<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Zyao</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Zyao">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Zyao">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Zyao" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zyao</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-system-design/website-architecture/关于大型网站系统架构你不得不懂的10个问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/website-architecture/%E5%85%B3%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%87%82%E7%9A%8410%E4%B8%AA%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.182Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>下面这些问题都是一线大厂的真实面试问题，不论是对你面试还是说拓宽知识面都很有帮助。之前发过一篇<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&mid=2247484416&idx=1&sn=6ced00d65491ef8fd33151bdfa8895c9&chksm=fd985261caefdb779412974a6a7207c93d0c2da5b28489afb74acd2fee28505daebbadb018ff&token=177958022&lang=zh_CN#rd">8 张图读懂大型网站技术架构</a> 可以作为不太了解大型网站系统技术架构朋友的入门文章。</p>
<!-- MarkdownTOC -->

<ul>
<li><a href="#1-%E4%BD%A0%E4%BD%BF%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E7%BB%84%E4%BB%B6%E6%88%96%E8%80%85%E6%96%B9%E6%B3%95%E6%9D%A5%E6%8F%90%E5%8D%87%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E5%8F%AF%E7%94%A8%E6%80%A7%E4%BB%A5%E5%8F%8A%E5%B9%B6%E5%8F%91%E9%87%8F">1. 你使用过哪些组件或者方法来提升网站性能,可用性以及并发量</a></li>
<li><a href="#2-%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B8%B8%E7%94%A8%E6%89%8B%E6%AE%B5">2. 设计高可用系统的常用手段</a></li>
<li><a href="#3-%E7%8E%B0%E4%BB%A3%E4%BA%92%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E9%80%9A%E5%B8%B8%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9">3. 现代互联网应用系统通常具有哪些特点?</a></li>
<li><a href="#4-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A2%86%E5%9F%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%92%8C%E8%AE%A4%E8%AF%86">4. 谈谈你对微服务领域的了解和认识</a></li>
<li><a href="#5-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-dubbo-%E5%92%8C-spring-cloud-%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%A4%E8%80%85%E5%85%B3%E7%B3%BB">5. 谈谈你对 Dubbo 和 Spring Cloud 的认识(两者关系)</a></li>
<li><a href="#6-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%BA%86%E8%A7%A3%E5%90%97%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7">6. 性能测试了解吗?说说你知道的性能测试工具?</a></li>
<li><a href="#7-%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E9%9A%8F%E7%9D%80%E4%BA%A7%E5%93%81%E4%BD%BF%E7%94%A8%E7%9A%84%E7%94%A8%E6%88%B7%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%9A%E7%BD%91%E7%AB%99%E7%9A%84%E6%B5%81%E9%87%8F%E4%BC%9A%E5%A2%9E%E5%8A%A0%E6%9C%80%E7%BB%88%E5%8D%95%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A0%E6%B3%95%E5%A4%84%E7%90%86%E9%82%A3%E4%B9%88%E5%A4%A7%E7%9A%84%E6%B5%81%E9%87%8F%E6%80%8E%E4%B9%88%E5%8A%9E">7. 对于一个单体应用系统,随着产品使用的用户越来越多,网站的流量会增加,最终单台服务器无法处理那么大的流量怎么办?</a></li>
<li><a href="#8-%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96%E7%9A%84%E5%B8%B8%E8%A7%81%E6%89%8B%E6%AE%B5">8. 大表优化的常见手段</a></li>
<li><a href="#9-%E5%9C%A8%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%83%BD%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84">9. 在系统中使用消息队列能带来什么好处?</a><ul>
<li><a href="#1-%E9%80%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD">1) 通过异步处理提高系统性能</a></li>
</ul>
</li>
<li><a href="#2-%E9%99%8D%E4%BD%8E%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88%E6%80%A7">2) 降低系统耦合性</a></li>
<li><a href="#10-%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E5%AF%B9-cap-%E5%AE%9A%E7%90%86base-%E7%90%86%E8%AE%BA%E7%9A%84%E4%BA%86%E8%A7%A3">10. 说说自己对 CAP 定理,BASE 理论的了解</a><ul>
<li><a href="#cap-%E5%AE%9A%E7%90%86">CAP 定理</a></li>
<li><a href="#base-%E7%90%86%E8%AE%BA">BASE 理论</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
<!-- /MarkdownTOC -->


<h3 id="1-你使用过哪些组件或者方法来提升网站性能-可用性以及并发量"><a href="#1-你使用过哪些组件或者方法来提升网站性能-可用性以及并发量" class="headerlink" title="1. 你使用过哪些组件或者方法来提升网站性能,可用性以及并发量"></a>1. 你使用过哪些组件或者方法来提升网站性能,可用性以及并发量</h3><ol>
<li><strong>提高硬件能力、增加系统服务器</strong>。（当服务器增加到某个程度的时候系统所能提供的并发访问量几乎不变，所以不能根本解决问题）</li>
<li><strong>使用缓存</strong>（本地缓存：本地可以使用JDK自带的 Map、Guava Cache.分布式缓存：Redis、Memcache.本地缓存不适用于提高系统并发量，一般是用在程序中。比如Spring是如何实现单例的呢？大家如果看过源码的话，应该知道，S把已经初始过的变量放在一个Map中，下次再要使用这个变量的时候，先判断Map中有没有，这也就是系统中常见的单例模式的实现。）</li>
<li><strong>消息队列</strong> （解耦+削峰+异步）</li>
<li><strong>采用分布式开发</strong> （不同的服务部署在不同的机器节点上，并且一个服务也可以部署在多台机器上，然后利用 Nginx 负载均衡访问。这样就解决了单点部署(All In)的缺点，大大提高的系统并发量）</li>
<li><strong>数据库分库（读写分离）、分表（水平分表、垂直分表）</strong></li>
<li><strong>采用集群</strong> （多台机器提供相同的服务）</li>
<li><strong>CDN 加速</strong> (将一些静态资源比如图片、视频等等缓存到离用户最近的网络节点)</li>
<li><strong>浏览器缓存</strong></li>
<li><strong>使用合适的连接池</strong>（数据库连接池、线程池等等）</li>
<li><strong>适当使用多线程进行开发。</strong></li>
</ol>
<h3 id="2-设计高可用系统的常用手段"><a href="#2-设计高可用系统的常用手段" class="headerlink" title="2. 设计高可用系统的常用手段"></a>2. 设计高可用系统的常用手段</h3><ol>
<li><strong>降级：</strong> 服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好；</li>
<li><strong>限流：</strong> 防止恶意请求流量、恶意攻击，或者防止流量超出系统峰值；</li>
<li><strong>缓存：</strong> 避免大量请求直接落到数据库，将数据库击垮；</li>
<li><strong>超时和重试机制：</strong> 避免请求堆积造成雪崩；</li>
<li><strong>回滚机制：</strong> 快速修复错误版本。</li>
</ol>
<h3 id="3-现代互联网应用系统通常具有哪些特点"><a href="#3-现代互联网应用系统通常具有哪些特点" class="headerlink" title="3. 现代互联网应用系统通常具有哪些特点?"></a>3. 现代互联网应用系统通常具有哪些特点?</h3><ol>
<li>高并发，大流量；</li>
<li>高可用：系统7×24小时不间断服务；</li>
<li>海量数据：需要存储、管理海量数据，需要使用大量服务器；</li>
<li>用户分布广泛，网络情况复杂：许多大型互联网都是为全球用户提供服务的，用户分布范围广，各地网络情况千差万别；</li>
<li>安全环境恶劣：由于互联网的开放性，使得互联网更容易受到攻击，大型网站几乎每天都会被黑客攻击；</li>
<li>需求快速变更，发布频繁：和传统软件的版本发布频率不同，互联网产品为快速适应市场，满足用户需求，其产品发布频率是极高的；</li>
<li>渐进式发展：与传统软件产品或企业应用系统一开始就规划好全部的功能和非功能需求不同，几乎所有的大型互联网网站都是从一个小网站开始，渐进地发展起来。</li>
</ol>
<h3 id="4-谈谈你对微服务领域的了解和认识"><a href="#4-谈谈你对微服务领域的了解和认识" class="headerlink" title="4. 谈谈你对微服务领域的了解和认识"></a>4. 谈谈你对微服务领域的了解和认识</h3><p>现在大公司都在用并且未来的趋势都是 Spring Cloud，而阿里开源的 Spring Cloud Alibaba 也是 Spring Cloud 规范的实现 。</p>
<p>我们通常把 Spring Cloud 理解为一系列开源组件的集合，但是 Spring Cloud并不是等同于 Spring Cloud Netflix 的 Ribbon、Feign、Eureka（停止更新）、Hystrix 这一套组件，而是抽象了一套通用的开发模式。它的目的是通过抽象出这套通用的模式，让开发者更快更好地开发业务。但是这套开发模式运行时的实际载体，还是依赖于 RPC、网关、服务发现、配置管理、限流熔断、分布式链路跟踪等组件的具体实现。</p>
<p>Spring Cloud Alibaba 是官方认证的新一套 Spring Cloud 规范的实现,Spring Cloud Alibaba 是一套国产开源产品集合，后续还会有中文 reference 和一些原理分析文章，所以，这对于国内的开发者是非常棒的一件事。阿里的这一举动势必会推动国内微服务技术的发展，因为在没有 Spring Cloud Alibaba 之前，我们的第一选择是 Spring Cloud Netflix，但是它们的文档都是英文的，出问题后排查也比较困难， 在国内并不是有特别多的人精通。Spring Cloud Alibaba 由阿里开源组件和阿里云产品组件两部分组成，其致力于提供微服务一站式解决方案，方便开发者通过 Spring Cloud 编程模型轻松开发微服务应用。</p>
<p>另外，Apache Dubbo Ecosystem 是围绕 Apache Dubbo 打造的微服务生态，是经过生产验证的微服务的最佳实践组合。在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。阿里后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。</p>
<h3 id="5-谈谈你对-Dubbo-和-Spring-Cloud-的认识-两者关系"><a href="#5-谈谈你对-Dubbo-和-Spring-Cloud-的认识-两者关系" class="headerlink" title="5. 谈谈你对 Dubbo 和 Spring Cloud 的认识(两者关系)"></a>5. 谈谈你对 Dubbo 和 Spring Cloud 的认识(两者关系)</h3><p>具体可以看公众号-阿里巴巴中间件的这篇文章:<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/iNVctXw7tUGHhnF0hV84ww">独家解读：Dubbo Ecosystem - 从微服务框架到微服务生态</a></p>
<p>Dubbo 与 Spring Cloud 并不是竞争关系，Dubbo 作为成熟的 RPC 框架，其易用性、扩展性和健壮性已得到业界的认可。未来 Dubbo 将会作为 Spring Cloud Alibaba 的 RPC 组件，并与 Spring Cloud 原生的 Feign 以及 RestTemplate 进行无缝整合，实现“零”成本迁移。</p>
<p>在阿里巴巴的微服务解决方案中，Dubbo、Nacos 和 Sentinel，以及后续将开源的微服务组件，都是 Dubbo EcoSystem 的一部分。我们后续也会将 Dubbo EcoSystem 集成到 Spring Cloud 的生态中。</p>
<h3 id="6-性能测试了解吗-说说你知道的性能测试工具"><a href="#6-性能测试了解吗-说说你知道的性能测试工具" class="headerlink" title="6. 性能测试了解吗?说说你知道的性能测试工具?"></a>6. 性能测试了解吗?说说你知道的性能测试工具?</h3><p>性能测试指通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。性能测试是总称，通常细分为：</p>
<ol>
<li><strong>基准测试：</strong> 在给系统施加较低压力时，查看系统的运行状况并记录相关数做为基础参考</li>
<li><strong>负载测试：</strong> 是指对系统不断地增加压力或增加一定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。此时继续加压，系统处理能力会下降。</li>
<li><strong>压力测试：</strong> 超过安全负载情况下，不断施加压力（增加并发请求），直到系统崩溃或无法处理任何请求，依此获得系统最大压力承受能力。</li>
<li><strong>稳定性测试：</strong> 被测试系统在特定硬件、软件、网络环境下，加载一定业务压力（模拟生产环境不同时间点、不均匀请求，呈波浪特性）运行一段较长时间，以此检测系统是否稳定。</li>
</ol>
<p>后端程序员或者测试平常比较常用的测试工具是 JMeter（官网：<a target="_blank" rel="noopener" href="https://jmeter.apache.org/">https://jmeter.apache.org/</a>）。Apache JMeter 是一款基于Java的压力测试工具(100％纯Java应用程序)，旨在加载测试功能行为和测量性能。它最初被设计用于 Web 应用测试但后来扩展到其他测试领域。</p>
<h3 id="7-对于一个单体应用系统-随着产品使用的用户越来越多-网站的流量会增加-最终单台服务器无法处理那么大的流量怎么办"><a href="#7-对于一个单体应用系统-随着产品使用的用户越来越多-网站的流量会增加-最终单台服务器无法处理那么大的流量怎么办" class="headerlink" title="7. 对于一个单体应用系统,随着产品使用的用户越来越多,网站的流量会增加,最终单台服务器无法处理那么大的流量怎么办?"></a>7. 对于一个单体应用系统,随着产品使用的用户越来越多,网站的流量会增加,最终单台服务器无法处理那么大的流量怎么办?</h3><p>这个时候就要考虑扩容了。《亿级流量网站架构核心技术》这本书上面介绍到我们可以考虑下面几步来解决这个问题：</p>
<ul>
<li>第一步，可以考虑简单的扩容来解决问题。比如增加系统的服务器，提高硬件能力等等。</li>
<li>第二步，如果简单扩容搞不定，就需要水平拆分和垂直拆分数据／应用来提升系统的伸缩性，即通过扩容提升系统负载能力。</li>
<li>第三步，如果通过水平拆分／垂直拆分还是搞不定，那就需要根据现有系统特性，架构层面进行重构甚至是重新设计，即推倒重来。</li>
</ul>
<p>对于系统设计，理想的情况下应支持线性扩容和弹性扩容，即在系统瓶颈时，只需要增加机器就可以解决系统瓶颈，如降低延迟提升吞吐量，从而实现扩容需求。</p>
<p>如果你想扩容，则支持水平/垂直伸缩是前提。在进行拆分时，一定要清楚知道自己的目的是什么，拆分后带来的问题如何解决，拆分后如果没有得到任何收益就不要为了<br>拆而拆，即不要过度拆分，要适合自己的业务。</p>
<h3 id="8-大表优化的常见手段"><a href="#8-大表优化的常见手段" class="headerlink" title="8. 大表优化的常见手段"></a>8. 大表优化的常见手段</h3><p>   当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</li>
<li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li><strong>垂直分区：</strong> <strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。<strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。<img src="https://user-gold-cdn.xitu.io/2018/6/16/164084354ba2e0fd?w=950&h=279&f=jpeg&s=26015"><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。<strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>
<li><strong>水平分区：</strong> <strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong> 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。<img src="https://user-gold-cdn.xitu.io/2018/6/16/164084b7e9e423e3?w=690&h=271&f=jpeg&s=23119" alt="数据库水平拆分">水平拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong>  ，跨界点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</li>
</ol>
<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>
<ul>
<li><strong>客户端代理：</strong>  <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>
<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<h3 id="9-在系统中使用消息队列能带来什么好处"><a href="#9-在系统中使用消息队列能带来什么好处" class="headerlink" title="9. 在系统中使用消息队列能带来什么好处?"></a>9. 在系统中使用消息队列能带来什么好处?</h3><p><strong>《大型网站技术架构》第四章和第七章均有提到消息队列对应用性能及扩展性的提升。</strong></p>
<h4 id="1-通过异步处理提高系统性能"><a href="#1-通过异步处理提高系统性能" class="headerlink" title="1) 通过异步处理提高系统性能"></a>1) 通过异步处理提高系统性能</h4><p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e63a8e34ba534?w=910&h=350&f=jpeg&s=29123" alt="通过异步处理提高系统性能"><br>如上图，<strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</strong></p>
<p>通过以上分析我们可以得出<strong>消息队列具有很好的削峰作用的功能</strong>——即<strong>通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</strong> 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e64583dd3ed01?w=780&h=384&f=jpeg&s=13550" alt="合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击"><br>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>
<h3 id="2-降低系统耦合性"><a href="#2-降低系统耦合性" class="headerlink" title="2) 降低系统耦合性"></a>2) 降低系统耦合性</h3><p>我们知道模块分布式部署以后聚合方式通常有两种：1.<strong>分布式消息队列</strong>和2.<strong>分布式服务</strong>。</p>
<blockquote>
<p><strong>先来简单说一下分布式服务：</strong></p>
</blockquote>
<p>目前使用比较多的用来构建<strong>SOA（Service Oriented Architecture面向服务体系结构）</strong>的<strong>分布式服务框架</strong>是阿里巴巴开源的<strong>Dubbo</strong>.如果想深入了解Dubbo的可以看我写的关于Dubbo的这一篇文章：<strong>《高性能优秀的服务框架-dubbo介绍》</strong>：<a target="_blank" rel="noopener" href="https://juejin.im/post/5acadeb1f265da2375072f9c">https://juejin.im/post/5acadeb1f265da2375072f9c</a></p>
<blockquote>
<p><strong>再来谈我们的分布式消息队列：</strong></p>
</blockquote>
<p>我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</p>
<p>我们最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e6665fa394b3b?w=790&h=290&f=jpeg&s=14946" alt="利用消息队列实现事件驱动结构"><br><strong>消息队列使利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p>
<p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>
<p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</strong>   </p>
<p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的，<strong>比如在我们的ActiveMQ消息队列中还有点对点工作模式</strong>，具体的会在后面的文章给大家详细介绍，这一篇文章主要还是让大家对消息队列有一个更透彻的了解。</p>
<blockquote>
<p>这个问题一般会在上一个问题问完之后，紧接着被问到。“使用消息队列会带来什么问题？”这个问题要引起重视，一般我们都会考虑使用消息队列会带来的好处而忽略它带来的问题！</p>
</blockquote>
<h3 id="10-说说自己对-CAP-定理-BASE-理论的了解"><a href="#10-说说自己对-CAP-定理-BASE-理论的了解" class="headerlink" title="10. 说说自己对 CAP 定理,BASE 理论的了解"></a>10. 说说自己对 CAP 定理,BASE 理论的了解</h3><h4 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/24/163912e973ecb93c?w=624&h=471&f=png&s=32984" alt="CAP定理"><br>在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<ul>
<li><strong>一致性（Consistence）</strong> :所有节点访问同一份最新的数据副本</li>
<li><strong>可用性（Availability）</strong>:每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据</li>
<li><strong>分区容错性（Partition tolerance）</strong> : 分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</li>
</ul>
<p>CAP仅适用于原子读写的NOSQL场景中，并不适合数据库系统。现在的分布式系统具有更多特性比如扩展性、可用性等等，在进行系统设计和开发时，我们不应该仅仅局限在CAP问题上。</p>
<p><strong>注意：不是所谓的3选2（不要被网上大多数文章误导了）:</strong></p>
<p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在CAP理论诞生12年之后，CAP之父也在2012年重写了之前的论文。</p>
<p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能2选1。也就是说当网络分区之后P是前提，决定了P之后才有C和A的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p>
<p>我在网上找了很多文章想看一下有没有文章提到这个不是所谓的3选2，用百度半天没找到了一篇，用谷歌搜索找到一篇比较不错的，如果想深入学习一下CAP就看这篇文章把，我这里就不多BB了：<strong>《分布式系统之CAP理论》 ：</strong> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/hxsyl/p/4381980.html">https://www.cnblogs.com/hxsyl/p/4381980.html</a></p>
<h4 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h4><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的，它大大降低了我们对系统的要求。</p>
<p><strong>BASE理论的核心思想：</strong> 即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>
<p><strong>BASE理论三要素：</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/24/163914806d9e15c6?w=612&h=461&f=png&s=39129" alt="BASE理论三要素"></p>
<ol>
<li><strong>基本可用：</strong> 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。 比如： <strong>①响应时间上的损失</strong>:正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒；<strong>②系统功能上的损失</strong>：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面；</li>
<li><strong>软状态：</strong> 软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时；</li>
<li><strong>最终一致性：</strong> 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《大型网站技术架构》</li>
<li>《亿级流量网站架构核心技术》</li>
<li>《Java工程师修炼之道》</li>
<li> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/puresoul/p/5456855.html">https://www.cnblogs.com/puresoul/p/5456855.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/website-architecture/%E5%85%B3%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%87%82%E7%9A%8410%E4%B8%AA%E9%97%AE%E9%A2%98/" data-id="cks75dy68000k7kve94vmc16c" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/website-architecture/8 张图读懂大型网站技术架构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/website-architecture/8%20%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.179Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文是作者读 《大型网站技术架构》所做的思维导图，在这里分享给各位，公众号(JavaGuide)后台回复：“架构”。即可获得下面图片的源文件以及思维导图源文件！</p>
</blockquote>
<!-- MarkdownTOC -->

<ul>
<li><a href="#1-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96">1. 大型网站架构演化</a></li>
<li><a href="#2-%E5%A4%A7%E5%9E%8B%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F">2. 大型架构模式</a></li>
<li><a href="#3-%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%A6%81%E7%B4%A0">3. 大型网站核心架构要素</a></li>
<li><a href="#4-%E7%9E%AC%E6%97%B6%E5%93%8D%E5%BA%94%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84">4. 瞬时响应:网站的高性能架构</a></li>
<li><a href="#5-%E4%B8%87%E6%97%A0%E4%B8%80%E5%A4%B1%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84">5. 万无一失:网站的高可用架构</a></li>
<li><a href="#6-%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83%E7%BD%91%E7%AB%99%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84">6. 永无止境:网站的伸缩性架构</a></li>
<li><a href="#7-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98%E7%BD%91%E7%AB%99%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E6%9E%B6%E6%9E%84">7. 随机应变:网站的可扩展性架构</a></li>
<li><a href="#8-%E5%9B%BA%E8%8B%A5%E9%87%91%E6%B1%A4%E7%BD%91%E7%AB%99%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E6%9E%84">8. 固若金汤:网站的安全机构</a></li>
</ul>
<!-- /MarkdownTOC -->


<h3 id="1-大型网站架构演化"><a href="#1-大型网站架构演化" class="headerlink" title="1. 大型网站架构演化"></a>1. 大型网站架构演化</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/1%20%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96.png" alt="1. 大型网站架构演化"></p>
<h3 id="2-大型架构模式"><a href="#2-大型架构模式" class="headerlink" title="2. 大型架构模式"></a>2. 大型架构模式</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2%20%E5%A4%A7%E5%9E%8B%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F.png" alt="2. 大型架构模式"></p>
<h3 id="3-大型网站核心架构要素"><a href="#3-大型网站核心架构要素" class="headerlink" title="3. 大型网站核心架构要素"></a>3. 大型网站核心架构要素</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/3%20%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E8%A6%81%E7%B4%A0.png" alt="3. 大型网站核心架构要素"></p>
<h3 id="4-瞬时响应-网站的高性能架构"><a href="#4-瞬时响应-网站的高性能架构" class="headerlink" title="4. 瞬时响应:网站的高性能架构"></a>4. 瞬时响应:网站的高性能架构</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/4%20%E7%9E%AC%E6%97%B6%E5%93%8D%E5%BA%94%EF%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84.png" alt="4. 瞬时响应:网站的高性能架构"></p>
<h3 id="5-万无一失-网站的高可用架构"><a href="#5-万无一失-网站的高可用架构" class="headerlink" title="5. 万无一失:网站的高可用架构"></a>5. 万无一失:网站的高可用架构</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/5%20%E4%B8%87%E6%97%A0%E4%B8%80%E5%A4%B1%EF%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="5. 万无一失:网站的高可用架构"></p>
<h3 id="6-永无止境-网站的伸缩性架构"><a href="#6-永无止境-网站的伸缩性架构" class="headerlink" title="6. 永无止境:网站的伸缩性架构"></a>6. 永无止境:网站的伸缩性架构</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/6%20%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83%EF%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84.png" alt="6. 永无止境:网站的伸缩性架构"></p>
<h3 id="7-随机应变-网站的可扩展性架构"><a href="#7-随机应变-网站的可扩展性架构" class="headerlink" title="7. 随机应变:网站的可扩展性架构"></a>7. 随机应变:网站的可扩展性架构</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/7%20%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98%EF%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%9E%B6%E6%9E%84.png" alt="7. 随机应变:网站的可扩展性架构"></p>
<h3 id="8-固若金汤-网站的安全机构"><a href="#8-固若金汤-网站的安全机构" class="headerlink" title="8. 固若金汤:网站的安全机构"></a>8. 固若金汤:网站的安全机构</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/8%20%E5%9B%BA%E8%8B%A5%E9%87%91%E6%B1%A4%EF%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E5%AE%89%E5%85%A8%E6%9E%B6%E6%9E%84.png" alt="enter image description here"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/website-architecture/8%20%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/" data-id="cks75dy5z000c7kve12b75qxw" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/micro-service/分布式id生成方案总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/micro-service/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.148Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>点击关注<a href="#%E5%85%AC%E4%BC%97%E5%8F%B7">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p>
<p>本文授权转载自：<a target="_blank" rel="noopener" href="https://juejin.im/post/5d6fc8eff265da03ef7a324b">https://juejin.im/post/5d6fc8eff265da03ef7a324b</a> ，作者：1点25。</p>
</blockquote>
<p>ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做<strong>分布式ID</strong>，或<strong>全局ID</strong>。下面来分析各个生成分布式ID的机制。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E5%88%86%E5%B8%83%E5%BC%8Fid%E6%96%B9%E6%A1%88.jpeg" alt="常用分布式id方案"></p>
<p>这篇文章并不会分析的特别详细，主要是做一些总结，以后再出一些详细某个方案的文章。</p>
<h2 id="数据库自增ID"><a href="#数据库自增ID" class="headerlink" title="数据库自增ID"></a>数据库自增ID</h2><p>第一种方案仍然还是基于数据库的自增ID，需要单独使用一个数据库实例，在这个实例中新建一个单独的表：</p>
<p>表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `SEQID`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SEQID.SEQUENCE_ID (</span><br><span class="line">	id <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment, </span><br><span class="line">	stub <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">	<span class="keyword">UNIQUE</span> KEY stub (stub)</span><br><span class="line">) ENGINE<span class="operator">=</span>MyISAM;</span><br></pre></td></tr></table></figure>

<p>可以使用下面的语句生成并获取到一个自增ID</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">replace <span class="keyword">into</span> SEQUENCE_ID (stub) <span class="keyword">VALUES</span> (<span class="string">&#x27;anyword&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> last_insert_id();</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>stub字段在这里并没有什么特殊的意义，只是为了方便的去插入数据，只有能插入数据才能产生自增id。而对于插入我们用的是replace，replace会先看是否存在stub指定值一样的数据，如果存在则先delete再insert，如果不存在则直接insert。</p>
<p>这种生成分布式ID的机制，需要一个单独的Mysql实例，虽然可行，但是基于性能与可靠性来考虑的话都不够，<strong>业务系统每次需要一个ID时，都需要请求数据库获取，性能低，并且如果此数据库实例下线了，那么将影响所有的业务系统。</strong></p>
<p>为了解决数据库可靠性问题，我们可以使用第二种分布式ID生成方案。</p>
<h2 id="数据库多主模式"><a href="#数据库多主模式" class="headerlink" title="数据库多主模式"></a>数据库多主模式</h2><p>如果我们两个数据库组成一个<strong>主从模式</strong>集群，正常情况下可以解决数据库可靠性问题，但是如果主库挂掉后，数据没有及时同步到从库，这个时候会出现ID重复的现象。我们可以使用<strong>双主模式</strong>集群，也就是两个Mysql实例都能单独的生产自增ID，这样能够提高效率，但是如果不经过其他改造的话，这两个Mysql实例很可能会生成同样的ID。需要单独给每个Mysql实例配置不同的起始值和自增步长。</p>
<p>第一台Mysql实例配置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_offset <span class="operator">=</span> <span class="number">1</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_increment <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure>

<p>第二台Mysql实例配置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_offset <span class="operator">=</span> <span class="number">2</span>;     <span class="comment">-- 起始值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@auto</span>_increment_increment <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">-- 步长</span></span><br></pre></td></tr></table></figure>

<p>经过上面的配置后，这两个Mysql实例生成的id序列如下： mysql1,起始值为1,步长为2,ID生成的序列为：1,3,5,7,9,… mysql2,起始值为2,步长为2,ID生成的序列为：2,4,6,8,10,…</p>
<p>对于这种生成分布式ID的方案，需要单独新增一个生成分布式ID应用，比如DistributIdService，该应用提供一个接口供业务应用获取ID，业务应用需要一个ID时，通过rpc的方式请求DistributIdService，DistributIdService随机去上面的两个Mysql实例中去获取ID。</p>
<p>实行这种方案后，就算其中某一台Mysql实例下线了，也不会影响DistributIdService，DistributIdService仍然可以利用另外一台Mysql来生成ID。</p>
<p>但是这种方案的扩展性不太好，如果两台Mysql实例不够用，需要新增Mysql实例来提高性能时，这时就会比较麻烦。</p>
<p>现在如果要新增一个实例mysql3，要怎么操作呢？ 第一，mysql1、mysql2的步长肯定都要修改为3，而且只能是人工去修改，这是需要时间的。 第二，因为mysql1和mysql2是不停在自增的，对于mysql3的起始值我们可能要定得大一点，以给充分的时间去修改mysql1，mysql2的步长。 第三，在修改步长的时候很可能会出现重复ID，要解决这个问题，可能需要停机才行。</p>
<p>为了解决上面的问题，以及能够进一步提高DistributIdService的性能，如果使用第三种生成分布式ID机制。</p>
<h2 id="号段模式"><a href="#号段模式" class="headerlink" title="号段模式"></a>号段模式</h2><p>我们可以使用号段的方式来获取自增ID，号段可以理解成批量获取，比如DistributIdService从数据库获取ID时，如果能批量获取多个ID并缓存在本地的话，那样将大大提供业务应用获取ID的效率。</p>
<p>比如DistributIdService每次从数据库获取ID时，就获取一个号段，比如(1,1000]，这个范围表示了1000个ID，业务应用在请求DistributIdService提供ID时，DistributIdService只需要在本地从1开始自增并返回即可，而不需要每次都请求数据库，一直到本地自增到1000时，也就是当前号段已经被用完时，才去数据库重新获取下一号段。</p>
<p>所以，我们需要对数据库表进行改动，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> id_generator (</span><br><span class="line">  id <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  current_max_id <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;当前最大id&#x27;</span>,</span><br><span class="line">  increment_step <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;号段的长度&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>这个数据库表用来记录自增步长以及当前自增ID的最大值（也就是当前已经被申请的号段的最后一个值），因为自增逻辑被移到DistributIdService中去了，所以数据库不需要这部分逻辑了。</p>
<p>这种方案不再强依赖数据库，就算数据库不可用，那么DistributIdService也能继续支撑一段时间。但是如果DistributIdService重启，会丢失一段ID，导致ID空洞。</p>
<p>为了提高DistributIdService的高可用，需要做一个集群，业务在请求DistributIdService集群获取ID时，会随机的选择某一个DistributIdService节点进行获取，对每一个DistributIdService节点来说，数据库连接的是同一个数据库，那么可能会产生多个DistributIdService节点同时请求数据库获取号段，那么这个时候需要利用乐观锁来进行控制，比如在数据库表中增加一个version字段，在获取号段时使用如下SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update id_generator <span class="keyword">set</span> current_max_id<span class="operator">=</span>#&#123;newMaxId&#125;, version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> version <span class="operator">=</span> #&#123;version&#125;</span><br></pre></td></tr></table></figure>

<p>因为newMaxId是DistributIdService中根据oldMaxId+步长算出来的，只要上面的update更新成功了就表示号段获取成功了。</p>
<p>为了提供数据库层的高可用，需要对数据库使用多主模式进行部署，对于每个数据库来说要保证生成的号段不重复，这就需要利用最开始的思路，再在刚刚的数据库表中增加起始值和步长，比如如果现在是两台Mysql，那么 mysql1将生成号段（1,1001]，自增的时候序列为1，3，5，7…. mysql1将生成号段（2,1002]，自增的时候序列为2，4，6，8，10…</p>
<p>更详细的可以参考滴滴开源的TinyId：<a target="_blank" rel="noopener" href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D">github.com/didi/tinyid…</a></p>
<p>在TinyId中还增加了一步来提高效率，在上面的实现中，ID自增的逻辑是在DistributIdService中实现的，而实际上可以把自增的逻辑转移到业务应用本地，这样对于业务应用来说只需要获取号段，每次自增时不再需要请求调用DistributIdService了。</p>
<h2 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>上面的三种方法总的来说是基于自增思想的，而接下来就介绍比较著名的雪花算法-snowflake。</p>
<p>我们可以换个角度来对分布式ID进行思考，只要能让负责生成分布式ID的每台机器在每毫秒内生成不一样的ID就行了。</p>
<p>snowflake是twitter开源的分布式ID生成算法，是一种算法，所以它和上面的三种生成分布式ID机制不太一样，它不依赖数据库。</p>
<p>核心思想是：分布式ID固定是一个long型的数字，一个long型占8个字节，也就是64个bit，原始snowflake算法中对于bit的分配如下图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.png" alt="雪花算法"></p>
<ul>
<li>第一个bit位是标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以固定为0。</li>
<li>时间戳部分占41bit，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li>
<li>工作机器id占10bit，这里比较灵活，比如，可以使用前5位作为数据中心机房标识，后5位作为单机房机器标识，可以部署1024个节点。</li>
<li>序列号部分占12bit，支持同一毫秒内同一个节点可以生成4096个ID</li>
</ul>
<p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p>
<p>snowflake算法实现起来并不难，提供一个github上用java实现的：<a target="_blank" rel="noopener" href="https://github.com/beyondfengyu/SnowFlake">github.com/beyondfengy…</a></p>
<p>在大厂里，其实并没有直接使用snowflake，而是进行了改造，因为snowflake算法中最难实践的就是工作机器id，原始的snowflake算法需要人工去为每台机器去指定一个机器id，并配置在某个地方从而让snowflake从此处获取机器id。</p>
<p>但是在大厂里，机器是很多的，人力成本太大且容易出错，所以大厂对snowflake进行了改造。</p>
<h3 id="百度（uid-generator）"><a href="#百度（uid-generator）" class="headerlink" title="百度（uid-generator）"></a>百度（uid-generator）</h3><p>github地址：<a target="_blank" rel="noopener" href="https://github.com/baidu/uid-generator">uid-generator</a></p>
<p>uid-generator使用的就是snowflake，只是在生产机器id，也叫做workId时有所不同。</p>
<p>uid-generator中的workId是由uid-generator自动生成的，并且考虑到了应用部署在docker上的情况，在uid-generator中用户可以自己去定义workId的生成策略，默认提供的策略是：应用启动时由数据库分配。说的简单一点就是：应用在启动时会往数据库表(uid-generator需要新增一个WORKER_NODE表)中去插入一条数据，数据插入成功后返回的该数据对应的自增唯一id就是该机器的workId，而数据由host，port组成。</p>
<p>对于uid-generator中的workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，同一个应用每重启一次就会消费一个workId。</p>
<p>具体可参考<a target="_blank" rel="noopener" href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">github.com/baidu/uid-g…</a></p>
<h3 id="美团（Leaf）"><a href="#美团（Leaf）" class="headerlink" title="美团（Leaf）"></a>美团（Leaf）</h3><p>github地址：<a target="_blank" rel="noopener" href="https://github.com/Meituan-Dianping/Leaf">Leaf</a></p>
<p>美团的Leaf也是一个分布式ID生成框架。它非常全面，即支持号段模式，也支持snowflake模式。号段模式这里就不介绍了，和上面的分析类似。</p>
<p>Leaf中的snowflake模式和原始snowflake算法的不同点，也主要在workId的生成，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，在启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总得来说，上面两种都是自动生成workId，以让系统更加稳定以及减少人工成功。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>这里额外再介绍一下使用Redis来生成分布式ID，其实和利用Mysql自增ID类似，可以利用Redis中的incr命令来实现原子性的自增与返回，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set seq_id 1     // 初始化自增ID为1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>使用redis的效率是非常高的，但是要考虑持久化的问题。Redis支持RDB和AOF两种持久化的方式。</p>
<p>RDB持久化相当于定时打一个快照进行持久化，如果打完快照后，连续自增了几次，还没来得及做下一次快照持久化，这个时候Redis挂掉了，重启Redis后会出现ID重复。</p>
<p>AOF持久化相当于对每条写命令进行持久化，如果Redis挂掉了，不会出现ID重复的现象，但是会由于incr命令过得，导致重启恢复数据时间过长。</p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p>
<p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#%E5%85%AC%E4%BC%97%E5%8F%B7">公众号</a>后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p>
<p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/167598cd2e17b8ec.png" alt="我的公众号"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/micro-service/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/" data-id="cks75dy5u00097kve3odpdzwj" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/micro-service/spring-cloud" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/micro-service/spring-cloud/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.145Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文基于 Spring Cloud Netflix 。Spring Cloud Alibaba 也是非常不错的选择哦！</p>
<p>授权转载自：<a target="_blank" rel="noopener" href="https://juejin.im/post/5de2553e5188256e885f4fa3">https://juejin.im/post/5de2553e5188256e885f4fa3</a></p>
</blockquote>
<p>首先我给大家看一张图，如果大家对这张图有些地方不太理解的话，我希望你们看完我这篇文章会恍然大悟。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/spring-cloud%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84.jpg" alt="Spring Cloud 总体架构"></p>
<h2 id="什么是Spring-cloud"><a href="#什么是Spring-cloud" class="headerlink" title="什么是Spring cloud"></a>什么是Spring cloud</h2><blockquote>
<p>构建分布式系统不需要复杂和容易出错。Spring Cloud 为最常见的分布式系统模式提供了一种简单且易于接受的编程模型，帮助开发人员构建有弹性的、可靠的、协调的应用程序。Spring Cloud 构建于 Spring Boot 之上，使得开发者很容易入手并快速应用于生产中。</p>
</blockquote>
<p>官方果然官方，介绍都这么有板有眼的。</p>
<p>我所理解的 <code>Spring Cloud</code> 就是微服务系统架构的一站式解决方案，在平时我们构建微服务的过程中需要做如 <strong>服务发现注册</strong> 、<strong>配置中心</strong> 、<strong>消息总线</strong> 、<strong>负载均衡</strong> 、<strong>断路器</strong> 、<strong>数据监控</strong> 等操作，而 Spring Cloud 为我们提供了一套简易的编程模型，使我们能在 Spring Boot 的基础上轻松地实现微服务项目的构建。</p>
<h2 id="Spring-Cloud-的版本"><a href="#Spring-Cloud-的版本" class="headerlink" title="Spring Cloud 的版本"></a>Spring Cloud 的版本</h2><p>当然这个只是个题外话。</p>
<p><code>Spring Cloud</code> 的版本号并不是我们通常见的数字版本号，而是一些很奇怪的单词。这些单词均为英国伦敦地铁站的站名。同时根据字母表的顺序来对应版本时间顺序，比如：最早 的 <code>Release</code> 版本 <code>Angel</code>，第二个 <code>Release</code> 版本 <code>Brixton</code>（英国地名），然后是 <code>Camden</code>、 <code>Dalston</code>、<code>Edgware</code>、<code>Finchley</code>、<code>Greenwich</code>、<code>Hoxton</code>。</p>
<h2 id="Spring-Cloud-的服务发现框架——Eureka"><a href="#Spring-Cloud-的服务发现框架——Eureka" class="headerlink" title="Spring Cloud 的服务发现框架——Eureka"></a>Spring Cloud 的服务发现框架——Eureka</h2><blockquote>
<p><code>Eureka</code>是基于<code>REST</code>（代表性状态转移）的服务，主要在 <code>AWS</code> 云中用于定位服务，以实现负载均衡和中间层服务器的故障转移。我们称此服务为<code>Eureka</code>服务器。Eureka还带有一个基于 <code>Java</code> 的客户端组件 <code>Eureka Client</code>，它使与服务的交互变得更加容易。客户端还具有一个内置的负载平衡器，可以执行基本的循环负载平衡。在 <code>Netflix</code>，更复杂的负载均衡器将 <code>Eureka</code> 包装起来，以基于流量，资源使用，错误条件等多种因素提供加权负载均衡，以提供出色的弹性。</p>
</blockquote>
<p>总的来说，<code>Eureka</code> 就是一个服务发现框架。何为服务，何又为发现呢？</p>
<p>举一个生活中的例子，就比如我们平时租房子找中介的事情。</p>
<p>在没有中介的时候我们需要一个一个去寻找是否有房屋要出租的房东，这显然会非常的费力，一你找凭一个人的能力是找不到很多房源供你选择，再者你也懒得这么找下去(找了这么久，没有合适的只能将就)。<strong>这里的我们就相当于微服务中的 <code>Consumer</code> ，而那些房东就相当于微服务中的 <code>Provider</code> 。消费者 <code>Consumer</code> 需要调用提供者 <code>Provider</code> 提供的一些服务，就像我们现在需要租他们的房子一样。</strong></p>
<p>但是如果只是租客和房东之间进行寻找的话，他们的效率是很低的，房东找不到租客赚不到钱，租客找不到房东住不了房。所以，后来房东肯定就想到了广播自己的房源信息(比如在街边贴贴小广告)，这样对于房东来说已经完成他的任务(将房源公布出去)，但是有两个问题就出现了。第一、其他不是租客的都能收到这种租房消息，这在现实世界没什么，但是在计算机的世界中就会出现 <strong>资源消耗</strong> 的问题了。第二、租客这样还是很难找到你，试想一下我需要租房，我还需要东一个西一个地去找街边小广告，麻不麻烦？</p>
<p>那怎么办呢？我们当然不会那么傻乎乎的，第一时间就是去找 <strong>中介</strong> 呀，它为我们提供了统一房源的地方，我们消费者只需要跑到它那里去找就行了。而对于房东来说，他们也只需要把房源在中介那里发布就行了。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/4d161e2950414113834f2f0a8fc2c16c-new-imaged17347a0-e653-4830-9542-3d7ae4305b2b.png"></p>
<p>那么现在，我们的模式就是这样的了。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/24382ce6bbd44932ac38b1accade12d1-new-image2ff8affc-6f1d-49de-a8c3-801e7bad2b11.png"></p>
<p>但是，这个时候还会出现一些问题。</p>
<ol>
<li>房东注册之后如果不想卖房子了怎么办？我们是不是需要让房东 <strong>定期续约</strong> ？如果房东不进行续约是不是要将他们从中介那里的注册列表中 <strong>移除</strong> 。</li>
<li>租客是不是也要进行 <strong>注册</strong> 呢？不然合同乙方怎么来呢？</li>
<li>中介可不可以做 <strong>连锁店</strong> 呢？如果这一个店因为某些不可抗力因素而无法使用，那么我们是否可以换一个连锁店呢？</li>
</ol>
<p>针对上面的问题我们来重新构建一下上面的模式图</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E7%A7%9F%E6%88%BF-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F%E5%9B%BE.jpg" alt="租房-中介模式图"></p>
<p>好了，举完这个:chestnut:我们就可以来看关于 <code>Eureka</code> 的一些基础概念了，你会发现这东西理解起来怎么这么简单。:punch::punch::punch:</p>
<p><strong>服务发现</strong>：其实就是一个“中介”，整个过程中有三个角色：**服务提供者(出租房子的)、服务消费者(租客)、服务中介(房屋中介)**。</p>
<p><strong>服务提供者</strong>： 就是提供一些自己能够执行的一些服务给外界。</p>
<p><strong>服务消费者</strong>： 就是需要使用一些服务的“用户”。</p>
<p><strong>服务中介</strong>： 其实就是服务提供者和服务消费者之间的“桥梁”，服务提供者可以把自己注册到服务中介那里，而服务消费者如需要消费一些服务(使用一些功能)就可以在服务中介中寻找注册在服务中介的服务提供者。</p>
<p><strong>服务注册 Register</strong>：</p>
<p>官方解释：当 <code>Eureka</code> 客户端向 <code>Eureka Server</code> 注册时，它提供自身的<strong>元数据</strong>，比如IP地址、端口，运行状况指示符URL，主页等。</p>
<p>结合中介理解：房东 (提供者 <code>Eureka Client Provider</code>)在中介 (服务器 <code>Eureka Server</code>) 那里登记房屋的信息，比如面积，价格，地段等等(元数据 <code>metaData</code>)。</p>
<p><strong>服务续约 Renew</strong>：</p>
<p>官方解释：**<code>Eureka</code> 客户会每隔30秒(默认情况下)发送一次心跳来续约**。 通过续约来告知 <code>Eureka Server</code> 该 <code>Eureka</code> 客户仍然存在，没有出现问题。 正常情况下，如果 <code>Eureka Server</code> 在90秒没有收到 <code>Eureka</code> 客户的续约，它会将实例从其注册表中删除。</p>
<p>结合中介理解：房东 (提供者 <code>Eureka Client Provider</code>) 定期告诉中介 (服务器 <code>Eureka Server</code>) 我的房子还租(续约) ，中介 (服务器<code>Eureka Server</code>) 收到之后继续保留房屋的信息。</p>
<p><strong>获取注册列表信息 Fetch Registries</strong>： </p>
<p>官方解释：<code>Eureka</code> 客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与 <code>Eureka</code> 客户端的缓存信息不同, <code>Eureka</code> 客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，<code>Eureka</code> 客户端则会重新获取整个注册表信息。 <code>Eureka</code> 服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。<code>Eureka</code> 客户端和 <code>Eureka</code> 服务器可以使用JSON / XML格式进行通讯。在默认的情况下 <code>Eureka</code> 客户端使用压缩 <code>JSON</code> 格式来获取注册列表的信息。</p>
<p>结合中介理解：租客(消费者 <code>Eureka Client Consumer</code>) 去中介 (服务器 <code>Eureka Server</code>) 那里获取所有的房屋信息列表 (客户端列表 <code>Eureka Client List</code>) ，而且租客为了获取最新的信息会定期向中介 (服务器 <code>Eureka Server</code>) 那里获取并更新本地列表。</p>
<p><strong>服务下线 Cancel</strong>：</p>
<p>官方解释：Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：<code>DiscoveryManager.getInstance().shutdownComponent();</code></p>
<p>结合中介理解：房东 (提供者 <code>Eureka Client Provider</code>) 告诉中介  (服务器 <code>Eureka Server</code>) 我的房子不租了，中介之后就将注册的房屋信息从列表中剔除。</p>
<p><strong>服务剔除 Eviction</strong>：</p>
<p>官方解释：在默认的情况下，<strong>当Eureka客户端连续90秒(3个续约周期)没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除</strong>，即服务剔除。</p>
<p>结合中介理解：房东(提供者 <code>Eureka Client Provider</code>) 会定期联系 中介  (服务器 <code>Eureka Server</code>) 告诉他我的房子还租(续约)，如果中介  (服务器 <code>Eureka Server</code>) 长时间没收到提供者的信息，那么中介会将他的房屋信息给下架(服务剔除)。</p>
<p>下面就是 <code>Netflix</code> 官方给出的 <code>Eureka</code> 架构图，你会发现和我们前面画的中介图别无二致。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/5d723c49eca1468ab7b89af06743023c-new-imageb8aa3d41-fad4-4b38-add9-c304930ab285.png" alt="Eureka架构图"></p>
<p>当然，可以充当服务发现的组件有很多：<code>Zookeeper</code> ，<code>Consul</code> ， <code>Eureka</code> 等。</p>
<p>更多关于 <code>Eureka</code> 的知识(自我保护，初始注册策略等等)可以自己去官网查看，或者查看我的另一篇文章 <a target="_blank" rel="noopener" href="https://juejin.im/post/5dd497e3f265da0ba7718018">深入理解 Eureka</a>。</p>
<h2 id="负载均衡之-Ribbon"><a href="#负载均衡之-Ribbon" class="headerlink" title="负载均衡之 Ribbon"></a>负载均衡之 Ribbon</h2><h3 id="什么是-RestTemplate"><a href="#什么是-RestTemplate" class="headerlink" title="什么是 RestTemplate?"></a>什么是 <code>RestTemplate</code>?</h3><p>不是讲 <code>Ribbon</code> 么？怎么扯到了 <code>RestTemplate</code> 了？你先别急，听我慢慢道来。</p>
<p>我不听我不听我不听:hear_no_evil::hear_no_evil::hear_no_evil:。</p>
<p>我就说一句！**<code>RestTemplate</code>是<code>Spring</code>提供的一个访问Http服务的客户端类**，怎么说呢？就是微服务之间的调用是使用的 <code>RestTemplate</code> 。比如这个时候我们 消费者B 需要调用 提供者A 所提供的服务我们就需要这么写。如我下面的伪代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"><span class="comment">// 这里是提供者A的ip地址，但是如果使用了 Eureka 那么就应该是提供者A的名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_PROVIDER_A = <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/judge&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="meta">@RequestBody</span> Request request)</span> </span>&#123;</span><br><span class="line">    String url = SERVICE_PROVIDER_A + <span class="string">&quot;/service1&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.postForObject(url, request, Boolean.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 如果你对源码感兴趣的话，你会发现上面我们所讲的 <code>Eureka</code> 框架中的 <strong>注册</strong>、<strong>续约</strong> 等，底层都是使用的 <code>RestTemplate</code> 。</p>
<h3 id="为什么需要-Ribbon？"><a href="#为什么需要-Ribbon？" class="headerlink" title="为什么需要 Ribbon？"></a>为什么需要 Ribbon？</h3><p><code>Ribbon</code>  是 <code>Netflix</code> 公司的一个开源的负载均衡 项目，是一个客户端/进程内负载均衡器，<strong>运行在消费者端</strong>。</p>
<p>我们再举个:chestnut:，比如我们设计了一个秒杀系统，但是为了整个系统的 <strong>高可用</strong> ，我们需要将这个系统做一个集群，而这个时候我们消费者就可以拥有多个秒杀系统的调用途径了，如下图。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/秒杀系统-ribbon.jpg" style="zoom:50%;" />

<p>如果这个时候我们没有进行一些 <strong>均衡操作</strong> ，如果我们对 <code>秒杀系统1</code> 进行大量的调用，而另外两个基本不请求，就会导致 <code>秒杀系统1</code> 崩溃，而另外两个就变成了傀儡，那么我们为什么还要做集群，我们高可用体现的意义又在哪呢？</p>
<p>所以 <code>Ribbon</code> 出现了，注意我们上面加粗的几个字——<strong>运行在消费者端</strong>。指的是，<code>Ribbon</code> 是运行在消费者端的负载均衡器，如下图。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/秒杀系统-ribbon2.jpg" style="zoom:50%;" />

<p>其工作原理就是 <code>Consumer</code> 端获取到了所有的服务列表之后，在其<strong>内部</strong>使用<strong>负载均衡算法</strong>，进行对多个系统的调用。</p>
<h3 id="Nginx-和-Ribbon-的对比"><a href="#Nginx-和-Ribbon-的对比" class="headerlink" title="Nginx 和 Ribbon 的对比"></a>Nginx 和 Ribbon 的对比</h3><p>提到 <strong>负载均衡</strong> 就不得不提到大名鼎鼎的 <code>Nignx</code> 了，而和 <code>Ribbon</code> 不同的是，它是一种<strong>集中式</strong>的负载均衡器。</p>
<p>何为集中式呢？简单理解就是 <strong>将所有请求都集中起来，然后再进行负载均衡</strong>。如下图。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/nginx-vs-ribbon1.jpg" style="zoom:50%;" />

<p>我们可以看到 <code>Nginx</code> 是接收了所有的请求进行负载均衡的，而对于 <code>Ribbon</code> 来说它是在消费者端进行的负载均衡。如下图。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/nginx-vs-ribbon2.jpg" style="zoom:50%;" />

<blockquote>
<p>请注意 <code>Request</code> 的位置，在 <code>Nginx</code> 中请求是先进入负载均衡器，而在 <code>Ribbon</code> 中是先在客户端进行负载均衡才进行请求的。</p>
</blockquote>
<h3 id="Ribbon-的几种负载均衡算法"><a href="#Ribbon-的几种负载均衡算法" class="headerlink" title="Ribbon 的几种负载均衡算法"></a>Ribbon 的几种负载均衡算法</h3><p>负载均衡，不管 <code>Nginx</code> 还是 <code>Ribbon</code> 都需要其算法的支持，如果我没记错的话 <code>Nginx</code> 使用的是 轮询和加权轮询算法。而在 <code>Ribbon</code> 中有更多的负载均衡调度算法，其默认是使用的 <code>RoundRobinRule</code> 轮询策略。</p>
<ul>
<li>**<code>RoundRobinRule</code>**：轮询策略。<code>Ribbon</code> 默认采用的策略。若经过一轮轮询没有找到可用的 <code>provider</code>，其最多轮询 10 轮。若最终还没有找到，则返回 <code>null</code>。</li>
<li><strong><code>RandomRule</code></strong>: 随机策略，从所有可用的 <code>provider</code> 中随机选择一个。</li>
<li><strong><code>RetryRule</code></strong>: 重试策略。先按照 <code>RoundRobinRule</code> 策略获取 <code>provider</code>，若获取失败，则在指定的时限内重试。默认的时限为 500 毫秒。</li>
</ul>
<p>🐦🐦🐦 还有很多，这里不一一举:chestnut:了，你最需要知道的是默认轮询算法，并且可以更换默认的负载均衡算法，只需要在配置文件中做出修改就行。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">providerName:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure>

<p>当然，在 <code>Ribbon</code> 中你还可以<strong>自定义负载均衡算法</strong>，你只需要实现 <code>IRule</code> 接口，然后修改配置文件或者自定义 <code>Java Config</code> 类。</p>
<h2 id="什么是-Open-Feign"><a href="#什么是-Open-Feign" class="headerlink" title="什么是 Open Feign"></a>什么是 Open Feign</h2><p>有了 <code>Eureka</code>  ，<code>RestTemplate</code> ，<code>Ribbon</code>，  我们就可以愉快地进行服务间的调用了，但是使用 <code>RestTemplate</code> 还是不方便，我们每次都要进行这样的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"><span class="comment">// 这里是提供者A的ip地址，但是如果使用了 Eureka 那么就应该是提供者A的名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICE_PROVIDER_A = <span class="string">&quot;http://localhost:8081&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/judge&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="meta">@RequestBody</span> Request request)</span> </span>&#123;</span><br><span class="line">    String url = SERVICE_PROVIDER_A + <span class="string">&quot;/service1&quot;</span>;</span><br><span class="line">    <span class="comment">// 是不是太麻烦了？？？每次都要 url、请求、返回类型的 </span></span><br><span class="line">    <span class="keyword">return</span> restTemplate.postForObject(url, request, Boolean.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样每次都调用 <code>RestRemplate</code> 的 <code>API</code> 是否太麻烦，我能不能像<strong>调用原来代码一样进行各个服务间的调用呢？</strong></p>
<p>:bulb::bulb::bulb:聪明的小朋友肯定想到了，那就用 <strong>映射</strong> 呀，就像域名和IP地址的映射。我们可以将被调用的服务代码映射到消费者端，这样我们就可以 **“无缝开发” **啦。</p>
<blockquote>
<p> <code>OpenFeign</code> 也是运行在消费者端的，使用 <code>Ribbon</code> 进行负载均衡，所以 <code>OpenFeign</code> 直接内置了 <code>Ribbon</code>。</p>
</blockquote>
<p>在导入了 <code>Open Feign</code> 之后我们就可以进行愉快编写  <code>Consumer</code> 端代码了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 @FeignClient 注解来指定提供者的名字</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;eureka-client-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里一定要注意需要使用的是提供者那端的请求相对路径，这里就相当于映射了</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/provider/xxx&quot;,</span></span><br><span class="line"><span class="meta">    method = RequestMethod.POST)</span></span><br><span class="line">    CommonResponse&lt;List&lt;Plan&gt;&gt; getPlans(<span class="meta">@RequestBody</span> planGetRequest request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们在 <code>Controller</code> 就可以像原来调用 <code>Service</code> 层代码一样调用它了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里就相当于原来自动注入的 Service</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestClient testClient;</span><br><span class="line">    <span class="comment">// controller 调用 service 层代码</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> CommonResponse&lt;List&lt;Plan&gt;&gt; get(<span class="meta">@RequestBody</span> planGetRequest request) &#123;</span><br><span class="line">        <span class="keyword">return</span> testClient.getPlans(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="必不可少的-Hystrix"><a href="#必不可少的-Hystrix" class="headerlink" title="必不可少的 Hystrix"></a>必不可少的 Hystrix</h2><h3 id="什么是-Hystrix之熔断和降级"><a href="#什么是-Hystrix之熔断和降级" class="headerlink" title="什么是 Hystrix之熔断和降级"></a>什么是 Hystrix之熔断和降级</h3><blockquote>
<p>在分布式环境中，不可避免地会有许多服务依赖项中的某些失败。Hystrix是一个库，可通过添加等待时间容限和容错逻辑来帮助您控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点，停止服务之间的级联故障并提供后备选项来实现此目的，所有这些都可以提高系统的整体弹性。</p>
</blockquote>
<p>总体来说 <code>Hystrix</code> 就是一个能进行 <strong>熔断</strong> 和 <strong>降级</strong> 的库，通过使用它能提高整个系统的弹性。</p>
<p>那么什么是 熔断和降级 呢？再举个:chestnut:，此时我们整个微服务系统是这样的。服务A调用了服务B，服务B再调用了服务C，但是因为某些原因，服务C顶不住了，这个时候大量请求会在服务C阻塞。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/Hystrix1.jpg" style="zoom:50%;" />

<p>服务C阻塞了还好，毕竟只是一个系统崩溃了。但是请注意这个时候因为服务C不能返回响应，那么服务B调用服务C的的请求就会阻塞，同理服务B阻塞了，那么服务A也会阻塞崩溃。</p>
<blockquote>
<p>请注意，为什么阻塞会崩溃。因为这些请求会消耗占用系统的线程、IO 等资源，消耗完你这个系统服务器不就崩了么。</p>
</blockquote>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/Hystrix2.jpg" style="zoom:50%;" />

<p>这就叫 <strong>服务雪崩</strong>。妈耶，上面两个 <strong>熔断</strong> 和 <strong>降级</strong> 你都没给我解释清楚，你现在又给我扯什么 <strong>服务雪崩</strong> ？:tired_face::tired_face::tired_face:</p>
<p>别急，听我慢慢道来。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/513d7e7f6d574fd799195d05556f4aa7-new-image9265b6bd-41ca-4e62-86f3-4341e5bdbe6c.png"></p>
<p>不听我也得讲下去！</p>
<p>所谓 <strong>熔断</strong> 就是服务雪崩的一种有效解决方案。当指定时间窗内的请求失败率达到设定阈值时，系统将通过 <strong>断路器</strong> 直接将此请求链路断开。</p>
<p>也就是我们上面服务B调用服务C在指定时间窗内，调用的失败率到达了一定的值，那么 <code>Hystrix</code> 则会自动将 服务B与C 之间的请求都断了，以免导致服务雪崩现象。</p>
<p>其实这里所讲的 <strong>熔断</strong> 就是指的 <code>Hystrix</code> 中的 <strong>断路器模式</strong> ，你可以使用简单的 <code>@HystrixCommand</code> 注解来标注某个方法，这样 <code>Hystrix</code> 就会使用 <strong>断路器</strong> 来“包装”这个方法，每当调用时间超过指定时间时(默认为1000ms)，断路器将会中断对这个方法的调用。</p>
<p>当然你可以对这个注解的很多属性进行设置，比如设置超时时间，像这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(</span></span><br><span class="line"><span class="meta">    commandProperties = &#123;@HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;,value = &quot;1200&quot;)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Xxx&gt; <span class="title">getXxxx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...省略代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我查阅了一些博客，发现他们都将 <strong>熔断</strong> 和 <strong>降级</strong> 的概念混淆了，以我的理解，<strong>降级是为了更好的用户体验，当一个方法调用异常时，通过执行另一种代码逻辑来给用户友好的回复</strong>。这也就对应着 <code>Hystrix</code> 的 <strong>后备处理</strong> 模式。你可以通过设置 <code>fallbackMethod</code> 来给一个方法设置备用的代码逻辑。比如这个时候有一个热点新闻出现了，我们会推荐给用户查看详情，然后用户会通过id去查询新闻的详情，但是因为这条新闻太火了(比如最近什么*易对吧)，大量用户同时访问可能会导致系统崩溃，那么我们就进行 <strong>服务降级</strong> ，一些请求会做一些降级处理比如当前人数太多请稍后查看等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定了后备方法调用</span></span><br><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;getHystrixNews&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/get/news&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> News <span class="title">getNews</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用新闻系统的获取新闻api 代码逻辑省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> News <span class="title">getHystrixNews</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做服务降级</span></span><br><span class="line">    <span class="comment">// 返回当前人数太多，请稍后查看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="什么是Hystrix之其他"><a href="#什么是Hystrix之其他" class="headerlink" title="什么是Hystrix之其他"></a>什么是Hystrix之其他</h3><p>我在阅读 《Spring微服务实战》这本书的时候还接触到了一个 <strong>舱壁模式</strong> 的概念。在不使用舱壁模式的情况下，服务A调用服务B，这种调用默认的是 <strong>使用同一批线程来执行</strong> 的，而在一个服务出现性能问题的时候，就会出现所有线程被刷爆并等待处理工作，同时阻塞新请求，最终导致程序崩溃。而舱壁模式会将远程资源调用隔离在他们自己的线程池中，以便可以控制单个表现不佳的服务，而不会使该程序崩溃。</p>
<p>具体其原理我推荐大家自己去了解一下，本篇文章中对 <strong>舱壁模式</strong> 不做过多解释。当然还有 <strong><code>Hystrix</code> 仪表盘</strong>，它是<strong>用来实时监控 <code>Hystrix</code> 的各项指标信息的</strong>，这里我将这个问题也抛出去，希望有不了解的可以自己去搜索一下。</p>
<h2 id="微服务网关——Zuul"><a href="#微服务网关——Zuul" class="headerlink" title="微服务网关——Zuul"></a>微服务网关——Zuul</h2><blockquote>
<p>ZUUL 是从设备和 web 站点到 Netflix 流应用后端的所有请求的前门。作为边界服务应用，ZUUL 是为了实现动态路由、监视、弹性和安全性而构建的。它还具有根据情况将请求路由到多个 Amazon Auto Scaling Groups（亚马逊自动缩放组，亚马逊的一种云计算方式） 的能力</p>
</blockquote>
<p>在上面我们学习了 <code>Eureka</code> 之后我们知道了 <em>服务提供者</em>  是 <em>消费者</em> 通过 <code>Eureka Server</code> 进行访问的，即 <code>Eureka Server</code> 是 <em>服务提供者</em> 的统一入口。那么整个应用中存在那么多 <em>消费者</em> 需要用户进行调用，这个时候用户该怎样访问这些 <em>消费者工程</em> 呢？当然可以像之前那样直接访问这些工程。但这种方式没有统一的消费者工程调用入口，不便于访问与管理，而 Zuul 就是这样的一个对于 <em>消费者</em> 的统一入口。</p>
<blockquote>
<p>如果学过前端的肯定都知道 Router 吧，比如 Flutter 中的路由，Vue，React中的路由，用了 Zuul 你会发现在路由功能方面和前端配置路由基本是一个理。:smile: 我偶尔撸撸 Flutter。</p>
</blockquote>
<p>大家对网关应该很熟吧，简单来讲网关是系统唯一对外的入口，介于客户端与服务器端之间，用于对请求进行<strong>鉴权</strong>、<strong>限流</strong>、 <strong>路由</strong>、<strong>监控</strong>等功能。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zuul-sj22o93nfdsjkdsf.jpg" style="zoom:50%;" />

<p>没错，网关有的功能，<code>Zuul</code> 基本都有。而 <code>Zuul</code> 中最关键的就是 <strong>路由和过滤器</strong> 了，在官方文档中 <code>Zuul</code> 的标题就是</p>
<blockquote>
<p>Router and Filter : Zuul</p>
</blockquote>
<h3 id="Zuul-的路由功能"><a href="#Zuul-的路由功能" class="headerlink" title="Zuul 的路由功能"></a>Zuul 的路由功能</h3><h4 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h4><p>本来想给你们复制一些代码，但是想了想，因为各个代码配置比较零散，看起来也比较零散，我决定还是给你们画个图来解释吧。</p>
<blockquote>
<p>请不要因为我这么好就给我点赞 :thumbsup: 。 疯狂暗示。</p>
</blockquote>
<p>比如这个时候我们已经向 <code>Eureka Server</code> 注册了两个 <code>Consumer</code> 、三个 <code>Provicer</code> ，这个时候我们再加个 <code>Zuul</code> 网关应该变成这样子了。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zuul-sj22o93nfdsjkdsf2312.jpg" style="zoom:50%;" />

<p>emmm，信息量有点大，我来解释一下。关于前面的知识我就不解释了:neutral_face:。</p>
<p>首先，<code>Zuul</code> 需要向 <code>Eureka</code> 进行注册，注册有啥好处呢？</p>
<p>你傻呀，<code>Consumer</code> 都向 <code>Eureka Server</code> 进行注册了，我网关是不是只要注册就能拿到所有 <code>Consumer</code> 的信息了？</p>
<p>拿到信息有什么好处呢？</p>
<p>我拿到信息我是不是可以获取所有的 <code>Consumer</code> 的元数据(名称，ip，端口)？</p>
<p>拿到这些元数据有什么好处呢？拿到了我们是不是直接可以做<strong>路由映射</strong>？比如原来用户调用 <code>Consumer1</code> 的接口 <code>localhost:8001/studentInfo/update</code> 这个请求，我们是不是可以这样进行调用了呢？<code>localhost:9000/consumer1/studentInfo/update</code> 呢？你这样是不是恍然大悟了？</p>
<blockquote>
<p>这里的url为了让更多人看懂所以没有使用 restful 风格。</p>
</blockquote>
<p>上面的你理解了，那么就能理解关于 <code>Zuul</code> 最基本的配置了，看下面。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># 这里只要注册 Eureka 就行了</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9997/eureka</span></span><br></pre></td></tr></table></figure>

<p>然后在启动类上加入 <code>@EnableZuulProxy</code> 注解就行了。没错，就是那么简单:smiley:。</p>
<h4 id="统一前缀"><a href="#统一前缀" class="headerlink" title="统一前缀"></a>统一前缀</h4><p>这个很简单，就是我们可以在前面加一个统一的前缀，比如我们刚刚调用的是 <code>localhost:9000/consumer1/studentInfo/update</code>，这个时候我们在 <code>yaml</code> 配置文件中添加如下。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">prefix:</span> <span class="string">/zuul</span></span><br></pre></td></tr></table></figure>

<p>这样我们就需要通过 <code>localhost:9000/zuul/consumer1/studentInfo/update</code> 来进行访问了。</p>
<h4 id="路由策略配置"><a href="#路由策略配置" class="headerlink" title="路由策略配置"></a>路由策略配置</h4><p>你会发现前面的访问方式(直接使用服务名)，需要将微服务名称暴露给用户，会存在安全性问题。所以，可以自定义路径来替代微服务名称，即自定义路由策略。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">consumer1:</span> <span class="string">/FrancisQ1/**</span></span><br><span class="line">    <span class="attr">consumer2:</span> <span class="string">/FrancisQ2/**</span></span><br></pre></td></tr></table></figure>

<p>这个时候你就可以使用 <code> </code>localhost:9000/zuul/FrancisQ1/studentInfo/update` 进行访问了。</p>
<h4 id="服务名屏蔽"><a href="#服务名屏蔽" class="headerlink" title="服务名屏蔽"></a>服务名屏蔽</h4><p>这个时候你别以为你好了，你可以试试，在你配置完路由策略之后使用微服务名称还是可以访问的，这个时候你需要将服务名屏蔽。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">ignore-services:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="路径屏蔽"><a href="#路径屏蔽" class="headerlink" title="路径屏蔽"></a>路径屏蔽</h4><p><code>Zuul</code> 还可以指定屏蔽掉的路径 URI，即只要用户请求中包含指定的 URI 路径，那么该请求将无法访问到指定的服务。通过该方式可以限制用户的权限。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">ignore-patterns:</span> <span class="string">**/auto/**</span></span><br></pre></td></tr></table></figure>

<p>这样关于 auto 的请求我们就可以过滤掉了。</p>
<blockquote>
<p>** 代表匹配多级任意路径</p>
<p>*代表匹配一级任意路径</p>
</blockquote>
<h4 id="敏感请求头屏蔽"><a href="#敏感请求头屏蔽" class="headerlink" title="敏感请求头屏蔽"></a>敏感请求头屏蔽</h4><p>默认情况下，像 <code>Cookie</code>、<code>Set-Cookie</code> 等敏感请求头信息会被 <code>zuul</code> 屏蔽掉，我们可以将这些默认屏蔽去掉，当然，也可以添加要屏蔽的请求头。</p>
<h3 id="Zuul-的过滤功能"><a href="#Zuul-的过滤功能" class="headerlink" title="Zuul 的过滤功能"></a>Zuul 的过滤功能</h3><p>如果说，路由功能是 <code>Zuul</code> 的基操的话，那么<strong>过滤器</strong>就是 <code>Zuul</code>的利器了。毕竟所有请求都经过网关(Zuul)，那么我们可以进行各种过滤，这样我们就能实现 <strong>限流</strong>，<strong>灰度发布</strong>，<strong>权限控制</strong> 等等。</p>
<h4 id="简单实现一个请求时间日志打印"><a href="#简单实现一个请求时间日志打印" class="headerlink" title="简单实现一个请求时间日志打印"></a>简单实现一个请求时间日志打印</h4><p>要实现自己定义的 <code>Filter</code> 我们只需要继承 <code>ZuulFilter</code> 然后将这个过滤器类以 <code>@Component</code> 注解加入 Spring 容器中就行了。</p>
<p>在给你们看代码之前我先给你们解释一下关于过滤器的一些注意点。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zuul-sj22o93nfdsjkdsf2312244.jpg" style="zoom:50%;" />

<p>过滤器类型：<code>Pre</code>、<code>Routing</code>、<code>Post</code>。前置<code>Pre</code>就是在请求之前进行过滤，<code>Routing</code>路由过滤器就是我们上面所讲的路由策略，而<code>Post</code>后置过滤器就是在 <code>Response</code> 之前进行过滤的过滤器。你可以观察上图结合着理解，并且下面我会给出相应的注释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入Spring容器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreRequestFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回过滤器类型 这里是前置过滤器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指定过滤顺序 越小越先执行，这里第一个执行</span></span><br><span class="line">    <span class="comment">// 当然不是只真正第一个 在Zuul内置中有其他过滤器会先执行</span></span><br><span class="line">    <span class="comment">// 那是写死的 比如 SERVLET_DETECTION_FILTER_ORDER = -3</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 什么时候该进行过滤</span></span><br><span class="line">    <span class="comment">// 这里我们可以进行一些判断，这样我们就可以过滤掉一些不符合规定的请求等等</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果过滤器允许通过则怎么进行处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        <span class="comment">// 这里我设置了全局的RequestContext并记录了请求开始时间</span></span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        ctx.set(<span class="string">&quot;startTime&quot;</span>, System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lombok的日志</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">// 加入 Spring 容器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessLogFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指定该过滤器的过滤类型</span></span><br><span class="line">    <span class="comment">// 此时是后置过滤器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.POST_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// SEND_RESPONSE_FILTER_ORDER 是最后一个过滤器</span></span><br><span class="line">    <span class="comment">// 我们此过滤器在它之前执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.SEND_RESPONSE_FILTER_ORDER - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 过滤时执行的策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = context.getRequest();</span><br><span class="line">        <span class="comment">// 从RequestContext获取原先的开始时间 并通过它计算整个时间间隔</span></span><br><span class="line">        Long startTime = (Long) context.get(<span class="string">&quot;startTime&quot;</span>);</span><br><span class="line">        <span class="comment">// 这里我可以获取HttpServletRequest来获取URI并且打印出来</span></span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        <span class="keyword">long</span> duration = System.currentTimeMillis() - startTime;</span><br><span class="line">        log.info(<span class="string">&quot;uri: &quot;</span> + uri + <span class="string">&quot;, duration: &quot;</span> + duration / <span class="number">100</span> + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就简单实现了请求时间日志打印功能，你有没有感受到 <code>Zuul</code> 过滤功能的强大了呢？</p>
<p>没有？好的、那我们再来。</p>
<h4 id="令牌桶限流"><a href="#令牌桶限流" class="headerlink" title="令牌桶限流"></a>令牌桶限流</h4><p>当然不仅仅是令牌桶限流方式，<code>Zuul</code> 只要是限流的活它都能干，这里我只是简单举个:chestnut:。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/zuui-令牌桶限流.jpg" alt="令牌桶限流" style="zoom:50%;" />

<p>我先来解释一下什么是 <strong>令牌桶限流</strong> 吧。</p>
<p>首先我们会有个桶，如果里面没有满那么就会以一定 <strong>固定的速率</strong> 会往里面放令牌，一个请求过来首先要从桶中获取令牌，如果没有获取到，那么这个请求就拒绝，如果获取到那么就放行。很简单吧，啊哈哈、</p>
<p>下面我们就通过 <code>Zuul</code> 的前置过滤器来实现一下令牌桶限流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lgq.zuul.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"><span class="keyword">import</span> com.netflix.zuul.ZuulFilter;</span><br><span class="line"><span class="keyword">import</span> com.netflix.zuul.context.RequestContext;</span><br><span class="line"><span class="keyword">import</span> com.netflix.zuul.exception.ZuulException;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个令牌桶，每秒产生2个令牌，即每秒最多处理2个请求</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RateLimiter RATE_LIMITER = RateLimiter.create(<span class="number">2</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;放行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext context = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="keyword">if</span>(!RATE_LIMITER.tryAcquire()) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;访问量超载&quot;</span>);</span><br><span class="line">            <span class="comment">// 指定当前请求未通过过滤</span></span><br><span class="line">            context.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 向客户端返回响应码429，请求数量过多</span></span><br><span class="line">            context.setResponseStatusCode(<span class="number">429</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就能将请求数量控制在一秒两个，有没有觉得很酷？</p>
<h3 id="关于-Zuul-的其他"><a href="#关于-Zuul-的其他" class="headerlink" title="关于 Zuul  的其他"></a>关于 Zuul  的其他</h3><p><code>Zuul</code> 的过滤器的功能肯定不止上面我所实现的两种，它还可以实现 <strong>权限校验</strong>，包括我上面提到的 <strong>灰度发布</strong> 等等。</p>
<p>当然，<code>Zuul</code> 作为网关肯定也存在 <strong>单点问题</strong> ，如果我们要保证 <code>Zuul</code> 的高可用，我们就需要进行 <code>Zuul</code> 的集群配置，这个时候可以借助额外的一些负载均衡器比如 <code>Nginx</code> 。</p>
<p>##Spring Cloud配置管理——Config</p>
<h3 id="为什么要使用进行配置管理？"><a href="#为什么要使用进行配置管理？" class="headerlink" title="为什么要使用进行配置管理？"></a>为什么要使用进行配置管理？</h3><p>当我们的微服务系统开始慢慢地庞大起来，那么多 <code>Consumer</code> 、<code>Provider</code> 、<code>Eureka Server</code> 、<code>Zuul</code> 系统都会持有自己的配置，这个时候我们在项目运行的时候可能需要更改某些应用的配置，如果我们不进行配置的统一管理，我们只能<strong>去每个应用下一个一个寻找配置文件然后修改配置文件再重启应用</strong>。</p>
<p>首先对于分布式系统而言我们就不应该去每个应用下去分别修改配置文件，再者对于重启应用来说，服务无法访问所以直接抛弃了可用性，这是我们更不愿见到的。</p>
<p>那么有没有一种方法<strong>既能对配置文件统一地进行管理，又能在项目运行时动态修改配置文件呢？</strong></p>
<p>那就是我今天所要介绍的 <code>Spring Cloud Config</code> 。</p>
<blockquote>
<p>能进行配置管理的框架不止 <code>Spring Cloud Config</code> 一种，大家可以根据需求自己选择（<code>disconf</code>，阿波罗等等）。而且对于 <code>Config</code> 来说有些地方实现的不是那么尽人意。</p>
</blockquote>
<h3 id="Config-是什么"><a href="#Config-是什么" class="headerlink" title="Config 是什么"></a>Config 是什么</h3><blockquote>
<p><code>Spring Cloud Config</code> 为分布式系统中的外部化配置提供服务器和客户端支持。使用 <code>Config</code> 服务器，可以在中心位置管理所有环境中应用程序的外部属性。</p>
</blockquote>
<p>简单来说，<code>Spring Cloud Config</code> 就是能将各个 应用/系统/模块 的配置文件存放到 <strong>统一的地方然后进行管理</strong>(Git 或者 SVN)。</p>
<p>你想一下，我们的应用是不是只有启动的时候才会进行配置文件的加载，那么我们的 <code>Spring Cloud Config</code> 就暴露出一个接口给启动应用来获取它所想要的配置文件，应用获取到配置文件然后再进行它的初始化工作。就如下图。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/config-ksksks.jpg" style="zoom:50%;" />

<p>当然这里你肯定还会有一个疑问，如果我在应用运行时去更改远程配置仓库(Git)中的对应配置文件，那么依赖于这个配置文件的已启动的应用会不会进行其相应配置的更改呢？</p>
<p>答案是不会的。</p>
<p>什么？那怎么进行动态修改配置文件呢？这不是出现了 <strong>配置漂移</strong> 吗？你个渣男:rage:，你又骗我！</p>
<p>别急嘛，你可以使用 <code>Webhooks</code> ，这是  <code>github</code> 提供的功能，它能确保远程库的配置文件更新后客户端中的配置信息也得到更新。</p>
<p>噢噢，这还差不多。我去查查怎么用。</p>
<p>慢着，听我说完，<code>Webhooks</code> 虽然能解决，但是你了解一下会发现它根本不适合用于生产环境，所以基本不会使用它的。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/1ada747175704ecba3507074847002d0-new-imagee5249fee-c5ee-4472-9983-f1bd5801387c.png"></p>
<p>而一般我们会使用 <code>Bus</code> 消息总线 + <code>Spring Cloud Config</code> 进行配置的动态刷新。</p>
<h2 id="引出-Spring-Cloud-Bus"><a href="#引出-Spring-Cloud-Bus" class="headerlink" title="引出 Spring Cloud Bus"></a>引出 Spring Cloud Bus</h2><blockquote>
<p>用于将服务和服务实例与分布式消息系统链接在一起的事件总线。在集群中传播状态更改很有用（例如配置更改事件）。</p>
</blockquote>
<p>你可以简单理解为 <code>Spring Cloud Bus</code> 的作用就是<strong>管理和广播分布式系统中的消息</strong>，也就是消息引擎系统中的广播模式。当然作为 <strong>消息总线</strong> 的 <code>Spring Cloud Bus</code> 可以做很多事而不仅仅是客户端的配置刷新功能。</p>
<p>而拥有了 <code>Spring Cloud Bus</code> 之后，我们只需要创建一个简单的请求，并且加上 <code>@ResfreshScope</code> 注解就能进行配置的动态修改了，下面我画了张图供你理解。</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/springcloud-bus-s213dsfsd.jpg" style="zoom:50%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章中我带大家初步了解了 <code>Spring Cloud</code> 的各个组件，他们有</p>
<ul>
<li><code>Eureka</code> 服务发现框架</li>
<li><code>Ribbon</code> 进程内负载均衡器</li>
<li><code>Open Feign</code> 服务调用映射</li>
<li><code>Hystrix</code> 服务降级熔断器</li>
<li><code>Zuul</code> 微服务网关</li>
<li><code>Config</code> 微服务统一配置中心</li>
<li><code>Bus</code> 消息总线</li>
</ul>
<p>如果你能这个时候能看懂文首那张图，也就说明了你已经对 <code>Spring Cloud</code> 微服务有了一定的架构认识。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/micro-service/spring-cloud/" data-id="cks75dy6f000s7kveel9h95wp" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/high-availability/如何设计一个高可用系统要考虑哪些地方" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/high-availability/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.122Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>一篇短小的文章，面试经常遇到的这个问题。本文主要包括下面这些内容：</p>
<ol>
<li>高可用的定义</li>
<li>哪些情况可能会导致系统不可用？</li>
<li>有些提高系统可用性的方法？只是简单的提一嘴，更具体内容在后续的文章中介绍，就拿限流来说，你需要搞懂：何为限流？如何限流？为什么要限流？如何做呢？说一下原理？。</li>
</ol>
<h2 id="什么是高可用？可用性的判断标准是啥？"><a href="#什么是高可用？可用性的判断标准是啥？" class="headerlink" title="什么是高可用？可用性的判断标准是啥？"></a>什么是高可用？可用性的判断标准是啥？</h2><p><strong>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</strong></p>
<p><strong>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。</strong></p>
<p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</p>
<h2 id="哪些情况会导致系统不可用？"><a href="#哪些情况会导致系统不可用？" class="headerlink" title="哪些情况会导致系统不可用？"></a>哪些情况会导致系统不可用？</h2><ol>
<li>黑客攻击；</li>
<li>硬件故障，比如服务器坏掉。</li>
<li>并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。</li>
<li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。</li>
<li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。</li>
<li>自然灾害或者人为破坏。</li>
<li>……</li>
</ol>
<h2 id="有哪些提高系统可用性的方法？"><a href="#有哪些提高系统可用性的方法？" class="headerlink" title="有哪些提高系统可用性的方法？"></a>有哪些提高系统可用性的方法？</h2><h3 id="1-注重代码质量，测试严格把关"><a href="#1-注重代码质量，测试严格把关" class="headerlink" title="1. 注重代码质量，测试严格把关"></a>1. 注重代码质量，测试严格把关</h3><p>我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！</p>
<p>另外，安利这个对提高代码质量有实际效果的宝贝：</p>
<ol>
<li>sonarqube ：保证你写出更安全更干净的代码！（ps: 目前所在的项目基本都会用到这个插件）。</li>
<li>Alibaba 开源的 Java 诊断工具 Arthas 也是很不错的选择。</li>
<li>IDEA 自带的代码分析等工具进行代码扫描也是非常非常棒的。</li>
</ol>
<h3 id="2-使用集群，减少单点故障"><a href="#2-使用集群，减少单点故障" class="headerlink" title="2.使用集群，减少单点故障"></a>2.使用集群，减少单点故障</h3><p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例，不到一秒就会有另外一台 Redis 实例顶上。</p>
<h3 id="3-限流"><a href="#3-限流" class="headerlink" title="3.限流"></a>3.限流</h3><p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。——来自 alibaba-<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel" title="Sentinel">Sentinel</a> 的 wiki。</p>
<h3 id="4-超时和重试机制设置"><a href="#4-超时和重试机制设置" class="headerlink" title="4.超时和重试机制设置"></a>4.超时和重试机制设置</h3><p>一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法在处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p>
<h3 id="5-熔断机制"><a href="#5-熔断机制" class="headerlink" title="5.熔断机制"></a>5.熔断机制</h3><p>超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的是流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。</p>
<h3 id="6-异步调用"><a href="#6-异步调用" class="headerlink" title="6.异步调用"></a>6.异步调用</h3><p>异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 <strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。</p>
<h3 id="7-使用缓存"><a href="#7-使用缓存" class="headerlink" title="7.使用缓存"></a>7.使用缓存</h3><p>如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！</p>
<h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h3><ol>
<li><strong>核心应用和服务优先使用更好的硬件</strong></li>
<li><strong>监控系统资源使用情况增加报警设置。</strong></li>
<li><strong>注意备份，必要时候回滚。</strong></li>
<li><strong>灰度发布：</strong> 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可</li>
<li><strong>定期检查/更换硬件：</strong> 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。</li>
<li>…..(想起来再补充！也欢迎各位欢迎补充！)</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%EF%BC%9F.png" alt="如何设计高可用系统？"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/high-availability/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9/" data-id="cks75dy5y000b7kve15s56dpk" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/high-availability/limit-request" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/high-availability/limit-request/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.119Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="限流的算法有哪些？"><a href="#限流的算法有哪些？" class="headerlink" title="限流的算法有哪些？"></a>限流的算法有哪些？</h3><p>简单介绍 4 种非常好理解并且容易实现的限流算法！</p>
<p>下图的图片不是 Guide 哥自己画的哦！图片来源于 InfoQ 的一篇文章<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673">《分布式服务限流实战，已经为你排好坑了》</a>。</p>
<h4 id="固定窗口计数器算法"><a href="#固定窗口计数器算法" class="headerlink" title="固定窗口计数器算法"></a>固定窗口计数器算法</h4><p>该算法规定我们单位时间处理的请求数量。比如我们规定我们的一个接口一分钟只能访问10次的话。使用固定窗口计数器算法的话可以这样实现：给定一个变量counter来记录处理的请求数量，当1分钟之内处理一个请求之后counter+1，1分钟之内的如果counter=100的话，后续的请求就会被全部拒绝。等到 1分钟结束后，将counter回归成0，重新开始计数（ps：只要过了一个周期就讲counter回归成0）。</p>
<p>这种限流算法无法保证限流速率，因而无法保证突然激增的流量。比如我们限制一个接口一分钟只能访问10次的话，前半分钟一个请求没有接收，后半分钟接收了10个请求。</p>
<p><img src="https://static001.infoq.cn/resource/image/8d/15/8ded7a2b90e1482093f92fff555b3615.png" alt="固定窗口计数器算法"></p>
<h4 id="滑动窗口计数器算法"><a href="#滑动窗口计数器算法" class="headerlink" title="滑动窗口计数器算法"></a>滑动窗口计数器算法</h4><p>该算法算的上是固定窗口计数器算法的升级版。滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：它把时间以一定比例分片。例如我们的接口限流每分钟处理60个请求，我们可以把 1 分钟分为60个窗口。每隔1秒移动一次，每个窗口一秒只能处理 不大于 60(请求数)/60（窗口数） 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。</p>
<p>很显然：当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</p>
<p><img src="https://static001.infoq.cn/resource/image/ae/15/ae4d3cd14efb8dc7046d691c90264715.png" alt="滑动窗口计数器算法"></p>
<h4 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h4><p>我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了。</p>
<p><img src="https://static001.infoq.cn/resource/image/75/03/75938d1010138ce66e38c6ed0392f103.png" alt="漏桶算法"></p>
<h4 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h4><p>令牌桶算法也比较简单。和漏桶算法算法一样，我们的主角还是桶（这限流算法和桶过不去啊）。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。</p>
<p><img src="https://static001.infoq.cn/resource/image/ec/93/eca0e5eaa35dac938c673fecf2ec9a93.png" alt="令牌桶算法"></p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/high-availability/limit-request/" data-id="cks75dy5w000a7kveauq70lr3" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/framework/spring/Spring常见问题总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.075Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这篇文章主要是想通过一些问题，加深大家对于 Spring 的理解，所以不会涉及太多的代码！这篇文章整理了挺长时间，下面的很多问题我自己在使用 Spring 的过程中也并没有注意，自己也是临时查阅了很多资料和书籍补上的。网上也有一些很多关于 Spring 常见问题/面试题整理的文章，我感觉大部分都是互相 copy，而且很多问题也不是很好，有些回答也存在问题。所以，自己花了一周的业余时间整理了一下，希望对大家有帮助。</p>
<h2 id="1-什么是-Spring-框架"><a href="#1-什么是-Spring-框架" class="headerlink" title="1. 什么是 Spring 框架?"></a>1. 什么是 Spring 框架?</h2><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 官网：<a target="_blank" rel="noopener" href="https://spring.io/">https://spring.io/</a>。</p>
<p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<p>Spring 官网列出的 Spring 的 6 个特征:</p>
<ul>
<li><strong>核心技术</strong> ：依赖注入(DI)，AOP，事件(events)，资源，i18n，验证，数据绑定，类型转换，SpEL。</li>
<li><strong>测试</strong> ：模拟对象，TestContext框架，Spring MVC 测试，WebTestClient。</li>
<li><strong>数据访问</strong> ：事务，DAO支持，JDBC，ORM，编组XML。</li>
<li><strong>Web支持</strong> : Spring MVC和Spring WebFlux Web框架。</li>
<li><strong>集成</strong> ：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</li>
<li><strong>语言</strong> ：Kotlin，Groovy，动态语言。</li>
</ul>
<h2 id="2-列举一些重要的Spring模块？"><a href="#2-列举一些重要的Spring模块？" class="headerlink" title="2. 列举一些重要的Spring模块？"></a>2. 列举一些重要的Spring模块？</h2><p>下图对应的是 Spring4.x 版本。目前最新的5.x版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Spring%E4%B8%BB%E8%A6%81%E6%A8%A1%E5%9D%97.png" alt="Spring主要模块"></p>
<ul>
<li><strong>Spring Core：</strong> 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</li>
<li><strong>Spring  Aspects</strong> ： 该模块为与AspectJ的集成提供支持。</li>
<li><strong>Spring AOP</strong> ：提供了面向切面的编程实现。</li>
<li><strong>Spring JDBC</strong> : Java数据库连接。</li>
<li><strong>Spring JMS</strong> ：Java消息服务。</li>
<li><strong>Spring ORM</strong> : 用于支持Hibernate等ORM工具。</li>
<li><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</li>
<li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li>
</ul>
<h2 id="3-RestController-vs-Controller"><a href="#3-RestController-vs-Controller" class="headerlink" title="3. @RestController vs @Controller"></a>3. @RestController vs @Controller</h2><p><strong><code>Controller</code> 返回一个页面</strong></p>
<p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般使用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC 的应用，对应于前后端不分离的情况。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringMVC%E4%BC%A0%E7%BB%9F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="SpringMVC 传统工作流程"></p>
<p><strong><code>@RestController</code> 返回JSON 或 XML 形式数据</strong></p>
<p>但<code>@RestController</code>只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringMVCRestController.png" alt="SpringMVC+RestController"></p>
<p><strong><code>@Controller +@ResponseBody</code> 返回JSON 或 XML 形式数据</strong></p>
<p>如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使用<code>@Controller</code> 并结合<code>@ResponseBody</code>注解，也就是说<code>@Controller</code> +<code>@ResponseBody</code>= <code>@RestController</code>（Spring 4 之后新加的注解）。</p>
<blockquote>
<p><code>@ResponseBody</code> 注解的作用是将 <code>Controller</code> 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/Spring3.xMVCRESTfulWeb%E6%9C%8D%E5%8A%A1%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Spring3.xMVC RESTfulWeb服务工作流程"></p>
<p>Reference:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/spring-framework-restcontroller-vs-controller">https://dzone.com/articles/spring-framework-restcontroller-vs-controller</a> （图片来源）</li>
<li><a target="_blank" rel="noopener" href="https://javarevisited.blogspot.com/2017/08/difference-between-restcontroller-and-controller-annotations-spring-mvc-rest.html?m=1">https://javarevisited.blogspot.com/2017/08/difference-between-restcontroller-and-controller-annotations-spring-mvc-rest.html?m=1</a></li>
</ul>
<h2 id="4-Spring-IOC-amp-AOP"><a href="#4-Spring-IOC-amp-AOP" class="headerlink" title="4. Spring IOC &amp; AOP"></a>4. Spring IOC &amp; AOP</h2><h3 id="4-1-谈谈自己对于-Spring-IoC-和-AOP-的理解"><a href="#4-1-谈谈自己对于-Spring-IoC-和-AOP-的理解" class="headerlink" title="4.1 谈谈自己对于 Spring IoC 和 AOP 的理解"></a>4.1 谈谈自己对于 Spring IoC 和 AOP 的理解</h3><h4 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h4><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong>  IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。  <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<p>推荐阅读：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a></p>
<p><strong>Spring IoC的初始化过程：</strong> </p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/SpringIOC%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="Spring IoC的初始化过程"></p>
<p>IoC源码阅读</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></li>
</ul>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong>生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p>
<p>当然你也可以使用 AspectJ，Spring AOP 已经集成了AspectJ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h3 id="4-2-Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#4-2-Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="4.2 Spring AOP 和 AspectJ AOP 有什么区别？"></a>4.2 Spring AOP 和 AspectJ AOP 有什么区别？</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p> Spring AOP 已经集成了 AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ  相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h2 id="5-Spring-bean"><a href="#5-Spring-bean" class="headerlink" title="5. Spring bean"></a>5. Spring bean</h2><h3 id="5-1-Spring-中的-bean-的作用域有哪些"><a href="#5-1-Spring-中的-bean-的作用域有哪些" class="headerlink" title="5.1 Spring 中的 bean 的作用域有哪些?"></a>5.1 Spring 中的 bean 的作用域有哪些?</h3><ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<h3 id="5-2-Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#5-2-Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="5.2 Spring 中的单例 bean 的线程安全问题了解吗？"></a>5.2 Spring 中的单例 bean 的线程安全问题了解吗？</h3><p>的确是存在安全问题的。因为，当多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题。</p>
<p>但是，一般情况下，我们常用的 <code>Controller</code>、<code>Service</code>、<code>Dao</code> 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。</p>
<p>常见的有 2 种解决办法：</p>
<ol>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在  <code>ThreadLocal</code>  中（推荐的一种方式）。</li>
<li>改变 Bean 的作用域为 “prototype”：每次请求都会创建一个新的 bean 实例，自然不会存在线程安全问题。</li>
</ol>
<h3 id="5-3-Component-和-Bean-的区别是什么？"><a href="#5-3-Component-和-Bean-的区别是什么？" class="headerlink" title="5.3 @Component 和 @Bean 的区别是什么？"></a>5.3 @Component 和 @Bean 的区别是什么？</h3><ol>
<li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OneService <span class="title">getService</span><span class="params">(status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl1();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl2();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-将一个类声明为Spring的-bean-的注解有哪些"><a href="#5-4-将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="5.4 将一个类声明为Spring的 bean 的注解有哪些?"></a>5.4 将一个类声明为Spring的 bean 的注解有哪些?</h3><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h3 id="5-5-Spring-中的-bean-生命周期"><a href="#5-5-Spring-中的-bean-生命周期" class="headerlink" title="5.5 Spring 中的 bean 生命周期?"></a>5.5 Spring 中的 bean 生命周期?</h3><p>这部分网上有很多文章都讲到了，下面的内容整理自： <del><a target="_blank" rel="noopener" href="https://yemengying.com/2016/07/14/spring-bean-life-cycle/">https://yemengying.com/2016/07/14/spring-bean-life-cycle/</a></del> (原作者可能不再维护这个博客，连接无法访问，可通过其 Github 仓库访问 <a target="_blank" rel="noopener" href="https://github.com/giraffe0813/giraffe0813.github.io">https://github.com/giraffe0813/giraffe0813.github.io</a>) ，除了这篇文章，再推荐一篇很不错的文章 ：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a> 。</p>
<ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含  init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p>图示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/48376272.jpg" alt="Spring Bean 生命周期"></p>
<p>与之比较类似的中文版本:</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg" alt="Spring Bean 生命周期"></p>
<h2 id="6-Spring-MVC"><a href="#6-Spring-MVC" class="headerlink" title="6. Spring MVC"></a>6. Spring MVC</h2><h3 id="6-1-说说自己对于-Spring-MVC-了解"><a href="#6-1-说说自己对于-Spring-MVC-了解" class="headerlink" title="6.1 说说自己对于 Spring MVC 了解?"></a>6.1 说说自己对于 Spring MVC 了解?</h3><p>谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代。</p>
<ul>
<li><strong>Model1 时代</strong> : 很多学 Java 后端比较晚的朋友可能并没有接触过  Model1 模式下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 既是控制层又是表现层。显而易见，这种模式存在很多问题。比如①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；②前端和后端相互依赖，难以进行测试并且开发效率极低；</li>
<li><strong>Model2 时代</strong> ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View,）+Servlet（Controller）  ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。Model:系统涉及的数据，也就是 dao 和 bean。View：展示模型中的数据，只是用来展示。Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。</li>
</ul>
<p>Model2 模式下还存在很多问题，Model2的抽象和封装程度还远远不够，使用Model2进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。于是很多JavaWeb开发相关的 MVC 框架应运而生比如Struts2，但是 Struts2 比较笨重。随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p>
<p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p>
<p><strong>Spring MVC 的简单原理图如下：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/60679444.jpg"></p>
<h3 id="6-2-SpringMVC-工作原理了解吗"><a href="#6-2-SpringMVC-工作原理了解吗" class="headerlink" title="6.2 SpringMVC 工作原理了解吗?"></a>6.2 SpringMVC 工作原理了解吗?</h3><p><strong>原理如下图所示：</strong><br><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/49790288.jpg" alt="SpringMVC运行原理"></p>
<p>上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 <code>DispatcherServlet</code> 的作用是接收请求，响应结果。</p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler </code>来调用真正的处理器来处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h2 id="7-Spring-框架中用到了哪些设计模式？"><a href="#7-Spring-框架中用到了哪些设计模式？" class="headerlink" title="7. Spring 框架中用到了哪些设计模式？"></a>7. Spring 框架中用到了哪些设计模式？</h2><p>关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN#rd">《面试官:“谈谈Spring中都用到了那些设计模式?”。》</a> 。</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>……</li>
</ul>
<h2 id="8-Spring-事务"><a href="#8-Spring-事务" class="headerlink" title="8. Spring 事务"></a>8. Spring 事务</h2><h3 id="8-1-Spring-管理事务的方式有几种？"><a href="#8-1-Spring-管理事务的方式有几种？" class="headerlink" title="8.1 Spring 管理事务的方式有几种？"></a>8.1 Spring 管理事务的方式有几种？</h3><ol>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用）</li>
</ol>
<p><strong>声明式事务又分为两种：</strong></p>
<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
<h3 id="8-2-Spring-事务中的隔离级别有哪几种"><a href="#8-2-Spring-事务中的隔离级别有哪几种" class="headerlink" title="8.2 Spring 事务中的隔离级别有哪几种?"></a>8.2 Spring 事务中的隔离级别有哪几种?</h3><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>  使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong>   允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong>   最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="8-3-Spring-事务中哪几种事务传播行为"><a href="#8-3-Spring-事务中哪几种事务传播行为" class="headerlink" title="8.3 Spring 事务中哪几种事务传播行为?"></a>8.3 Spring 事务中哪几种事务传播行为?</h3><p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h3 id="8-4-Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#8-4-Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="8.4 @Transactional(rollbackFor = Exception.class)注解了解吗？"></a>8.4 @Transactional(rollbackFor = Exception.class)注解了解吗？</h3><p>我们知道：Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<p>关于 <code>@Transactional </code> 注解推荐阅读的文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html">透彻的掌握 Spring 中@transactional 的使用</a></li>
</ul>
<h2 id="9-JPA"><a href="#9-JPA" class="headerlink" title="9. JPA"></a>9. JPA</h2><h3 id="9-1-如何使用JPA在数据库中非持久化一个字段？"><a href="#9-1-如何使用JPA在数据库中非持久化一个字段？" class="headerlink" title="9.1 如何使用JPA在数据库中非持久化一个字段？"></a>9.1 如何使用JPA在数据库中非持久化一个字段？</h3><p>假如我们有有下面一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Entity(name=<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name=&quot;USER_NAME&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name=&quot;PASSWORD&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String secrect;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> String transient2 = “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// not persistent because of @Transient</span></span><br></pre></td></tr></table></figure>

<p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Spring 技术内幕》</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wmyskxz/p/8820371.html">https://www.cnblogs.com/wmyskxz/p/8820371.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.journaldev.com/2696/spring-interview-questions-and-answers">https://www.journaldev.com/2696/spring-interview-questions-and-answers</a></li>
<li><a target="_blank" rel="noopener" href="https://www.edureka.co/blog/interview-questions/spring-interview-questions/">https://www.edureka.co/blog/interview-questions/spring-interview-questions/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/clwydjgs/p/9317849.html">https://www.cnblogs.com/clwydjgs/p/9317849.html</a></li>
<li><a target="_blank" rel="noopener" href="https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/">https://howtodoinjava.com/interview-questions/top-spring-interview-questions-with-answers/</a></li>
<li><a target="_blank" rel="noopener" href="http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/">http://www.tomaszezula.com/2014/02/09/spring-series-part-5-component-vs-bean/</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired">https://stackoverflow.com/questions/34172888/difference-between-bean-and-autowired</a></li>
<li><a target="_blank" rel="noopener" href="https://www.interviewbit.com/spring-interview-questions/">https://www.interviewbit.com/spring-interview-questions/</a></li>
</ul>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p>
<p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#%E5%85%AC%E4%BC%97%E5%8F%B7">公众号</a>后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p>
<p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/javaguide1.jpg" alt="公众号"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" data-id="cks75dy6e000r7kvedqk932j2" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/framework/spring/Spring事务总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/framework/spring/Spring%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.071Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>大家好，我是 Guide 哥，前段答应读者的 <strong>Spring 事务</strong>分析总结终于来了。这部分内容比较重要，不论是对于工作还是面试，但是网上比较好的参考资料比较少。</p>
<p>如果本文有任何不对或者需要完善的地方，请帮忙指出！Guide 哥感激不尽！</p>
<h2 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1. 什么是事务？"></a>1. 什么是事务？</h2><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p><em>Guide 哥：大家应该都能背上面这句话了，下面我结合我们日常的真实开发来谈一谈。</em></p>
<p>我们系统的每个业务方法可能包括了多个原子性的数据库操作，比如下面的 <code>savePerson()</code> 方法中就有两个原子性的数据库操作。这些原子性的数据库操作是有依赖的，它们要么都执行，要不就都不执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">savePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	personDao.save(person);</span><br><span class="line">	personDetailDao.save(personDetail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，需要格外注意的是：<strong>事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的<code>innodb</code>引擎。但是，如果把数据库引擎变为 <code>myisam</code>，那么程序也就不再支持事务了！</strong></p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：</p>
<ol>
<li><p>将小明的余额减少 1000 元</p>
</li>
<li><p>将小红的余额增加 1000 元。</p>
</li>
</ol>
<p>万一在这两个操作之间突然出现错误比如银行系统崩溃或者网络故障，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrdersService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrdersDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional(propagation = Propagation.REQUIRED,</span></span><br><span class="line"><span class="meta">                isolation = Isolation.DEFAULT, readOnly = false, timeout = -1)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//小红账户多1000</span></span><br><span class="line">		accountDao.addMoney(<span class="number">1000</span>,xiaohong);</span><br><span class="line">		<span class="comment">//模拟突然出现的异常，比如银行中可能为突然停电等等</span></span><br><span class="line">    <span class="comment">//如果没有配置事务管理的话会造成，小红账户多了1000而小明账户没有少钱</span></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//小王账户少1000</span></span><br><span class="line">		accountDao.reduceMoney(<span class="number">1000</span>,xiaoming);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，数据库事务的 ACID 四大特性是事务的基础，下面简单来了解一下。</p>
<h2 id="2-事务的特性（ACID）了解么"><a href="#2-事务的特性（ACID）了解么" class="headerlink" title="2. 事务的特性（ACID）了解么?"></a>2. 事务的特性（ACID）了解么?</h2><p><img src="images/spring-transaction/bda7231b-ab05-4e23-95ee-89ac90ac7fcf.png"></p>
<ul>
<li><strong>原子性（Atomicity）：</strong> 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>一致性（Consistency）：</strong> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li><strong>隔离性（Isolation）：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p>参考 ：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/ACID">https://zh.wikipedia.org/wiki/ACID</a> 。</p>
<h2 id="3-详谈-Spring-对事务的支持"><a href="#3-详谈-Spring-对事务的支持" class="headerlink" title="3. 详谈 Spring 对事务的支持"></a>3. 详谈 Spring 对事务的支持</h2><p><strong>再提醒一次：你的程序是否支持事务首先取决于数据库 ，比如使用 MySQL 的话，如果你选择的是 innodb 引擎，那么恭喜你，是可以支持事务的。但是，如果你的 MySQL 数据库使用的是 myisam 引擎的话，那不好意思，从根上就是不支持事务的。</strong></p>
<p>这里再多提一下一个非常重要的知识点： <strong>MySQL 怎么保证原子性的？</strong></p>
<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<h3 id="3-1-Spring-支持两种方式的事务管理"><a href="#3-1-Spring-支持两种方式的事务管理" class="headerlink" title="3.1. Spring 支持两种方式的事务管理"></a>3.1. Spring 支持两种方式的事务管理</h3><h4 id="1-编程式事务管理"><a href="#1-编程式事务管理" class="headerlink" title="1).编程式事务管理"></a>1).编程式事务管理</h4><p>通过 <code>TransactionTemplate</code>或者<code>TransactionManager</code>手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</p>
<p>使用<code>TransactionTemplate</code> 进行编程式事务管理的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// ....  业务代码</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//回滚</span></span><br><span class="line">                    transactionStatus.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>TransactionManager</code> 进行编程式事务管理的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  TransactionStatus status = transactionManager.getTransaction(<span class="keyword">new</span> DefaultTransactionDefinition());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// ....  业务代码</span></span><br><span class="line">              transactionManager.commit(status);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              transactionManager.rollback(status);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-声明式事务管理"><a href="#2-声明式事务管理" class="headerlink" title="2)声明式事务管理"></a>2)声明式事务管理</h4><p>推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）。</p>
<p>使用 <code>@Transactional</code>注解进行事务管理的示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=propagation.PROPAGATION_REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">  B b = <span class="keyword">new</span> B();</span><br><span class="line">  C c = <span class="keyword">new</span> C();</span><br><span class="line">  b.bMethod();</span><br><span class="line">  c.cMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Spring-事务管理接口介绍"><a href="#3-2-Spring-事务管理接口介绍" class="headerlink" title="3.2. Spring 事务管理接口介绍"></a>3.2. Spring 事务管理接口介绍</h3><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p>
<ul>
<li>**<code>PlatformTransactionManager</code>**： （平台）事务管理器，Spring 事务策略的核心。</li>
<li>**<code>TransactionDefinition</code>**： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li>
<li>**<code>TransactionStatus</code>**： 事务运行状态。</li>
</ul>
<p>我们可以把 <strong><code>PlatformTransactionManager</code></strong> 接口可以被看作是事务上层的管理者，而 <strong><code>TransactionDefinition</code></strong> 和 <strong><code>TransactionStatus</code></strong> 这两个接口可以看作是事务的描述。</p>
<p><strong><code>PlatformTransactionManager</code></strong> 会根据 <strong><code>TransactionDefinition</code></strong> 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 <strong><code>TransactionStatus</code></strong> 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p>
<h4 id="3-2-1-PlatformTransactionManager-事务管理接口"><a href="#3-2-1-PlatformTransactionManager-事务管理接口" class="headerlink" title="3.2.1. PlatformTransactionManager:事务管理接口"></a>3.2.1. PlatformTransactionManager:事务管理接口</h4><p><strong>Spring 并不直接管理事务，而是提供了多种事务管理器</strong> 。Spring 事务管理器的接口是： <strong><code>PlatformTransactionManager</code></strong> 。</p>
<p>通过这个接口，Spring 为各个平台如 JDBC(<code>DataSourceTransactionManager</code>)、Hibernate(<code>HibernateTransactionManager</code>)、JPA(<code>JpaTransactionManager</code>)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
<p><strong><code>PlatformTransactionManager</code> 接口的具体实现如下:</strong></p>
<p><img src="images/spring-transaction/ae964c2c-7289-441c-bddd-511161f51ee1.png"></p>
<p><code>PlatformTransactionManager</code>接口中定义了三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>这里多插一嘴。为什么要定义或者说抽象出来<code>PlatformTransactionManager</code>这个接口呢？</strong></p>
<p>主要是因为要将事务管理行为抽象出来，然后不同的平台去实现它，这样我们可以保证提供给外部的行为不变，方便我们扩展。我前段时间分享过：<strong>“为什么我们要用接口？”</strong></p>
<p><img src="images/spring-transaction/%E6%8E%A5%E5%8F%A3%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%9B%A0.png"></p>
<h4 id="3-2-2-TransactionDefinition-事务属性"><a href="#3-2-2-TransactionDefinition-事务属性" class="headerlink" title="3.2.2. TransactionDefinition:事务属性"></a>3.2.2. TransactionDefinition:事务属性</h4><p>事务管理器接口 <strong><code>PlatformTransactionManager</code></strong> 通过 <strong><code>getTransaction(TransactionDefinition definition)</code></strong> 方法来得到一个事务，这个方法里面的参数是 <strong><code>TransactionDefinition</code></strong> 类 ，这个类就定义了一些基本的事务属性。</p>
<p>那么什么是 <strong>事务属性</strong> 呢？</p>
<p>事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。</p>
<p>事务属性包含了 5 个方面：</p>
<p><img src="images/spring-transaction/a616b84d-9eea-4ad1-b4fc-461ff05e951d.png"></p>
<p><code>TransactionDefinition</code> 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> TIMEOUT_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回事务的隔离级别，默认值是 DEFAULT</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-TransactionStatus-事务状态"><a href="#3-2-3-TransactionStatus-事务状态" class="headerlink" title="3.2.3. TransactionStatus:事务状态"></a>3.2.3. TransactionStatus:事务状态</h4><p><code>TransactionStatus</code>接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。</p>
<p><code>PlatformTransactionManager.getTransaction(…)</code>方法返回一个 <code>TransactionStatus</code> 对象。</p>
<p><strong>TransactionStatus 接口接口内容如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-事务属性详解"><a href="#3-3-事务属性详解" class="headerlink" title="3.3. 事务属性详解"></a>3.3. 事务属性详解</h3><p><em>实际业务开发中，大家一般都是使用 <code>@Transactional</code> 注解来开启事务，很多人并不清楚这个参数里面的参数是什么意思，有什么用。为了更好的在项目中使用事务管理，强烈推荐好好阅读一下下面的内容。</em></p>
<h4 id="3-3-1-事务传播行为"><a href="#3-3-1-事务传播行为" class="headerlink" title="3.3.1. 事务传播行为"></a>3.3.1. 事务传播行为</h4><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p><strong>举个例子！</strong></p>
<p>我们在 A 类的<code>aMethod（）</code>方法中调用了 B 类的 <code>bMethod()</code> 方法。这个时候就涉及到业务层方法之间互相调用的事务问题。如果我们的 <code>bMethod()</code>如果发生异常需要回滚，如何配置事务传播行为才能让 <code>aMethod()</code>也跟着回滚呢？这个时候就需要事务传播行为的知识了，如果你不知道的话一定要好好看一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.xxx)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>TransactionDefinition</code>定义中包括了如下几个表示传播行为的常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过如此，为了方便使用，Spring 会相应地定义了一个枚举类：<code>Propagation</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Propagation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),</span><br><span class="line"></span><br><span class="line">	SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),</span><br><span class="line"></span><br><span class="line">	MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),</span><br><span class="line"></span><br><span class="line">	REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),</span><br><span class="line"></span><br><span class="line">	NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),</span><br><span class="line"></span><br><span class="line">	NEVER(TransactionDefinition.PROPAGATION_NEVER),</span><br><span class="line"></span><br><span class="line">	NESTED(TransactionDefinition.PROPAGATION_NESTED);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">	Propagation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>正确的事务传播行为可能的值如下</strong> ：</p>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。也就是说：</p>
<ol>
<li>如果外部方法没有开启事务的话，<code>Propagation.REQUIRED</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li>
<li>如果外部方法开启事务并且被<code>Propagation.REQUIRED</code>的话，所有<code>Propagation.REQUIRED</code>修饰的内部方法和外部方法均属于同一事务 ，只要一个方法回滚，整个事务均回滚。</li>
</ol>
<p>举个例子：如果我们上面的<code>aMethod()</code>和<code>bMethod()</code>使用的都是<code>PROPAGATION_REQUIRED</code>传播行为的话，两者使用的就是同一个事务，只要其中一个方法回滚，整个事务均回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.PROPAGATION_REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.PROPAGATION_REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p>举个例子：如果我们上面的<code>bMethod()</code>使用<code>PROPAGATION_REQUIRES_NEW</code>事务传播行为修饰，<code>aMethod</code>还是用<code>PROPAGATION_REQUIRED</code>修饰的话。如果<code>aMethod()</code>发生异常回滚，<code>bMethod()</code>不会跟着回滚，因为 <code>bMethod()</code>开启了独立的事务。但是，如果 <code>bMethod()</code>抛出了未被捕获的异常并且这个异常满足事务回滚规则的话,<code>aMethod()</code>同样也会回滚，因为这个异常被 <code>aMethod()</code>的事务管理机制检测到了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.PROPAGATION_REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.bMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong>:</p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。也就是说：</p>
<ol>
<li>在外部方法未开启事务的情况下<code>Propagation.NESTED</code>和<code>Propagation.REQUIRED</code>作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。</li>
<li>如果外部方法开启事务的话，<code>Propagation.NESTED</code>修饰的内部方法属于外部事务的子事务，外部主事务回滚的话，子事务也会回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。</li>
</ol>
<p>这里还是简单举个例子：</p>
<p>如果 <code>aMethod()</code> 回滚的话，<code>bMethod()</code>和<code>bMethod2()</code>都要回滚，而<code>bMethod()</code>回滚的话，并不会造成 <code>aMethod()</code> 和<code>bMethod()2</code>回滚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.PROPAGATION_REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.bMethod();</span><br><span class="line">        b.bMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.PROPAGATION_NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional(propagation=propagation.PROPAGATION_NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> bMethod2 &#123;</span><br><span class="line">       <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<p>这个使用的很少，就不举例子来说了。</p>
<p><strong>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚，这里不对照案例讲解了，使用的很少。</strong></p>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p>更多关于事务传播行为的内容请看这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486668&idx=2&sn=0381e8c836442f46bdc5367170234abb&chksm=cea24307f9d5ca11c96943b3ccfa1fc70dc97dd87d9c540388581f8fe6d805ff548dff5f6b5b&token=1776990505&lang=zh_CN#rd">《太难了~面试官让我结合案例讲讲自己对 Spring 事务传播行为的理解。》</a></p>
<h4 id="3-3-2-事务隔离级别"><a href="#3-3-2-事务隔离级别" class="headerlink" title="3.3.2 事务隔离级别"></a>3.3.2 事务隔离级别</h4><p><code>TransactionDefinition</code> 接口中定义了五个表示隔离级别的常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Isolation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line">	READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line">	READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line">	REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line">	SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">	Isolation(<span class="keyword">int</span> value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我依次对每一种事务隔离级别进行介绍：</p>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<p>因为平时使用 MySQL 数据库比较多，这里再多提一嘴！</p>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br></pre></td></tr></table></figure>

<p><del>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong> 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</del></p>
<p>🐛问题更正：<strong>MySQL InnoDB的REPEATABLE-READ（可重读）并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是 Next-Key Locks。</strong></p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED(读取提交内容)</strong> ，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEAaTABLE-READ（可重读）</strong> 并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到 <strong>SERIALIZABLE(可串行化)</strong> 隔离级别。</p>
<p>🌈拓展一下(以下内容摘自《MySQL技术内幕：InnoDB存储引擎(第2版)》7.7章)：</p>
<blockquote>
<p>InnoDB存储引擎提供了对XA事务的支持，并通过XA事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的ACID要求又有了提高。另外，在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为SERIALIZABLE。</p>
</blockquote>
<h4 id="3-3-3-事务超时属性"><a href="#3-3-3-事务超时属性" class="headerlink" title="3.3.3. 事务超时属性"></a>3.3.3. 事务超时属性</h4><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 <code>TransactionDefinition</code> 中以 int 的值来表示超时时间，其单位是秒，默认值为-1。</p>
<h4 id="3-3-3-事务只读属性"><a href="#3-3-3-事务只读属性" class="headerlink" title="3.3.3. 事务只读属性"></a>3.3.3. 事务只读属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。只读事务不涉及数据的修改，数据库会提供一些优化手段，适合用在有多条数据库查询操作的方法中。</p>
<p>很多人就会疑问了，为什么我一个数据查询操作还要启用事务支持呢？</p>
<p>拿 MySQL 的 innodb 举例子，根据官网 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html</a> 描述：</p>
<blockquote>
<p>MySQL 默认对每一个新建立的连接都启用了<code>autocommit</code>模式。在该模式下，每一个发送到 MySQL 服务器的<code>sql</code>语句都会在一个单独的事务中进行处理，执行结束后会自动提交事务，并开启一个新的事务。</p>
</blockquote>
<p>但是，如果你给方法加上了<code>Transactional</code>注解的话，这个方法执行的所有<code>sql</code>会被放在一个事务中。如果声明了只读事务的话，数据库就会去优化它的执行，并不会带来其他的什么收益。</p>
<p>如果不加<code>Transactional</code>，每条<code>sql</code>会开启一个单独的事务，中间被其它事务改了数据，都会实时读取到最新值。</p>
<p>分享一下关于事务只读属性，其他人的解答：</p>
<ol>
<li>如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；</li>
<li>如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则，在前条 SQL 查询之后，后条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持</li>
</ol>
<h4 id="3-3-4-事务回滚规则"><a href="#3-3-4-事务回滚规则" class="headerlink" title="3.3.4. 事务回滚规则"></a>3.3.4. 事务回滚规则</h4><p>这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常（RuntimeException 的子类）时才会回滚，Error 也会导致事务回滚，但是，在遇到检查型（Checked）异常时不会回滚。</p>
<p><img src="images/spring-transaction/f6c6f0aa-0f26-49e1-84b3-7f838c7379d1.png"></p>
<p>如果你想要回滚你定义的特定的异常类型的话，可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor= MyException.class)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-Transactional-注解使用详解"><a href="#3-4-Transactional-注解使用详解" class="headerlink" title="3.4. @Transactional 注解使用详解"></a>3.4. @Transactional 注解使用详解</h3><h4 id="1-Transactional-的作用范围"><a href="#1-Transactional-的作用范围" class="headerlink" title="1) @Transactional 的作用范围"></a>1) <code>@Transactional</code> 的作用范围</h4><ol>
<li><strong>方法</strong> ：推荐将注解使用于方法上，不过需要注意的是：<strong>该注解只能应用到 public 方法上，否则不生效。</strong></li>
<li><strong>类</strong> ：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li>
<li><strong>接口</strong> ：不推荐在接口上使用。</li>
</ol>
<h4 id="2-Transactional-的常用配置参数"><a href="#2-Transactional-的常用配置参数" class="headerlink" title="2) @Transactional 的常用配置参数"></a>2) <code>@Transactional</code> 的常用配置参数</h4><p><code>@Transactional</code>注解源码如下，里面包含了基本事务属性的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(&quot;transactionManager&quot;)</span></span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">	<span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>@Transactional</code> 的常用配置参数总结（只列巨额 5 个我平时比较常用的）：</strong></p>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">propagation</td>
<td align="left">事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过</td>
</tr>
<tr>
<td align="left">isolation</td>
<td align="left">事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td>
</tr>
<tr>
<td align="left">readOnly</td>
<td align="left">指定事务是否为只读事务，默认值为 false。</td>
</tr>
<tr>
<td align="left">rollbackFor</td>
<td align="left">用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。</td>
</tr>
</tbody></table>
<h4 id="3-Transactional-事务注解原理"><a href="#3-Transactional-事务注解原理" class="headerlink" title="3)@Transactional 事务注解原理"></a>3)<code>@Transactional</code> 事务注解原理</h4><p>面试中在问 AOP 的时候可能会被问到的一个问题。简单说下吧！</p>
<p>我们知道，**<code>@Transactional</code> 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。**</p>
<p>多提一嘴：<code>createAopProxy()</code> 方法 决定了是使用 JDK 还是 Cglib 来做动态代理，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">			Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">			<span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">&quot;TargetSource cannot determine target class: &quot;</span> +</span><br><span class="line">						<span class="string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类或者一个类中的 public 方法上被标注<code>@Transactional</code> 注解的话，Spring 容器就会在启动的时候为其创建一个代理类，在调用被<code>@Transactional</code> 注解的 public 方法的时候，实际调用的是，<code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p>
<blockquote>
<p><code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法内部实际调用的是 <code>TransactionAspectSupport</code> 类的 <code>invokeWithinTransaction()</code>方法。由于新版本的 Spring 对这部分重写很大，而且用到了很多响应式编程的知识，这里就不列源码了。</p>
</blockquote>
<h4 id="4-Spring-AOP-自调用问题"><a href="#4-Spring-AOP-自调用问题" class="headerlink" title="4)Spring AOP 自调用问题"></a>4)Spring AOP 自调用问题</h4><p>若同一类中的其他没有 <code>@Transactional</code> 注解的方法内部调用有 <code>@Transactional</code> 注解的方法，有<code>@Transactional</code> 注解的方法的事务会失效。</p>
<p>这是由于<code>Spring AOP</code>代理的原因造成的，因为只有当 <code>@Transactional</code> 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</p>
<p><code>MyService</code> 类中的<code>method1()</code>调用<code>method2()</code>就会导致<code>method2()</code>的事务失效。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     method2();</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法就是避免同一类中自调用或者使用 AspectJ 取代 Spring AOP 代理。</p>
<h4 id="5-Transactional-的使用注意事项总结"><a href="#5-Transactional-的使用注意事项总结" class="headerlink" title="5) @Transactional 的使用注意事项总结"></a>5) <code>@Transactional</code> 的使用注意事项总结</h4><ol>
<li> <code>@Transactional</code> 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用；</li>
<li> 避免同一个类中调用 <code>@Transactional</code> 注解的方法，这样会导致事务失效；</li>
<li> 正确的设置 <code>@Transactional</code> 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败</li>
<li> ……</li>
</ol>
<h2 id="4-Reference"><a href="#4-Reference" class="headerlink" title="4. Reference"></a>4. Reference</h2><ol start="3">
<li>[总结]Spring 事务管理中@Transactional 的参数:<a target="_blank" rel="noopener" href="http://www.mobabel.net/spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%ADtransactional%E7%9A%84%E5%8F%82%E6%95%B0/">http://www.mobabel.net/spring 事务管理中 transactional 的参数/</a></li>
<li>Spring 官方文档：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html">https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html</a></li>
<li>《Spring5 高级编程》</li>
<li>透彻的掌握 Spring 中@transactional 的使用: <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html">https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html</a></li>
<li>Spring 事务的传播特性：<a target="_blank" rel="noopener" href="https://github.com/love-somnus/Spring/wiki/Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7">https://github.com/love-somnus/Spring/wiki/Spring 事务的传播特性</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013341344">Spring 事务传播行为详解</a> ：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013341344">https://segmentfault.com/a/1190000013341344</a></li>
<li>全面分析 Spring 的编程式事务管理及声明式事务管理：<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html">https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/framework/spring/Spring%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93/" data-id="cks75dy6l000w7kvedfzt507n" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/framework/spring/SpringBoot+Spring常用注解总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/framework/spring/SpringBoot+Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.068Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><!-- TOC -->

<ul>
<li><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">文章目录</a></li>
<li><a href="#0%E5%89%8D%E8%A8%80">0.前言</a></li>
<li><a href="#1-springbootapplication">1. <code>@SpringBootApplication</code></a></li>
<li><a href="#2-spring-bean-%E7%9B%B8%E5%85%B3">2. Spring Bean 相关</a><ul>
<li><a href="#21-autowired">2.1. <code>@Autowired</code></a></li>
<li><a href="#22-componentrepositoryservice-controller">2.2. <code>@Component</code>,<code>@Repository</code>,<code>@Service</code>, <code>@Controller</code></a></li>
<li><a href="#23-restcontroller">2.3. <code>@RestController</code></a></li>
<li><a href="#24-scope">2.4. <code>@Scope</code></a></li>
<li><a href="#25-configuration">2.5. <code>@Configuration</code></a></li>
</ul>
</li>
<li><a href="#3-%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84-http-%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B">3. 处理常见的 HTTP 请求类型</a><ul>
<li><a href="#31-get-%E8%AF%B7%E6%B1%82">3.1. GET 请求</a></li>
<li><a href="#32-post-%E8%AF%B7%E6%B1%82">3.2. POST 请求</a></li>
<li><a href="#33-put-%E8%AF%B7%E6%B1%82">3.3. PUT 请求</a></li>
<li><a href="#34-delete-%E8%AF%B7%E6%B1%82">3.4. <strong>DELETE 请求</strong></a></li>
<li><a href="#35-patch-%E8%AF%B7%E6%B1%82">3.5. <strong>PATCH 请求</strong></a></li>
</ul>
</li>
<li><a href="#4-%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E5%80%BC">4. 前后端传值</a><ul>
<li><a href="#41-pathvariable-%E5%92%8C-requestparam">4.1. <code>@PathVariable</code> 和 <code>@RequestParam</code></a></li>
<li><a href="#42-requestbody">4.2. <code>@RequestBody</code></a></li>
</ul>
</li>
<li><a href="#5-%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF">5. 读取配置信息</a><ul>
<li><a href="#51-value%E5%B8%B8%E7%94%A8">5.1. <code>@value</code>(常用)</a></li>
<li><a href="#52-configurationproperties%E5%B8%B8%E7%94%A8">5.2. <code>@ConfigurationProperties</code>(常用)</a></li>
<li><a href="#53-propertysource%E4%B8%8D%E5%B8%B8%E7%94%A8">5.3. <code>PropertySource</code>（不常用）</a></li>
</ul>
</li>
<li><a href="#6-%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C">6. 参数校验</a><ul>
<li><a href="#61-%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%97%E6%AE%B5%E9%AA%8C%E8%AF%81%E7%9A%84%E6%B3%A8%E8%A7%A3">6.1. 一些常用的字段验证的注解</a></li>
<li><a href="#62-%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E4%BD%93requestbody">6.2. 验证请求体(RequestBody)</a></li>
<li><a href="#63-%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0path-variables-%E5%92%8C-request-parameters">6.3. 验证请求参数(Path Variables 和 Request Parameters)</a></li>
</ul>
</li>
<li><a href="#7-%E5%85%A8%E5%B1%80%E5%A4%84%E7%90%86-controller-%E5%B1%82%E5%BC%82%E5%B8%B8">7. 全局处理 Controller 层异常</a></li>
<li><a href="#8-jpa-%E7%9B%B8%E5%85%B3">8. JPA 相关</a><ul>
<li><a href="#81-%E5%88%9B%E5%BB%BA%E8%A1%A8">8.1. 创建表</a></li>
<li><a href="#82-%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%94%AE">8.2. 创建主键</a></li>
<li><a href="#83-%E8%AE%BE%E7%BD%AE%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B">8.3. 设置字段类型</a></li>
<li><a href="#84-%E6%8C%87%E5%AE%9A%E4%B8%8D%E6%8C%81%E4%B9%85%E5%8C%96%E7%89%B9%E5%AE%9A%E5%AD%97%E6%AE%B5">8.4. 指定不持久化特定字段</a></li>
<li><a href="#85-%E5%A3%B0%E6%98%8E%E5%A4%A7%E5%AD%97%E6%AE%B5">8.5. 声明大字段</a></li>
<li><a href="#86-%E5%88%9B%E5%BB%BA%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E6%AE%B5">8.6. 创建枚举类型的字段</a></li>
<li><a href="#87-%E5%A2%9E%E5%8A%A0%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD">8.7. 增加审计功能</a></li>
<li><a href="#88-%E5%88%A0%E9%99%A4%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE">8.8. 删除/修改数据</a></li>
<li><a href="#89-%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB">8.9. 关联关系</a></li>
</ul>
</li>
<li><a href="#9-%E4%BA%8B%E5%8A%A1-transactional">9. 事务 <code>@Transactional</code></a></li>
<li><a href="#10-json-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">10. json 数据处理</a><ul>
<li><a href="#101-%E8%BF%87%E6%BB%A4-json-%E6%95%B0%E6%8D%AE">10.1. 过滤 json 数据</a></li>
<li><a href="#102-%E6%A0%BC%E5%BC%8F%E5%8C%96-json-%E6%95%B0%E6%8D%AE">10.2. 格式化 json 数据</a></li>
<li><a href="#103-%E6%89%81%E5%B9%B3%E5%8C%96%E5%AF%B9%E8%B1%A1">10.3. 扁平化对象</a></li>
</ul>
</li>
<li><a href="#11-%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3">11. 测试相关</a></li>
</ul>
<!-- /TOC -->
<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h3><p><em>大家好，我是 Guide 哥！这是我的 221 篇优质原创文章。如需转载，请在文首注明地址，蟹蟹！</em></p>
<p>本文已经收录进我的 75K Star 的 Java 开源项目 JavaGuide：<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a>。</p>
<p>可以毫不夸张地说，这篇文章介绍的 Spring/SpringBoot 常用注解基本已经涵盖你工作中遇到的大部分常用的场景。对于每一个注解我都说了具体用法，掌握搞懂，使用 SpringBoot 来开发项目基本没啥大问题了！</p>
<p><strong>为什么要写这篇文章？</strong></p>
<p>最近看到网上有一篇关于 SpringBoot 常用注解的文章被转载的比较多，我看了文章内容之后属实觉得质量有点低，并且有点会误导没有太多实际使用经验的人（这些人又占据了大多数）。所以，自己索性花了大概 两天时间简单总结一下了。</p>
<p><strong>因为我个人的能力和精力有限，如果有任何不对或者需要完善的地方，请帮忙指出！Guide 哥感激不尽！</strong></p>
<h3 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1. @SpringBootApplication"></a>1. <code>@SpringBootApplication</code></h3><p>这里先单独拎出<code>@SpringBootApplication</code> 注解说一下，虽然我们一般不会主动去使用它。</p>
<p><em>Guide 哥：这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSecurityJwtGuideApplication</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringSecurityJwtGuideApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把 <code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure;</span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.boot;</span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 SpringBoot 官网，这三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
<li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描该类所在的包下所有的类。</li>
<li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li>
</ul>
<h3 id="2-Spring-Bean-相关"><a href="#2-Spring-Bean-相关" class="headerlink" title="2. Spring Bean 相关"></a>2. Spring Bean 相关</h3><h4 id="2-1-Autowired"><a href="#2-1-Autowired" class="headerlink" title="2.1. @Autowired"></a>2.1. <code>@Autowired</code></h4><p>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserService userService;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-Component-Repository-Service-Controller"><a href="#2-2-Component-Repository-Service-Controller" class="headerlink" title="2.2. @Component,@Repository,@Service, @Controller"></a>2.2. <code>@Component</code>,<code>@Repository</code>,<code>@Service</code>, <code>@Controller</code></h4><p>我们一般使用 <code>@Autowired</code> 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,可以采用以下注解实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h4 id="2-3-RestController"><a href="#2-3-RestController" class="headerlink" title="2.3. @RestController"></a>2.3. <code>@RestController</code></h4><p><code>@RestController</code>注解是<code>@Controller和</code>@<code>ResponseBody</code>的合集,表示这是个控制器 bean,并且是将函数的返回值直 接填入 HTTP 响应体中,是 REST 风格的控制器。</p>
<p><em>Guide 哥：现在都是前后端分离，说实话我已经很久没有用过<code>@Controller</code>。如果你的项目太老了的话，就当我没说。</em></p>
<p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般使用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。<code>@Controller</code> +<code>@ResponseBody</code> 返回 JSON 或 XML 形式数据</p>
<p>关于<code>@RestController</code> 和 <code>@Controller</code>的对比，请看这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485544&idx=1&sn=3cc95b88979e28fe3bfe539eb421c6d8&chksm=cea247a3f9d5ceb5e324ff4b8697adc3e828ecf71a3468445e70221cce768d1e722085359907&token=1725092312&lang=zh_CN#rd">@RestController vs @Controller</a>。</p>
<h4 id="2-4-Scope"><a href="#2-4-Scope" class="headerlink" title="2.4. @Scope"></a>2.4. <code>@Scope</code></h4><p>声明 Spring Bean 的作用域，使用方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">personSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>四种常见的 Spring Bean 的作用域：</strong></p>
<ul>
<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li>session : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
</ul>
<h4 id="2-5-Configuration"><a href="#2-5-Configuration" class="headerlink" title="2.5. @Configuration"></a>2.5. <code>@Configuration</code></h4><p>一般用来声明配置类，可以使用 <code>@Component</code>注解替代，不过使用<code>@Configuration</code>注解声明配置类更加语义化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-处理常见的-HTTP-请求类型"><a href="#3-处理常见的-HTTP-请求类型" class="headerlink" title="3. 处理常见的 HTTP 请求类型"></a>3. 处理常见的 HTTP 请求类型</h3><p><strong>5 种常见的请求类型:</strong></p>
<ul>
<li><strong>GET</strong> ：请求从服务器获取特定资源。举个例子：<code>GET /users</code>（获取所有学生）</li>
<li><strong>POST</strong> ：在服务器上创建一个新的资源。举个例子：<code>POST /users</code>（创建学生）</li>
<li><strong>PUT</strong> ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /users/12</code>（更新编号为 12 的学生）</li>
<li><strong>DELETE</strong> ：从服务器删除特定的资源。举个例子：<code>DELETE /users/12</code>（删除编号为 12 的学生）</li>
<li><strong>PATCH</strong> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li>
</ul>
<h4 id="3-1-GET-请求"><a href="#3-1-GET-请求" class="headerlink" title="3.1. GET 请求"></a>3.1. GET 请求</h4><p><code>@GetMapping(&quot;users&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.GET)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() &#123;</span><br><span class="line"> <span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-POST-请求"><a href="#3-2-POST-请求" class="headerlink" title="3.2. POST 请求"></a>3.2. POST 请求</h4><p><code>@PostMapping(&quot;users&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.POST)</code></p>
<p>关于<code>@RequestBody</code>注解的使用，在下面的“前后端传值”这块会讲到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">createUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserCreateRequest userCreateRequest)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> userRespository.save(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-PUT-请求"><a href="#3-3-PUT-请求" class="headerlink" title="3.3. PUT 请求"></a>3.3. PUT 请求</h4><p><code>@PutMapping(&quot;/users/&#123;userId&#125;&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;,method=RequestMethod.PUT)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/users/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">updateUser</span><span class="params">(<span class="meta">@PathVariable(value = &quot;userId&quot;)</span> Long userId,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserUpdateRequest userUpdateRequest)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-DELETE-请求"><a href="#3-4-DELETE-请求" class="headerlink" title="3.4. DELETE 请求"></a>3.4. <strong>DELETE 请求</strong></h4><p><code>@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)</code>等价于<code>@RequestMapping(value=&quot;/users/&#123;userId&#125;&quot;,method=RequestMethod.DELETE)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable(value = &quot;userId&quot;)</span> Long userId)</span></span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-PATCH-请求"><a href="#3-5-PATCH-请求" class="headerlink" title="3.5. PATCH 请求"></a>3.5. <strong>PATCH 请求</strong></h4><p>一般实际项目中，我们都是 PUT 不够用了之后才用 PATCH 请求去更新数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PatchMapping(&quot;/profile&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">updateStudent</span><span class="params">(<span class="meta">@RequestBody</span> StudentUpdateRequest studentUpdateRequest)</span> </span>&#123;</span><br><span class="line">      studentRepository.updateDetail(studentUpdateRequest);</span><br><span class="line">      <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-前后端传值"><a href="#4-前后端传值" class="headerlink" title="4. 前后端传值"></a>4. 前后端传值</h3><p><strong>掌握前后端传值的正确姿势，是你开始 CRUD 的第一步！</strong></p>
<h4 id="4-1-PathVariable-和-RequestParam"><a href="#4-1-PathVariable-和-RequestParam" class="headerlink" title="4.1. @PathVariable 和 @RequestParam"></a>4.1. <code>@PathVariable</code> 和 <code>@RequestParam</code></h4><p><code>@PathVariable</code>用于获取路径参数，<code>@RequestParam</code>用于获取查询参数。</p>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/klasses/&#123;klassId&#125;/teachers&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Teacher&gt; <span class="title">getKlassRelatedTeachers</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="meta">@PathVariable(&quot;klassId&quot;)</span> Long klassId,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="meta">@RequestParam(value = &quot;type&quot;, required = false)</span> String type )</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们请求的 url 是：<code>/klasses/&#123;123456&#125;/teachers?type=web</code></p>
<p>那么我们服务获取到的数据就是：<code>klassId=123456,type=web</code>。</p>
<h4 id="4-2-RequestBody"><a href="#4-2-RequestBody" class="headerlink" title="4.2. @RequestBody"></a>4.2. <code>@RequestBody</code></h4><p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application/json</strong> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>将请求的 body 中的 json 字符串转换为 java 对象。</p>
<p>我用一个简单的例子来给演示一下基本使用！</p>
<p>我们有一个注册的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/sign-up&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity <span class="title">signUp</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> UserRegisterRequest userRegisterRequest)</span> </span>&#123;</span><br><span class="line">  userService.save(userRegisterRequest);</span><br><span class="line">  <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UserRegisterRequest</code>对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRegisterRequest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发送 post 请求到这个接口，并且 body 携带 JSON 数据：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;userName&quot;</span>:<span class="string">&quot;coder&quot;</span>,<span class="attr">&quot;fullName&quot;</span>:<span class="string">&quot;shuangkou&quot;</span>,<span class="attr">&quot;password&quot;</span>:<span class="string">&quot;123456&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的后端就可以直接把 json 格式的数据映射到我们的 <code>UserRegisterRequest</code> 类上。</p>
<p><img src="images/spring-annotations/@RequestBody.png"></p>
<p>👉 需要注意的是：**一个请求方法只可以有一个<code>@RequestBody</code>，但是可以有多个<code>@RequestParam</code>和<code>@PathVariable</code>**。 如果你的方法必须要用两个 <code>@RequestBody</code>来接受数据的话，大概率是你的数据库设计或者系统设计出问题了！</p>
<h3 id="5-读取配置信息"><a href="#5-读取配置信息" class="headerlink" title="5. 读取配置信息"></a>5. 读取配置信息</h3><p><strong>很多时候我们需要将一些常用的配置信息比如阿里云 oss、发送短信、微信认证的相关配置信息等等放到配置文件中。</strong></p>
<p><strong>下面我们来看一下 Spring 为我们提供了哪些方式帮助我们从配置文件中读取这些配置信息。</strong></p>
<p>我们的数据源<code>application.yml</code>内容如下：：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">wuhan2020:</span> <span class="number">2020</span><span class="string">年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！</span></span><br><span class="line"></span><br><span class="line"><span class="attr">my-profile:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Guide哥</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">koushuangbwcx@163.com</span></span><br><span class="line"></span><br><span class="line"><span class="attr">library:</span></span><br><span class="line">  <span class="attr">location:</span> <span class="string">湖北武汉加油中国加油</span></span><br><span class="line">  <span class="attr">books:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">天才基本法</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">时间的秩序</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">了不起的我</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？</span> <span class="string">如何走出人生的艰难时刻？</span></span><br></pre></td></tr></table></figure>

<h4 id="5-1-value-常用"><a href="#5-1-value-常用" class="headerlink" title="5.1. @value(常用)"></a>5.1. <code>@value</code>(常用)</h4><p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 读取比较简单的配置信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;wuhan2020&#125;&quot;)</span></span><br><span class="line">String wuhan2020;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-ConfigurationProperties-常用"><a href="#5-2-ConfigurationProperties-常用" class="headerlink" title="5.2. @ConfigurationProperties(常用)"></a>5.2. <code>@ConfigurationProperties</code>(常用)</h4><p>通过<code>@ConfigurationProperties</code>读取配置信息并与 bean 绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;library&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LibraryProperties</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; books;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        String description;</span><br><span class="line">    &#125;</span><br><span class="line">  省略getter/setter</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以像使用普通的 Spring bean 一样，将其注入到类中使用。</p>
<h4 id="5-3-PropertySource（不常用）"><a href="#5-3-PropertySource（不常用）" class="headerlink" title="5.3. PropertySource（不常用）"></a>5.3. <code>PropertySource</code>（不常用）</h4><p><code>@PropertySource</code>读取指定 properties 文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:website.properties&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebSite</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">  省略getter/setter</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多内容请查看我的这篇文章：《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486181&idx=2&sn=10db0ae64ef501f96a5b0dbc4bd78786&chksm=cea2452ef9d5cc384678e456427328600971180a77e40c13936b19369672ca3e342c26e92b50&token=816772476&lang=zh_CN#rd">10 分钟搞定 SpringBoot 如何优雅读取配置文件？</a>》 。</p>
<h3 id="6-参数校验"><a href="#6-参数校验" class="headerlink" title="6. 参数校验"></a>6. 参数校验</h3><p><strong>数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。</strong></p>
<p><strong>JSR(Java Specification Requests）</strong> 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了，非常方便！</p>
<p>校验的时候我们实际用的是 <strong>Hibernate Validator</strong> 框架。Hibernate Validator 是 Hibernate 团队最初的数据校验框架，Hibernate Validator 4.x 是 Bean Validation 1.0（JSR 303）的参考实现，Hibernate Validator 5.x 是 Bean Validation 1.1（JSR 349）的参考实现，目前最新版的 Hibernate Validator 6.x 是 Bean Validation 2.0（JSR 380）的参考实现。</p>
<p>SpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖。如下图所示（通过 idea 插件—Maven Helper 生成）：</p>
<p><strong>注</strong>：更新版本的 spring-boot-starter-web 依赖中不再有 hibernate-validator 包（如2.3.11.RELEASE），需要自己引入 <code>spring-boot-starter-validation</code> 依赖。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2021/03/c7bacd12-1c1a-4e41-aaaf-4cad840fc073.png"></p>
<p>非 SpringBoot 项目需要自行引入相关依赖包，这里不多做讲解，具体可以查看我的这篇文章：《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485783&idx=1&sn=a407f3b75efa17c643407daa7fb2acd6&chksm=cea2469cf9d5cf8afbcd0a8a1c9cc4294d6805b8e01bee6f76bb2884c5bc15478e91459def49&token=292197051&lang=zh_CN#rd">如何在 Spring/Spring Boot 中做参数校验？你需要了解的都在这里！</a>》。</p>
<p>👉 需要注意的是： <strong>所有的注解，推荐使用 JSR 注解，即<code>javax.validation.constraints</code>，而不是<code>org.hibernate.validator.constraints</code></strong></p>
<h4 id="6-1-一些常用的字段验证的注解"><a href="#6-1-一些常用的字段验证的注解" class="headerlink" title="6.1. 一些常用的字段验证的注解"></a>6.1. 一些常用的字段验证的注解</h4><ul>
<li><code>@NotEmpty</code> 被注释的字符串的不能为 null 也不能为空</li>
<li><code>@NotBlank</code> 被注释的字符串非 null，并且必须包含一个非空白字符</li>
<li><code>@Null</code> 被注释的元素必须为 null</li>
<li><code>@NotNull</code> 被注释的元素必须不为 null</li>
<li><code>@AssertTrue</code> 被注释的元素必须为 true</li>
<li><code>@AssertFalse</code> 被注释的元素必须为 false</li>
<li><code>@Pattern(regex=,flag=)</code>被注释的元素必须符合指定的正则表达式</li>
<li><code>@Email</code> 被注释的元素必须是 Email 格式。</li>
<li><code>@Min(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@Max(value)</code>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@DecimalMin(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>
<li><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>
<li><code>@Size(max=, min=)</code>被注释的元素的大小必须在指定的范围内</li>
<li><code>@Digits (integer, fraction)</code>被注释的元素必须是一个数字，其值必须在可接受的范围内</li>
<li><code>@Past</code>被注释的元素必须是一个过去的日期</li>
<li><code>@Future</code> 被注释的元素必须是一个将来的日期</li>
<li>……</li>
</ul>
<h4 id="6-2-验证请求体-RequestBody"><a href="#6-2-验证请求体-RequestBody" class="headerlink" title="6.2. 验证请求体(RequestBody)"></a>6.2. 验证请求体(RequestBody)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;classId 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String classId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Size(max = 33)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;name 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pattern(regexp = &quot;((^Man$|^Woman$|^UGM$))&quot;, message = &quot;sex 值不在可选范围&quot;)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;sex 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email(message = &quot;email 格式不正确&quot;)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;email 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在需要验证的参数上加上了<code>@Valid</code>注解，如果验证失败，它将抛出<code>MethodArgumentNotValidException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Person&gt; <span class="title">getPerson</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Valid</span> Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-验证请求参数-Path-Variables-和-Request-Parameters"><a href="#6-3-验证请求参数-Path-Variables-和-Request-Parameters" class="headerlink" title="6.3. 验证请求参数(Path Variables 和 Request Parameters)"></a>6.3. 验证请求参数(Path Variables 和 Request Parameters)</h4><p><strong>一定一定不要忘记在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/person/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title">getPersonByID</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="meta">@Max(value = 5,message = &quot;超过 id 的范围了&quot;)</span> Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().body(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多关于如何在 Spring 项目中进行参数校验的内容，请看《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485783&idx=1&sn=a407f3b75efa17c643407daa7fb2acd6&chksm=cea2469cf9d5cf8afbcd0a8a1c9cc4294d6805b8e01bee6f76bb2884c5bc15478e91459def49&token=292197051&lang=zh_CN#rd">如何在 Spring/Spring Boot 中做参数校验？你需要了解的都在这里！</a>》这篇文章。</p>
<h3 id="7-全局处理-Controller-层异常"><a href="#7-全局处理-Controller-层异常" class="headerlink" title="7. 全局处理 Controller 层异常"></a>7. 全局处理 Controller 层异常</h3><p>介绍一下我们 Spring 项目必备的全局处理 Controller 层异常。</p>
<p><strong>相关注解：</strong></p>
<ol>
<li><code>@ControllerAdvice</code> :注解定义全局异常处理类</li>
<li><code>@ExceptionHandler</code> :注解声明异常处理方法</li>
</ol>
<p>如何使用呢？拿我们在第 5 节参数校验这块来举例子。如果方法参数不对的话就会抛出<code>MethodArgumentNotValidException</code>，我们来处理这个异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求参数异常处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletRequest request) &#123;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多关于 Spring Boot 异常处理的内容，请看我的这两篇文章：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485568&idx=2&sn=c5ba880fd0c5d82e39531fa42cb036ac&chksm=cea2474bf9d5ce5dcbc6a5f6580198fdce4bc92ef577579183a729cb5d1430e4994720d59b34&token=2133161636&lang=zh_CN#rd">SpringBoot 处理异常的几种常见姿势</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486379&idx=2&sn=48c29ae65b3ed874749f0803f0e4d90e&chksm=cea24460f9d5cd769ed53ad7e17c97a7963a89f5350e370be633db0ae8d783c3a3dbd58c70f8&token=1054498516&lang=zh_CN#rd">使用枚举简单封装一个优雅的 Spring Boot 全局异常处理！</a></li>
</ol>
<h3 id="8-JPA-相关"><a href="#8-JPA-相关" class="headerlink" title="8. JPA 相关"></a>8. JPA 相关</h3><h4 id="8-1-创建表"><a href="#8-1-创建表" class="headerlink" title="8.1. 创建表"></a>8.1. 创建表</h4><p><code>@Entity</code>声明一个类对应一个数据库实体。</p>
<p><code>@Table</code> 设置表名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;role&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    省略getter/setter......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-创建主键"><a href="#8-2-创建主键" class="headerlink" title="8.2. 创建主键"></a>8.2. 创建主键</h4><p><code>@Id</code> ：声明一个字段为主键。</p>
<p>使用<code>@Id</code>声明之后，我们还需要定义主键的生成策略。我们可以使用 <code>@GeneratedValue</code> 指定主键生成策略。</p>
<p><strong>1.通过 <code>@GeneratedValue</code>直接使用 JPA 内置提供的四种主键生成策略来指定主键生成策略。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure>

<p>JPA 使用枚举定义了 4 中常见的主键生成策略，如下：</p>
<p><em>Guide 哥：枚举替代常量的一种用法</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">GenerationType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用一个特定的数据库表格来保存主键</span></span><br><span class="line"><span class="comment">     * 持久化引擎通过关系数据库的一张特定的表格来生成主键,</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *在某些数据库中,不支持主键自增长,比如Oracle、PostgreSQL其提供了一种叫做&quot;序列(sequence)&quot;的机制生成主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SEQUENCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键自增长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IDENTITY,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *把主键生成策略交给持久化引擎(persistence engine),</span></span><br><span class="line"><span class="comment">     *持久化引擎会根据数据库在以上三种主键生成 策略中选择其中一种</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AUTO</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>@GeneratedValue</code>注解默认使用的策略是<code>GenerationType.AUTO</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GeneratedValue &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">GenerationType <span class="title">strategy</span><span class="params">()</span> <span class="keyword">default</span> AUTO</span>;</span><br><span class="line">    <span class="function">String <span class="title">generator</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般使用 MySQL 数据库的话，使用<code>GenerationType.IDENTITY</code>策略比较普遍一点（分布式系统的话需要另外考虑使用分布式 ID）。</p>
<p><strong>2.通过 <code>@GenericGenerator</code>声明一个主键策略，然后 <code>@GeneratedValue</code>使用这个策略</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue(generator = &quot;IdentityIdGenerator&quot;)</span></span><br><span class="line"><span class="meta">@GenericGenerator(name = &quot;IdentityIdGenerator&quot;, strategy = &quot;identity&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure>

<p>jpa 提供的主键生成策略有如下几种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultIdentifierGeneratorFactory</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">MutableIdentifierGeneratorFactory</span>, <span class="title">Serializable</span>, <span class="title">ServiceRegistryAwareService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DefaultIdentifierGeneratorFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		register( <span class="string">&quot;uuid2&quot;</span>, UUIDGenerator.class );</span><br><span class="line">		register( <span class="string">&quot;guid&quot;</span>, GUIDGenerator.class );			<span class="comment">// can be done with UUIDGenerator + strategy</span></span><br><span class="line">		register( <span class="string">&quot;uuid&quot;</span>, UUIDHexGenerator.class );			<span class="comment">// &quot;deprecated&quot; for new use</span></span><br><span class="line">		register( <span class="string">&quot;uuid.hex&quot;</span>, UUIDHexGenerator.class ); 	<span class="comment">// uuid.hex is deprecated</span></span><br><span class="line">		register( <span class="string">&quot;assigned&quot;</span>, Assigned.class );</span><br><span class="line">		register( <span class="string">&quot;identity&quot;</span>, IdentityGenerator.class );</span><br><span class="line">		register( <span class="string">&quot;select&quot;</span>, SelectGenerator.class );</span><br><span class="line">		register( <span class="string">&quot;sequence&quot;</span>, SequenceStyleGenerator.class );</span><br><span class="line">		register( <span class="string">&quot;seqhilo&quot;</span>, SequenceHiLoGenerator.class );</span><br><span class="line">		register( <span class="string">&quot;increment&quot;</span>, IncrementGenerator.class );</span><br><span class="line">		register( <span class="string">&quot;foreign&quot;</span>, ForeignGenerator.class );</span><br><span class="line">		register( <span class="string">&quot;sequence-identity&quot;</span>, SequenceIdentityGenerator.class );</span><br><span class="line">		register( <span class="string">&quot;enhanced-sequence&quot;</span>, SequenceStyleGenerator.class );</span><br><span class="line">		register( <span class="string">&quot;enhanced-table&quot;</span>, TableGenerator.class );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String strategy, Class generatorClass)</span> </span>&#123;</span><br><span class="line">		LOG.debugf( <span class="string">&quot;Registering IdentifierGenerator strategy [%s] -&gt; [%s]&quot;</span>, strategy, generatorClass.getName() );</span><br><span class="line">		<span class="keyword">final</span> Class previous = generatorStrategyToClassNameMap.put( strategy, generatorClass );</span><br><span class="line">		<span class="keyword">if</span> ( previous != <span class="keyword">null</span> ) &#123;</span><br><span class="line">			LOG.debugf( <span class="string">&quot;    - overriding [%s]&quot;</span>, previous.getName() );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-3-设置字段类型"><a href="#8-3-设置字段类型" class="headerlink" title="8.3. 设置字段类型"></a>8.3. 设置字段类型</h4><p><code>@Column</code> 声明字段。</p>
<p><strong>示例：</strong></p>
<p>设置属性 userName 对应的数据库字段名为 user_name，长度为 32，非空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Column(name = &quot;user_name&quot;, nullable = false, length=32)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br></pre></td></tr></table></figure>

<p>设置字段类型并且加默认值，这个还是挺常用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Column(columnDefinition = <span class="string">&quot;tinyint(1) default 1&quot;</span>)</span><br><span class="line"><span class="keyword">private</span> Boolean enabled;</span><br></pre></td></tr></table></figure>

<h4 id="8-4-指定不持久化特定字段"><a href="#8-4-指定不持久化特定字段" class="headerlink" title="8.4. 指定不持久化特定字段"></a>8.4. 指定不持久化特定字段</h4><p><code>@Transient</code> ：声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库 。</p>
<p>如果我们想让<code>secrect</code> 这个字段不被持久化，可以使用 <code>@Transient</code>关键字声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Entity(name=<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">private</span> String secrect; <span class="comment">// not persistent because of @Transient</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了 <code>@Transient</code>关键字声明， 还可以采用下面几种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String secrect; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> String secrect = “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String secrect; <span class="comment">// not persistent because of transient</span></span><br></pre></td></tr></table></figure>

<p>一般使用注解的方式比较多。</p>
<h4 id="8-5-声明大字段"><a href="#8-5-声明大字段" class="headerlink" title="8.5. 声明大字段"></a>8.5. 声明大字段</h4><p><code>@Lob</code>:声明某个字段为大字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lob</span></span><br><span class="line"><span class="keyword">private</span> String content;</span><br></pre></td></tr></table></figure>

<p>更详细的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lob</span></span><br><span class="line"><span class="comment">//指定 Lob 类型数据的获取策略， FetchType.EAGER 表示非延迟 加载，而 FetchType. LAZY 表示延迟加载 ；</span></span><br><span class="line"><span class="meta">@Basic(fetch = FetchType.EAGER)</span></span><br><span class="line"><span class="comment">//columnDefinition 属性指定数据表对应的 Lob 字段类型</span></span><br><span class="line"><span class="meta">@Column(name = &quot;content&quot;, columnDefinition = &quot;LONGTEXT NOT NULL&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String content;</span><br></pre></td></tr></table></figure>

<h4 id="8-6-创建枚举类型的字段"><a href="#8-6-创建枚举类型的字段" class="headerlink" title="8.6. 创建枚举类型的字段"></a>8.6. 创建枚举类型的字段</h4><p>可以使用枚举类型的字段，不过枚举字段要用<code>@Enumerated</code>注解修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line">    MALE(<span class="string">&quot;男性&quot;</span>),</span><br><span class="line">    FEMALE(<span class="string">&quot;女性&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    Gender(String str)&#123;</span><br><span class="line">        value=str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;role&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="meta">@Enumerated(EnumType.STRING)</span></span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">    省略getter/setter......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数据库里面对应存储的是 MAIL/FEMAIL。</p>
<h4 id="8-7-增加审计功能"><a href="#8-7-增加审计功能" class="headerlink" title="8.7. 增加审计功能"></a>8.7. 增加审计功能</h4><p>只要继承了 <code>AbstractAuditBase</code>的类都会默认加上下面四个字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(value = AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAuditBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant updatedAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedBy</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String createdBy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedBy</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String updatedBy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们对应的审计功能对应地配置类可能是下面这样的（Spring Security 项目）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaAuditing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuditSecurityConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">AuditorAware&lt;String&gt; <span class="title">auditorAware</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; Optional.ofNullable(SecurityContextHolder.getContext())</span><br><span class="line">                .map(SecurityContext::getAuthentication)</span><br><span class="line">                .filter(Authentication::isAuthenticated)</span><br><span class="line">                .map(Authentication::getName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单介绍一下上面设计到的一些注解：</p>
<ol>
<li><p><code>@CreatedDate</code>: 表示该字段为创建时间时间字段，在这个实体被 insert 的时候，会设置值</p>
</li>
<li><p><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值</p>
<p><code>@LastModifiedDate</code>、<code>@LastModifiedBy</code>同理。</p>
</li>
</ol>
<p><code>@EnableJpaAuditing</code>：开启 JPA 审计功能。</p>
<h4 id="8-8-删除-修改数据"><a href="#8-8-删除-修改数据" class="headerlink" title="8.8. 删除/修改数据"></a>8.8. 删除/修改数据</h4><p><code>@Modifying</code> 注解提示 JPA 该操作是修改操作,注意还要配合<code>@Transactional</code>注解使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-9-关联关系"><a href="#8-9-关联关系" class="headerlink" title="8.9. 关联关系"></a>8.9. 关联关系</h4><ul>
<li><code>@OneToOne</code> 声明一对一关系</li>
<li><code>@OneToMany</code> 声明一对多关系</li>
<li><code>@ManyToOne</code>声明多对一关系</li>
<li><code>MangToMang</code>声明多对多关系</li>
</ul>
<p>更多关于 Spring Boot JPA 的文章请看我的这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485689&idx=1&sn=061b32c2222869932be5631fb0bb5260&chksm=cea24732f9d5ce24a356fb3675170e7843addbfcc79ee267cfdb45c83fc7e90babf0f20d22e1&token=292197051&lang=zh_CN#rd">一文搞懂如何在 Spring Boot 正确中使用 JPA</a> 。</p>
<h3 id="9-事务-Transactional"><a href="#9-事务-Transactional" class="headerlink" title="9. 事务 @Transactional"></a>9. 事务 <code>@Transactional</code></h3><p>在要开启事务的方法上使用<code>@Transactional</code>注解即可!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道 Exception 分为运行时异常 RuntimeException 和非运行时异常。在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事物只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事物在遇到非运行时异常时也回滚。</p>
<p><code>@Transactional</code> 注解一般用在可以作用在<code>类</code>或者<code>方法</code>上。</p>
<ul>
<li><strong>作用于类</strong>：当把<code>@Transactional 注解放在类上时，表示所有该类的</code>public 方法都配置相同的事务属性信息。</li>
<li><strong>作用于方法</strong>：当类配置了<code>@Transactional</code>，方法也配置了<code>@Transactional</code>，方法的事务会覆盖类的事务配置信息。</li>
</ul>
<p>更多关于关于 Spring 事务的内容请查看：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484943&idx=1&sn=46b9082af4ec223137df7d1c8303ca24&chksm=cea249c4f9d5c0d2b8212a17252cbfb74e5fbe5488b76d829827421c53332326d1ec360f5d63&token=1082669959&lang=zh_CN#rd">可能是最漂亮的 Spring 事务管理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486483&idx=2&sn=77be488e206186803531ea5d7164ec53&chksm=cea243d8f9d5cacecaa5c5daae4cde4c697b9b5b21f96dfc6cce428cfcb62b88b3970c26b9c2&token=816772476&lang=zh_CN#rd">一口气说出 6 种 @Transactional 注解失效场景</a></li>
</ol>
<h3 id="10-json-数据处理"><a href="#10-json-数据处理" class="headerlink" title="10. json 数据处理"></a>10. json 数据处理</h3><h4 id="10-1-过滤-json-数据"><a href="#10-1-过滤-json-数据" class="headerlink" title="10.1. 过滤 json 数据"></a>10.1. 过滤 json 数据</h4><p><strong><code>@JsonIgnoreProperties</code> 作用在类上用于过滤掉特定字段不返回或者不解析。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(&#123;&quot;userRoles&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>@JsonIgnore</code>一般用于类的属性上，作用和上面的<code>@JsonIgnoreProperties</code> 一样。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">   <span class="comment">//生成json时将userRoles属性过滤</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;UserRole&gt; userRoles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-2-格式化-json-数据"><a href="#10-2-格式化-json-数据" class="headerlink" title="10.2. 格式化 json 数据"></a>10.2. 格式化 json 数据</h4><p><code>@JsonFormat</code>一般用来格式化 json 数据。：</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(shape=JsonFormat.Shape.STRING, pattern=&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSS&#x27;Z&#x27;&quot;, timezone=&quot;GMT&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br></pre></td></tr></table></figure>

<h4 id="10-3-扁平化对象"><a href="#10-3-扁平化对象" class="headerlink" title="10.3. 扁平化对象"></a>10.3. 扁平化对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> Location location;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> PersonInfo personInfo;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Getter</span></span><br><span class="line">  <span class="meta">@Setter</span></span><br><span class="line">  <span class="meta">@ToString</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String provinceName;</span><br><span class="line">     <span class="keyword">private</span> String countyName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Getter</span></span><br><span class="line">  <span class="meta">@Setter</span></span><br><span class="line">  <span class="meta">@ToString</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String fullName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>未扁平化之前：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;location&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;provinceName&quot;</span>:<span class="string">&quot;湖北&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;countyName&quot;</span>:<span class="string">&quot;武汉&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;personInfo&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;userName&quot;</span>: <span class="string">&quot;coder1234&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;fullName&quot;</span>: <span class="string">&quot;shaungkou&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@JsonUnwrapped</code> 扁平对象之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> Location location;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> PersonInfo personInfo;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;provinceName&quot;</span>:<span class="string">&quot;湖北&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;countyName&quot;</span>:<span class="string">&quot;武汉&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;userName&quot;</span>: <span class="string">&quot;coder1234&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;fullName&quot;</span>: <span class="string">&quot;shaungkou&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-测试相关"><a href="#11-测试相关" class="headerlink" title="11. 测试相关"></a>11. 测试相关</h3><p><strong><code>@ActiveProfiles</code>一般作用于测试类上， 用于声明生效的 Spring 配置文件。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = RANDOM_PORT)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;test&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBase</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>@Test</code>声明一个方法为测试方法</strong></p>
<p><strong><code>@Transactional</code>被声明的测试方法的数据会回滚，避免污染测试数据。</strong></p>
<p><strong><code>@WithMockUser</code> Spring Security 提供的，用来模拟一个真实用户，并且可以赋予权限。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@WithMockUser(username = &quot;user-id-18163138155&quot;, authorities = &quot;ROLE_TEACHER&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">should_import_student_success</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>暂时总结到这里吧！虽然花了挺长时间才写完，不过可能还是会一些常用的注解的被漏掉，所以，我将文章也同步到了 Github 上去，Github 地址： 欢迎完善！</em></p>
<p>本文已经收录进我的 75K Star 的 Java 开源项目 JavaGuide：<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide">https://github.com/Snailclimb/JavaGuide</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/framework/spring/SpringBoot+Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93/" data-id="cks75dy6h000v7kve79ty4qdy" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/framework/spring/Spring" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/framework/spring/Spring/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.064Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Spring相关教程-资料"><a href="#Spring相关教程-资料" class="headerlink" title="Spring相关教程/资料"></a>Spring相关教程/资料</h2><h3 id="官网相关"><a href="#官网相关" class="headerlink" title="官网相关"></a>官网相关</h3><ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/">Spring官网</a>、<a target="_blank" rel="noopener" href="https://spring.io/projects">Spring系列主要项目</a>、<a target="_blank" rel="noopener" href="https://spring.io/guides">Spring官网指南</a>、<a target="_blank" rel="noopener" href="https://spring.io/docs/reference">官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.0.14.RELEASE/spring-framework-reference/index.html">spring-framework-reference</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/4.3.17.RELEASE/javadoc-api/">Spring Framework 4.3.17.RELEASE API</a></li>
</ul>
<h2 id="系统学习教程"><a href="#系统学习教程" class="headerlink" title="系统学习教程"></a>系统学习教程</h2><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul>
<li> <a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/spring/transaction-management.html">极客学院Spring Wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3cschool.cn/wkspring/f6pk1ic8.html">Spring W3Cschool教程 </a></li>
</ul>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://study.163.com/course/courseMain.htm?courseId=1004475015#/courseDetail?tab=1&35">网易云课堂——58集精通java教程Spring框架开发</a></p>
</li>
<li><p> <a target="_blank" rel="noopener" href="https://www.imooc.com/">慕课网相关视频</a></p>
</li>
<li><p><strong>黑马视频和尚硅谷视频（非常推荐）：</strong> 微信公众号：“<strong>JavaGuide</strong>”后台回复关键字 “<strong>1</strong>” 免费领取。</p>
</li>
</ul>
<h2 id="面试必备知识点"><a href="#面试必备知识点" class="headerlink" title="面试必备知识点"></a>面试必备知识点</h2><h3 id="SpringAOP-IOC实现原理"><a href="#SpringAOP-IOC实现原理" class="headerlink" title="SpringAOP,IOC实现原理"></a>SpringAOP,IOC实现原理</h3><p>AOP实现原理、动态代理和静态代理、Spring IOC的初始化过程、IOC原理、自己实现怎么实现一个IOC容器？这些东西都是经常会被问到的。</p>
<p>推荐阅读：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="http://www.coolblog.xyz/2018/01/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP-%E4%B8%8A%E7%AF%87/">自己动手实现的 Spring IOC 和 AOP - 上篇</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="http://www.coolblog.xyz/2018/01/18/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%9A%84-Spring-IOC-%E5%92%8C-AOP-%E4%B8%8B%E7%AF%87/">自己动手实现的 Spring IOC 和 AOP - 下篇</a></p>
</li>
</ul>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>AOP思想的实现一般都是基于 <strong>代理模式</strong> ，在JAVA中一般采用JDK动态代理模式，但是我们都知道，<strong>JDK动态代理模式只能代理接口而不能代理类</strong>。因此，Spring AOP 会这样子来进行切换，因为Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理。</p>
<ul>
<li>如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；</li>
<li>如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类——不过这个选择过程对开发者完全透明、开发者也无需关心。</li>
</ul>
<p>推荐阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/puyangsky/p/6218925.html">静态代理、JDK动态代理、CGLIB动态代理讲解</a> ：我们知道AOP思想的实现一般都是基于 <strong>代理模式</strong> ，所以在看下面的文章之前建议先了解一下静态代理以及JDK动态代理、CGLIB动态代理的实现方式。</li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5aa7818af265da23844040c6">Spring AOP 入门</a> ：带你入门的一篇文章。这篇文章主要介绍了AOP中的基本概念：5种类型的通知（Before，After，After-returning，After-throwing，Around）；Spring中对AOP的支持：AOP思想的实现一般都是基于代理模式，在Java中一般采用JDK动态代理模式，Spring AOP 同时支持 CGLIB、ASPECTJ、JDK动态代理，</li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a55af9e518825734d14813f">Spring AOP 基于AspectJ注解如何实现AOP</a> ： <strong>AspectJ是一个AOP框架，它能够对java代码进行AOP编译（一般在编译期进行），让java代码具有AspectJ的AOP功能（当然需要特殊的编译器）</strong>，可以这样说AspectJ是目前实现AOP框架中最成熟，功能最丰富的语言，更幸运的是，AspectJ与java程序完全兼容，几乎是无缝关联，因此对于有java编程基础的工程师，上手和使用都非常容易。Spring注意到AspectJ在AOP的实现方式上依赖于特殊编译器(ajc编译器)，因此Spring很机智回避了这点，转向采用动态代理技术的实现原理来构建Spring AOP的内部机制（动态织入），这是与AspectJ（静态织入）最根本的区别。<strong>Spring 只是使用了与 AspectJ 5 一样的注解，但仍然没有使用 AspectJ 的编译器，底层依是动态代理技术的实现，因此并不依赖于 AspectJ 的编译器</strong>。 Spring AOP虽然是使用了那一套注解，其实实现AOP的底层是使用了动态代理(JDK或者CGLib)来动态植入。至于AspectJ的静态植入，不是本文重点，所以只提一提。</li>
<li><a target="_blank" rel="noopener" href="https://www.imooc.com/learn/869">探秘Spring AOP（慕课网视频，很不错）</a>:慕课网视频，讲解的很不错，详细且深入</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fighterandknight/article/details/51209822">spring源码剖析（六）AOP实现原理剖析</a> :通过源码分析Spring AOP的原理</li>
</ul>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wang-meng/p/5597490.html">[Spring框架]Spring IOC的原理及详解。</a></li>
<li><a target="_blank" rel="noopener" href="https://yikun.github.io/2015/05/29/Spring-IOC%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">Spring IOC核心源码学习</a> :比较简短，推荐阅读。</li>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">Spring IOC 容器源码分析</a> :强烈推荐，内容详尽，而且便于阅读。</li>
<li><a target="_blank" rel="noopener" href="https://www.qzztf.com/2019/08/21/Bean%E5%88%9D%E5%A7%8B%E5%8C%96/#Bean-%E5%AE%9E%E4%BE%8B%E5%8C%96">Bean初始化过程</a></li>
</ul>
<h2 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b00c52ef265da0b95276091">可能是最漂亮的Spring事务管理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5b010f27518825426539ba38">Spring编程式和声明式事务实例讲解</a></li>
</ul>
<h3 id="Spring单例与线程安全"><a href="#Spring单例与线程安全" class="headerlink" title="Spring单例与线程安全"></a>Spring单例与线程安全</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxuyuanzhilu/p/6404991.html">Spring框架中的单例模式（源码解读）</a>:单例模式是一种常用的软件设计模式。通过单例模式可以保证系统中一个类只有一个实例。spring依赖注入时，使用了 多重判断加锁 的单例模式。</li>
</ul>
<h3 id="Spring源码阅读"><a href="#Spring源码阅读" class="headerlink" title="Spring源码阅读"></a>Spring源码阅读</h3><p>阅读源码不仅可以加深我们对Spring设计思想的理解，提高自己的编码水平，还可以让自己在面试中如鱼得水。下面的是Github上的一个开源的Spring源码阅读，大家有时间可以看一下，当然你如果有时间也可以自己慢慢研究源码。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/seaswalker/Spring/blob/master/note/Spring.md">spring-core</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/seaswalker/Spring/blob/master/note/spring-aop.md">spring-aop</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/seaswalker/Spring/blob/master/note/spring-context.md">spring-context</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/seaswalker/Spring/blob/master/note/spring-task.md">spring-task</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/seaswalker/Spring/blob/master/note/spring-transaction.md">spring-transaction</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/seaswalker/Spring/blob/master/note/spring-mvc.md">spring-mvc</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/seaswalker/Spring/blob/master/note/guava-cache.md">guava-cache</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/framework/spring/Spring/" data-id="cks75dy64000i7kvegdmw4qnj" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/11/system-design/website-architecture/%E5%85%B3%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%87%82%E7%9A%8410%E4%B8%AA%E9%97%AE%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/11/system-design/website-architecture/8%20%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/11/system-design/micro-service/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/11/system-design/micro-service/spring-cloud/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/11/system-design/high-availability/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>