<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Zyao</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Zyao">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Zyao">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Zyao" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zyao</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-system-design/framework/spring/Spring-Design-Patterns" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/framework/spring/Spring-Design-Patterns/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.061Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>点击关注<a href="#%E5%85%AC%E4%BC%97%E5%8F%B7">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p>
<!-- TOC -->

<ul>
<li><a href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5di">控制反转(IoC)和依赖注入(DI)</a></li>
<li><a href="#%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">工厂设计模式</a></li>
<li><a href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">单例设计模式</a></li>
<li><a href="#%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">代理设计模式</a><ul>
<li><a href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%9C%A8-aop-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8">代理模式在 AOP 中的应用</a></li>
<li><a href="#spring-aop-%E5%92%8C-aspectj-aop-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Spring AOP 和 AspectJ AOP 有什么区别?</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">模板方法</a></li>
<li><a href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者模式</a><ul>
<li><a href="#spring-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%92%E8%89%B2">Spring 事件驱动模型中的三种角色</a><ul>
<li><a href="#%E4%BA%8B%E4%BB%B6%E8%A7%92%E8%89%B2">事件角色</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E8%80%85%E8%A7%92%E8%89%B2">事件监听者角色</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E8%80%85%E8%A7%92%E8%89%B2">事件发布者角色</a></li>
</ul>
</li>
<li><a href="#spring-%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93">Spring 的事件流程总结</a></li>
</ul>
</li>
<li><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">适配器模式</a><ul>
<li><a href="#spring-aop%E4%B8%AD%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">spring AOP中的适配器模式</a></li>
<li><a href="#spring-mvc%E4%B8%AD%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">spring MVC中的适配器模式</a></li>
</ul>
</li>
<li><a href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F">装饰者模式</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
<!-- /TOC -->

<p>JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见。我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下，由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的设计模式。</p>
<p>Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p>
<h2 id="控制反转-IoC-和依赖注入-DI"><a href="#控制反转-IoC-和依赖注入-DI" class="headerlink" title="控制反转(IoC)和依赖注入(DI)"></a>控制反转(IoC)和依赖注入(DI)</h2><p><strong>IoC(Inversion of Control,控制反转)</strong> 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容器管理对象，你只管使用即可)，从而降低代码之间的耦合度。<strong>IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ioc-patterns.png" alt="ioc-patterns"></p>
<p><strong>Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p>
<p>在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a>  ，非常不错。</p>
<p><strong>控制反转怎么理解呢?</strong> 举个例子：”对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中”。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权反转，这就是控制反转名字的由来。</p>
<p><strong>DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。</strong></p>
<h2 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h2><p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p>
<p><strong>两者对比：</strong></p>
<ul>
<li> <code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>ApplicationContext</code> 来说会占用更少的内存，程序启动速度更快。</li>
<li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code> ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code> ApplicationContext</code>会更多。</li>
</ul>
<p>ApplicationContext的三个实现类：</p>
<ol>
<li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li>
<li> <code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li>
<li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li>
</ol>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(</span><br><span class="line">				<span class="string">&quot;C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml&quot;</span>);</span><br><span class="line"> </span><br><span class="line">		HelloApplicationContext obj = (HelloApplicationContext) context.getBean(<span class="string">&quot;helloApplicationContext&quot;</span>);</span><br><span class="line">		obj.getMsg();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p>
<p><strong>使用单例模式的好处:</strong></p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p>
<ul>
<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>
<li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li>
<li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li>
<li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li>
</ul>
<p><strong>Spring 实现单例的方式：</strong></p>
<ul>
<li>xml : <code>&lt;bean id=&quot;userService&quot; class=&quot;top.snailclimb.UserService&quot; scope=&quot;singleton&quot;/&gt;</code></li>
<li>注解：<code>@Scope(value = &quot;singleton&quot;)</code></li>
</ul>
<p><strong>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ConcurrentHashMap（线程安全） 实现单例注册表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">        Assert.notNull(beanName, <span class="string">&quot;&#x27;beanName&#x27; must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 检查缓存中是否存在实例  </span></span><br><span class="line">            Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...省略了很多代码</span></span><br><span class="line">                <span class="comment">// 如果实例对象在不存在，我们注册到单例注册表中。</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将对象添加到单例注册表</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="keyword">this</span>.singletonObjects.put(beanName, (singletonObject != <span class="keyword">null</span> ? singletonObject : NULL_OBJECT));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h2><h3 id="代理模式在-AOP-中的应用"><a href="#代理模式在-AOP-中的应用" class="headerlink" title="代理模式在 AOP 中的应用"></a>代理模式在 AOP 中的应用</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/SpringAOPProcess.jpg" alt="SpringAOPProcess"></p>
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别?"></a>Spring AOP 和 AspectJ AOP 有什么区别?</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p> Spring AOP 已经集成了 AspectJ  ，AspectJ  应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ  相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是我们的模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">TemplateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PrimitiveOperation1();  </span><br><span class="line">        PrimitiveOperation2();</span><br><span class="line">        PrimitiveOperation3();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span>  <span class="title">PrimitiveOperation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//被子类实现的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateImpl</span> <span class="keyword">extends</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrimitiveOperation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前类实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p>
<h3 id="Spring-事件驱动模型中的三种角色"><a href="#Spring-事件驱动模型中的三种角色" class="headerlink" title="Spring 事件驱动模型中的三种角色"></a>Spring 事件驱动模型中的三种角色</h3><h4 id="事件角色"><a href="#事件角色" class="headerlink" title="事件角色"></a>事件角色</h4><p> <code>ApplicationEvent</code> (<code>org.springframework.context</code>包下)充当事件的角色,这是一个抽象类，它继承了<code>java.util.EventObject</code>并实现了 <code>java.io.Serializable</code>接口。</p>
<p>Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自<code>ApplicationContextEvent</code>)：</p>
<ul>
<li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li>
<li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li>
<li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li>
<li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件。</li>
</ul>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ApplicationEvent-Subclass.png" alt="ApplicationEvent-Subclass"></p>
<h4 id="事件监听者角色"><a href="#事件监听者角色" class="headerlink" title="事件监听者角色"></a>事件监听者角色</h4><p><code>ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code>onApplicationEvent（）</code>方法来处理<code>ApplicationEvent</code>。<code>ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code>ApplicationEvent</code>就可以了。所以，在 Spring中我们只要实现 <code>ApplicationListener</code> 接口的 <code>onApplicationEvent()</code> 方法即可完成监听事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.context;</span><br><span class="line"><span class="keyword">import</span> java.util.EventListener;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件发布者角色"><a href="#事件发布者角色" class="headerlink" title="事件发布者角色"></a>事件发布者角色</h4><p><code>ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.publishEvent((Object)event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object var1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ApplicationEventPublisher</code> 接口的<code>publishEvent（）</code>这个方法在<code>AbstractApplicationContext</code>类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过<code>ApplicationEventMulticaster</code>来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</p>
<h3 id="Spring-的事件流程总结"><a href="#Spring-的事件流程总结" class="headerlink" title="Spring 的事件流程总结"></a>Spring 的事件流程总结</h3><ol>
<li>定义一个事件: 实现一个继承自 <code>ApplicationEvent</code>，并且写相应的构造函数；</li>
<li>定义一个事件监听者：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法；</li>
<li>使用事件发布者发布消息:  可以通过 <code>ApplicationEventPublisher  </code> 的 <code>publishEvent()</code> 方法发布消息。</li>
</ol>
<p>Example:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoEvent</span><span class="params">(Object source,String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> message;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">DemoEvent</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用onApplicationEvent接收消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(DemoEvent event)</span> </span>&#123;</span><br><span class="line">        String msg = event.getMessage();</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到的信息是：&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPublisher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">//发布事件</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> DemoEvent(<span class="keyword">this</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当调用 <code>DemoPublisher </code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish(&quot;你好&quot;)</code> ，控制台就会打印出:<code>接收到的信息是：你好</code> 。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p>
<h3 id="spring-AOP中的适配器模式"><a href="#spring-AOP中的适配器模式" class="headerlink" title="spring AOP中的适配器模式"></a>spring AOP中的适配器模式</h3><p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter </code> 。Advice 常用的类型有：<code>BeforeAdvice</code>（目标方法调用前,前置通知）、<code>AfterAdvice</code>（目标方法调用后,后置通知）、<code>AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。Spring预定义的通知要通过对应的适配器，适配成 <code>MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</p>
<h3 id="spring-MVC中的适配器模式"><a href="#spring-MVC中的适配器模式" class="headerlink" title="spring MVC中的适配器模式"></a>spring MVC中的适配器模式</h3><p>在Spring MVC中，<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由<code>HandlerAdapter</code> 适配器处理。<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</p>
<p><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code> 直接获取对应类型的 <code>Controller</code>，需要的自行来判断，像下面这段代码一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> MultiActionController)&#123;  </span><br><span class="line">   ((MultiActionController)mappedHandler.getHandler()).xxx  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mappedHandler.getHandler() <span class="keyword">instanceof</span> XXX)&#123;  </span><br><span class="line">    ...  </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(...)&#123;  </span><br><span class="line">   ...  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>假如我们再增加一个 <code>Controller</code>类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code>InputStream</code>家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code>InputStream</code> 代码的情况下扩展了它的功能。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Decorator.jpg" alt="装饰者模式示意图"></p>
<p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code>或者 <code>Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring 框架中用到了哪些设计模式？</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>……</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《Spring技术内幕》</li>
<li><a target="_blank" rel="noopener" href="https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/">https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.yeamin.top/2018/03/27/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Spring%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">http://blog.yeamin.top/2018/03/27/单例模式-Spring单例实现原理分析/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.tutorialsteacher.com/ioc/inversion-of-control">https://www.tutorialsteacher.com/ioc/inversion-of-control</a> </li>
<li><a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a8eb261f265da4e9e307230">https://juejin.im/post/5a8eb261f265da4e9e307230</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ba28986f265da0abc2b6084">https://juejin.im/post/5ba28986f265da0abc2b6084</a></li>
</ul>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p>
<p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#%E5%85%AC%E4%BC%97%E5%8F%B7">公众号</a>后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p>
<p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/167598cd2e17b8ec.png" alt="我的公众号"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/framework/spring/Spring-Design-Patterns/" data-id="cks75dy6c000q7kvegfuzfnl3" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/framework/mybatis/mybatis-interview" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/framework/mybatis/mybatis-interview/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.053Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本篇文章是JavaGuide收集自网络，原出处不明。</p>
</blockquote>
<p>MyBatis 技术内幕系列博客，从原理和源码角度，介绍了其内部实现细节，无论是写的好与不好，我确实是用心写了，由于并不是介绍如何使用 MyBatis 的文章，所以，一些参数使用细节略掉了，我们的目标是介绍 MyBatis 的技术架构和重要组成部分，以及基本运行原理。</p>
<p>博客写的很辛苦，但是写出来却不一定好看，所谓开始很兴奋，过程很痛苦，结束很遗憾。要求不高，只要读者能从系列博客中，学习到一点其他博客所没有的技术点，作为作者，我就很欣慰了，我也读别人写的博客，通常对自己当前研究的技术，是很有帮助的。</p>
<p>尽管还有很多可写的内容，但是，我认为再写下去已经没有意义，任何其他小的功能点，都是在已经介绍的基本框架和基本原理下运行的，只有结束，才能有新的开始。写博客也积攒了一些经验，源码多了感觉就是复制黏贴，源码少了又觉得是空谈原理，将来再写博客，我希望是“精炼博文”，好读好懂美观读起来又不累，希望自己能再写一部开源分布式框架原理系列博客。</p>
<p>有胆就来，我出几道 MyBatis 面试题，看你能回答上来几道（都是我出的，可不是网上找的）。</p>
<h4 id="1、-和-的区别是什么？"><a href="#1、-和-的区别是什么？" class="headerlink" title="1、#{}和${}的区别是什么？"></a>1、#{}和${}的区别是什么？</h4><p>注：这道题是面试官面试我同事的。</p>
<p>答：</p>
<ul>
<li><code>$&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc.Driver</code>。</li>
<li><code>#&#123;&#125;</code>是 sql 的参数占位符，MyBatis 会将 sql 中的<code>#&#123;&#125;</code>替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，<code>#&#123;item.name&#125;</code> 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 <code>param.getItem().getName()</code>。</li>
</ul>
<h4 id="2、Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？"><a href="#2、Xml-映射文件中，除了常见的-select-insert-update-delete-标签之外，还有哪些标签？" class="headerlink" title="2、Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？"></a>2、Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</h4><p>注：这道题是京东面试官面试我时问的。</p>
<p>答：还有很多其他的标签，<code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态 sql 的 9 个标签，<code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>等，其中<sql>为 sql 片段标签，通过<code>&lt;include&gt;</code>标签引入 sql 片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</p>
<h4 id="3、最佳实践中，通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？"><a href="#3、最佳实践中，通常一个-Xml-映射文件，都会写一个-Dao-接口与之对应，请问，这个-Dao-接口的工作原理是什么？Dao-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="3、最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？"></a>3、最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</h4><p>注：这道题也是京东面试官面试我被问的。</p>
<p>答：Dao 接口，就是人们常说的 <code>Mapper</code>接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中<code>MappedStatement</code>的 id 值，接口方法内的参数，就是传递给 sql 的参数。<code>Mapper</code>接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个<code>MappedStatement</code>，举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code>，可以唯一找到 namespace 为<code>com.mybatis3.mappers.StudentDao</code>下面<code>id = findStudentById</code>的<code>MappedStatement</code>。在 MyBatis 中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<code>MappedStatement</code>对象。</p>
<p><del>Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</del></p>
<p>Dao 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复。</p>
<p>Mybatis版本3.3.0，亲测如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mapper接口里面方法重载</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StuMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">List&lt;Student&gt; <span class="title">getAllStu</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function">List&lt;Student&gt; <span class="title">getAllStu</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>StuMapper.xml</code> 中利用Mybatis的动态sql就可以实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;getAllStu&quot;</span> resultType=<span class="string">&quot;com.pojo.Student&quot;</span>&gt;</span><br><span class="line">		select * from student</span><br><span class="line">	&lt;where&gt;</span><br><span class="line">		&lt;<span class="keyword">if</span> test=<span class="string">&quot;id != null&quot;</span>&gt;</span><br><span class="line">			id = #&#123;id&#125;</span><br><span class="line">		&lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">	&lt;/where&gt;</span><br><span class="line">	&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>能正常运行，并能得到相应的结果，这样就实现了在Dao接口中写重载方法。</p>
<p><strong>Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p>
<p>相关 issue ：<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/1122">更正：Dao 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复！</a>。</p>
<p>Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行<code>MappedStatement</code>所代表的 sql，然后将 sql 执行结果返回。</p>
<h5 id="补充："><a href="#补充：" class="headerlink" title="==补充：=="></a>==补充：==</h5><p>Dao接口方法可以重载，但是需要满足以下条件：</p>
<ol>
<li>仅有一个无参方法和一个有参方法</li>
<li>多个有参方法时，参数数量必须一致。且使用相同的 <code>@Param</code> ，或者使用 <code>param1</code> 这种</li>
</ol>
<p>测试如下：</p>
<p><code>PersonDao.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">queryById</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">queryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">queryById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> Long id, <span class="meta">@Param(&quot;name&quot;)</span> String name)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>PersonMapper.xml</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;PersonMap&quot;</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">      id, name, age, address</span><br><span class="line">    from person</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id != null&quot;</span>&gt;</span></span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">            name = #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    limit 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>org.apache.ibatis.scripting.xmltags.DynamicContext.ContextAccessor#getProperty</code>方法用于获取<code>&lt;if&gt;</code>标签中的条件值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProperty</span><span class="params">(Map context, Object target, Object name)</span> </span>&#123;</span><br><span class="line">  Map map = (Map) target;</span><br><span class="line"></span><br><span class="line">  Object result = map.get(name);</span><br><span class="line">  <span class="keyword">if</span> (map.containsKey(name) || result != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object parameterObject = map.get(PARAMETER_OBJECT_KEY);</span><br><span class="line">  <span class="keyword">if</span> (parameterObject <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((Map)parameterObject).get(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>parameterObject</code>为map，存放的是Dao接口中参数相关信息。</p>
<p><code>((Map)parameterObject).get(name)</code>方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">super</span>.containsKey(key)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Parameter &#x27;&quot;</span> + key + <span class="string">&quot;&#x27; not found. Available parameters are &quot;</span> + keySet());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>queryById()</code>方法执行时，<code>parameterObject</code>为null，<code>getProperty</code>方法返回null值，<code>&lt;if&gt;</code>标签获取的所有条件值都为null，所有条件不成立，动态sql可以正常执行。</li>
<li><code>queryById(1L)</code>方法执行时，<code>parameterObject</code>为map，包含了<code>id</code>和<code>param1</code>两个key值。当获取<code>&lt;if&gt;</code>标签中<code>name</code>的属性值时，进入<code>((Map)parameterObject).get(name)</code>方法中，map中key不包含<code>name</code>，所以抛出异常。</li>
<li><code>queryById(1L,&quot;1&quot;)</code>方法执行时，<code>parameterObject</code>中包含<code>id</code>,<code>param1</code>,<code>name</code>,<code>param2</code>四个key值，<code>id</code>和<code>name</code>属性都可以获取到，动态sql正常执行。</li>
</ol>
<h4 id="4、MyBatis-是如何进行分页的？分页插件的原理是什么？"><a href="#4、MyBatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="4、MyBatis 是如何进行分页的？分页插件的原理是什么？"></a>4、MyBatis 是如何进行分页的？分页插件的原理是什么？</h4><p>注：我出的。</p>
<p>答：MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：<code>select _ from student</code>，拦截 sql 后重写为：<code>select t._ from （select \* from student）t limit 0，10</code></p>
<h4 id="5、简述-MyBatis-的插件运行原理，以及如何编写一个插件。"><a href="#5、简述-MyBatis-的插件运行原理，以及如何编写一个插件。" class="headerlink" title="5、简述 MyBatis 的插件运行原理，以及如何编写一个插件。"></a>5、简述 MyBatis 的插件运行原理，以及如何编写一个插件。</h4><p>注：我出的。</p>
<p>答：MyBatis 仅可以编写针对 <code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code> 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 <code>InvocationHandler</code> 的 <code>invoke()</code>方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现 MyBatis 的 Interceptor 接口并复写<code> intercept()</code>方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h4 id="6、MyBatis-执行批量插入，能返回数据库主键列表吗？"><a href="#6、MyBatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="6、MyBatis 执行批量插入，能返回数据库主键列表吗？"></a>6、MyBatis 执行批量插入，能返回数据库主键列表吗？</h4><p>注：我出的。</p>
<p>答：能，JDBC 都能，MyBatis 当然也能。</p>
<h4 id="7、MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#7、MyBatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="7、MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>7、MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h4><p>注：我出的。</p>
<p>答：MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code>。</p>
<p>其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<h4 id="8、MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#8、MyBatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="8、MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>8、MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h4><p>注：我出的。</p>
<p>答：第一种是使用<code>&lt;resultMap&gt;</code>标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h4 id="9、MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#9、MyBatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="9、MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>9、MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h4><p>注：我出的。</p>
<p>答：能，MyBatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可；多对多查询，其实就是一对多查询，只需要把 <code>selectOne()</code>修改为 <code>selectList()</code>即可。</p>
<p>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p>
<p>那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是<code>&lt;resultMap&gt;</code>标签内的<code>&lt;id&gt;</code>子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据<id>列值来完成 100 条记录的去重复功能，<code>&lt;id&gt;</code>可以有多个，代表了联合主键的语意。</p>
<p>同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。</p>
<p>举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，MyBatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。</p>
<table>
<thead>
<tr>
<th>t_id</th>
<th>t_name</th>
<th>s_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>teacher</td>
<td>38</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>39</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>40</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>41</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>42</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>43</td>
</tr>
</tbody></table>
<h4 id="10、MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#10、MyBatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="10、MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>10、MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h4><p>注：我出的。</p>
<p>答：MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 <code>lazyLoadingEnabled=true|false。</code></p>
<p>它的原理是，使用<code> CGLIB</code> 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 <code>a.getB().getName()</code>，拦截器 <code>invoke()</code>方法发现 <code>a.getB()</code>是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 <code>a.getB().getName()</code>方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。</p>
<h4 id="11、MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？"><a href="#11、MyBatis-的-Xml-映射文件中，不同的-Xml-映射文件，id-是否可以重复？" class="headerlink" title="11、MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？"></a>11、MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？</h4><p>注：我出的。</p>
<p>答：不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。</p>
<p>原因就是 namespace+id 是作为 <code>Map&lt;String, MappedStatement&gt;</code>的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。</p>
<h4 id="12、MyBatis-中如何执行批处理？"><a href="#12、MyBatis-中如何执行批处理？" class="headerlink" title="12、MyBatis 中如何执行批处理？"></a>12、MyBatis 中如何执行批处理？</h4><p>注：我出的。</p>
<p>答：使用 BatchExecutor 完成批处理。</p>
<h4 id="13、MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#13、MyBatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="13、MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>13、MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h4><p>注：我出的</p>
<p>答：MyBatis 有三种基本的 Executor 执行器，**<code>SimpleExecutor</code>、<code>ReuseExecutor</code>、<code>BatchExecutor</code>。**</p>
<p><strong><code>SimpleExecutor</code>：</strong>每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。</p>
<p><strong><code>ReuseExecutor</code>：</strong>执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。</p>
<p><strong><code>BatchExecutor</code>：</strong>执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。</p>
<p>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p>
<h4 id="14、MyBatis-中如何指定使用哪一种-Executor-执行器？"><a href="#14、MyBatis-中如何指定使用哪一种-Executor-执行器？" class="headerlink" title="14、MyBatis 中如何指定使用哪一种 Executor 执行器？"></a>14、MyBatis 中如何指定使用哪一种 Executor 执行器？</h4><p>注：我出的</p>
<p>答：在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 <code>DefaultSqlSessionFactory</code> 的创建 SqlSession 的方法传递 ExecutorType 类型参数。</p>
<h4 id="15、MyBatis-是否可以映射-Enum-枚举类？"><a href="#15、MyBatis-是否可以映射-Enum-枚举类？" class="headerlink" title="15、MyBatis 是否可以映射 Enum 枚举类？"></a>15、MyBatis 是否可以映射 Enum 枚举类？</h4><p>注：我出的</p>
<p>答：MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上。映射方式为自定义一个 <code>TypeHandler</code>，实现 <code>TypeHandler</code> 的 <code>setParameter()</code>和 <code>getResult()</code>接口方法。<code>TypeHandler</code> 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 <code>setParameter()</code>和 <code>getResult()</code>两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。</p>
<h4 id="16、MyBatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#16、MyBatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="16、MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>16、MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h4><p>注：我出的</p>
<p>答：虽然 MyBatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。</p>
<p>原理是，MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，MyBatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<h4 id="17、简述-MyBatis-的-Xml-映射文件和-MyBatis-内部数据结构之间的映射关系？"><a href="#17、简述-MyBatis-的-Xml-映射文件和-MyBatis-内部数据结构之间的映射关系？" class="headerlink" title="17、简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？"></a>17、简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？</h4><p>注：我出的</p>
<p>答：MyBatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，<code>&lt;parameterMap&gt;</code>标签会被解析为 <code>ParameterMap</code> 对象，其每个子元素会被解析为 ParameterMapping 对象。<code>&lt;resultMap&gt;</code>标签会被解析为 <code>ResultMap</code> 对象，其每个子元素会被解析为 <code>ResultMapping</code> 对象。每一个<code>&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;</code>标签均会被解析为 <code>MappedStatement</code> 对象，标签内的 sql 会被解析为 BoundSql 对象。</p>
<h4 id="18、为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#18、为什么说-MyBatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="18、为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>18、为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h4><p>注：我出的</p>
<p>答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>
<p>面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的 MyBatis 系列博客中都有详细讲解和原理分析。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/framework/mybatis/mybatis-interview/" data-id="cks75dy6c000p7kvebqrkes45" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/distributed-system/zookeeper/zookeeper-plus" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/distributed-system/zookeeper/zookeeper-plus/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.012Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://juejin.im/user/5c33853851882525ea106810">FrancisQ</a> 投稿。</p>
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

<ul>
<li><a href="#1-%E5%A5%BD%E4%B9%85%E4%B8%8D%E8%A7%81">1. 好久不见</a></li>
<li><a href="#2-%E4%BB%80%E4%B9%88%E6%98%AFzookeeper">2. 什么是ZooKeeper</a></li>
<li><a href="#3-%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98">3. 一致性问题</a></li>
<li><a href="#4-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%AE%97%E6%B3%95">4. 一致性协议和算法</a><ul>
<li><a href="#41-2pc%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">4.1. 2PC（两阶段提交）</a></li>
<li><a href="#42-3pc%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4">4.2. 3PC（三阶段提交）</a></li>
<li><a href="#43-paxos-%E7%AE%97%E6%B3%95">4.3. <code>Paxos</code> 算法</a><ul>
<li><a href="#431-prepare-%E9%98%B6%E6%AE%B5">4.3.1. prepare 阶段</a></li>
<li><a href="#432-accept-%E9%98%B6%E6%AE%B5">4.3.2. accept 阶段</a></li>
<li><a href="#433-paxos-%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF%E9%97%AE%E9%A2%98">4.3.3. <code>paxos</code> 算法的死循环问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-%E5%BC%95%E5%87%BA-zab">5. 引出 <code>ZAB</code></a><ul>
<li><a href="#51-zookeeper-%E6%9E%B6%E6%9E%84">5.1. <code>Zookeeper</code> 架构</a></li>
<li><a href="#52-zab-%E4%B8%AD%E7%9A%84%E4%B8%89%E4%B8%AA%E8%A7%92%E8%89%B2">5.2. <code>ZAB</code> 中的三个角色</a></li>
<li><a href="#53-%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F">5.3. 消息广播模式</a></li>
<li><a href="#54-%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F">5.4. 崩溃恢复模式</a></li>
</ul>
</li>
<li><a href="#6-zookeeper%E7%9A%84%E5%87%A0%E4%B8%AA%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86">6. Zookeeper的几个理论知识</a><ul>
<li><a href="#61-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">6.1. 数据模型</a></li>
<li><a href="#62-%E4%BC%9A%E8%AF%9D">6.2. 会话</a></li>
<li><a href="#63-acl">6.3. ACL</a></li>
<li><a href="#64-watcher%E6%9C%BA%E5%88%B6">6.4. Watcher机制</a></li>
</ul>
</li>
<li><a href="#7-zookeeper%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">7. Zookeeper的几个典型应用场景</a><ul>
<li><a href="#71-%E9%80%89%E4%B8%BB">7.1. 选主</a></li>
<li><a href="#72-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">7.2. 分布式锁</a></li>
<li><a href="#73-%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1">7.3. 命名服务</a></li>
<li><a href="#74-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E5%92%8C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83">7.4. 集群管理和注册中心</a></li>
</ul>
</li>
<li><a href="#8-%E6%80%BB%E7%BB%93">8. 总结</a></li>
</ul>
<!-- /code_chunk_output -->


<h2 id="1-好久不见"><a href="#1-好久不见" class="headerlink" title="1. 好久不见"></a>1. 好久不见</h2><p>离上一篇文章的发布也快一个月了，想想已经快一个月没写东西了，其中可能有期末考试、课程设计和驾照考试，但这都不是借口！</p>
<p>一到冬天就懒的不行，望广大掘友督促我🙄🙄✍️✍️。</p>
<blockquote>
<p>文章很长，先赞后看，养成习惯。❤️ 🧡 💛 💚 💙 💜</p>
</blockquote>
<h2 id="2-什么是ZooKeeper"><a href="#2-什么是ZooKeeper" class="headerlink" title="2. 什么是ZooKeeper"></a>2. 什么是ZooKeeper</h2><p><code>ZooKeeper</code> 由 <code>Yahoo</code> 开发，后来捐赠给了 <code>Apache</code> ，现已成为 <code>Apache</code> 顶级项目。<code>ZooKeeper</code> 是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于 <code>Paxos</code> 算法的 <code>ZAB</code> 协议完成的。其主要功能包括：配置维护、分布式同步、集群管理、分布式事务等。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7c349891b773671514a68f057b2e14f8.png" alt="zookeeper"></p>
<p>简单来说， <code>ZooKeeper</code> 是一个 <strong>分布式协调服务框架</strong> 。分布式？协调服务？这啥玩意？🤔🤔</p>
<p>其实解释到分布式这个概念的时候，我发现有些同学并不是能把 **分布式和集群 **这两个概念很好的理解透。前段时间有同学和我探讨起分布式的东西，他说分布式不就是加机器吗？一台机器不够用再加一台抗压呗。当然加机器这种说法也无可厚非，你一个分布式系统必定涉及到多个机器，但是你别忘了，计算机学科中还有一个相似的概念—— <code>Cluster</code> ，集群不也是加机器吗？但是 集群 和 分布式 其实就是两个完全不同的概念。</p>
<p>比如，我现在有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也 <strong>一样</strong> 提供秒杀服务，这个时候就是 <strong><code>Cluster</code> 集群</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ffcb080eb66f242ffcd8d2047a7f46aa.png" alt="cluster"></p>
<p>但是，我现在换一种方式，我将一个秒杀服务 <strong>拆分成多个子服务</strong> ，比如创建订单服务，增加积分服务，扣优惠券服务等等，<strong>然后我将这些子服务都部署在不同的服务器上</strong> ，这个时候就是  <strong><code>Distributed</code> 分布式</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/07191f38aa947b0075e5c0a6a019a11d.png" alt="distributed"></p>
<p>而我为什么反驳同学所说的分布式就是加机器呢？因为我认为加机器更加适用于构建集群，因为它真是只有加机器。而对于分布式来说，你首先需要将业务进行拆分，然后再加机器（不仅仅是加机器那么简单），同时你还要去解决分布式带来的一系列问题。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2b2fbc21abfb3f6547a2121f28c6d00f.png"></p>
<p>比如各个分布式组件如何协调起来，如何减少各个系统之间的耦合度，分布式事务的处理，如何去配置整个分布式系统等等。<code>ZooKeeper</code> 主要就是解决这些问题的。</p>
<h2 id="3-一致性问题"><a href="#3-一致性问题" class="headerlink" title="3. 一致性问题"></a>3. 一致性问题</h2><p>设计一个分布式系统必定会遇到一个问题—— <strong>因为分区容忍性（partition tolerance）的存在，就必定要求我们需要在系统可用性（availability）和数据一致性（consistency）中做出权衡</strong> 。这就是著名的 <code>CAP</code> 定理。</p>
<p>理解起来其实很简单，比如说把一个班级作为整个系统，而学生是系统中的一个个独立的子系统。这个时候班里的小红小明偷偷谈恋爱被班里的大嘴巴小花发现了，小花欣喜若狂告诉了周围的人，然后小红小明谈恋爱的消息在班级里传播起来了。当在消息的传播（散布）过程中，你抓到一个同学问他们的情况，如果回答你不知道，那么说明整个班级系统出现了数据不一致的问题（因为小花已经知道这个消息了）。而如果他直接不回答你，因为整个班级有消息在进行传播（为了保证一致性，需要所有人都知道才可提供服务），这个时候就出现了系统的可用性问题。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/34ffff41f6ca4f221ca9d9ad6f0b5470.png"></p>
<p>而上述前者就是 <code>Eureka</code> 的处理方式，它保证了AP（可用性），后者就是我们今天所要讲的 <code>ZooKeeper</code> 的处理方式，它保证了CP（数据一致性）。</p>
<h2 id="4-一致性协议和算法"><a href="#4-一致性协议和算法" class="headerlink" title="4. 一致性协议和算法"></a>4. 一致性协议和算法</h2><p>而为了解决数据一致性问题，在科学家和程序员的不断探索中，就出现了很多的一致性协议和算法。比如 2PC（两阶段提交），3PC（三阶段提交），Paxos算法等等。</p>
<p>这时候请你思考一个问题，同学之间如果采用传纸条的方式去传播消息，那么就会出现一个问题——我咋知道我的小纸条有没有传到我想要传递的那个人手中呢？万一被哪个小家伙给劫持篡改了呢，对吧？</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b0e01fe3213dcc1535c31298ba9bdfbc.png"></p>
<p>这个时候就引申出一个概念—— <strong>拜占庭将军问题</strong> 。它意指 <strong>在不可靠信道上试图通过消息传递的方式达到一致性是不可能的</strong>， 所以所有的一致性算法的 <strong>必要前提</strong> 就是安全可靠的消息通道。</p>
<p>而为什么要去解决数据一致性的问题？你想想，如果一个秒杀系统将服务拆分成了下订单和加积分服务，这两个服务部署在不同的机器上了，万一在消息的传播过程中积分系统宕机了，总不能你这边下了订单却没加积分吧？你总得保证两边的数据需要一致吧？</p>
<h3 id="4-1-2PC（两阶段提交）"><a href="#4-1-2PC（两阶段提交）" class="headerlink" title="4.1. 2PC（两阶段提交）"></a>4.1. 2PC（两阶段提交）</h3><p>两阶段提交是一种保证分布式系统数据一致性的协议，现在很多数据库都是采用的两阶段提交协议来完成 <strong>分布式事务</strong> 的处理。</p>
<p>在介绍2PC之前，我们先来想想分布式事务到底有什么问题呢？</p>
<p>还拿秒杀系统的下订单和加积分两个系统来举例吧（我想你们可能都吐了🤮🤮🤮），我们此时下完订单会发个消息给积分系统告诉它下面该增加积分了。如果我们仅仅是发送一个消息也不收回复，那么我们的订单系统怎么能知道积分系统的收到消息的情况呢？如果我们增加一个收回复的过程，那么当积分系统收到消息后返回给订单系统一个 <code>Response</code> ，但在中间出现了网络波动，那个回复消息没有发送成功，订单系统是不是以为积分系统消息接收失败了？它是不是会回滚事务？但此时积分系统是成功收到消息的，它就会去处理消息然后给用户增加积分，这个时候就会出现积分加了但是订单没下成功。</p>
<p>所以我们所需要解决的是在分布式系统中，整个调用链中，我们所有服务的数据处理要么都成功要么都失败，即所有服务的 <strong>原子性问题</strong> 。</p>
<p>在两阶段提交中，主要涉及到两个角色，分别是协调者和参与者。</p>
<p>第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 <code>prepare</code> 请求（其中包括事务内容）告诉参与者你们需要执行事务了，如果能执行我发的事务内容那么就先执行但不提交，执行后请给我回复。然后参与者收到 <code>prepare</code> 消息后，他们会开始执行事务（但不提交），并将 <code>Undo</code> 和 <code>Redo</code> 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了。</p>
<p>第二阶段：第二阶段主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作，即提交事务或者回滚事务。</p>
<p>比如这个时候 <strong>所有的参与者</strong> 都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 <strong><code>Commit</code> 请求</strong> ，当参与者收到 <code>Commit</code> 请求的时候会执行前面执行的事务的 <strong>提交操作</strong> ，提交完毕之后将给协调者发送提交成功的响应。</p>
<p>而如果在第一阶段并不是所有参与者都返回了准备好了的消息，那么此时协调者将会给所有参与者发送 <strong>回滚事务的 <code>rollback</code> 请求</strong>，参与者收到之后将会 <strong>回滚它在第一阶段所做的事务处理</strong> ，然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7ce4e40b68d625676bb42c29efce046a.png" alt="2PC流程"></p>
<p>个人觉得 2PC 实现得还是比较鸡肋的，因为事实上它只解决了各个事务的原子性问题，随之也带来了很多的问题。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9af1ad68517561a8e9f5d3455a32132d.png"></p>
<ul>
<li><strong>单点故障问题</strong>，如果协调者挂了那么整个系统都处于不可用的状态了。</li>
<li><strong>阻塞问题</strong>，即当协调者发送 <code>prepare</code> 请求，参与者收到之后如果能处理那么它将会进行事务的处理但并不提交，这个时候会一直占用着资源不释放，如果此时协调者挂了，那么这些资源都不会再释放了，这会极大影响性能。</li>
<li><strong>数据不一致问题</strong>，比如当第二阶段，协调者只发送了一部分的 <code>commit</code> 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。</li>
</ul>
<h3 id="4-2-3PC（三阶段提交）"><a href="#4-2-3PC（三阶段提交）" class="headerlink" title="4.2. 3PC（三阶段提交）"></a>4.2. 3PC（三阶段提交）</h3><p>因为2PC存在的一系列问题，比如单点，容错机制缺陷等等，从而产生了 <strong>3PC（三阶段提交）</strong> 。那么这三阶段又分别是什么呢？</p>
<blockquote>
<p>千万不要吧PC理解成个人电脑了，其实他们是 phase-commit 的缩写，即阶段提交。</p>
</blockquote>
<ol>
<li><strong>CanCommit阶段</strong>：协调者向所有参与者发送 <code>CanCommit</code> 请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO 。</li>
<li><strong>PreCommit阶段</strong>：协调者根据参与者返回的响应来决定是否可以进行下面的 <code>PreCommit</code> 操作。如果上面参与者返回的都是 YES，那么协调者将向所有参与者发送 <code>PreCommit</code> 预提交请求，<strong>参与者收到预提交请求后，会进行事务的执行操作，并将 <code>Undo</code> 和 <code>Redo</code> 信息写入事务日志中</strong> ，最后如果参与者顺利执行了事务则给协调者返回成功的响应。如果在第一阶段协调者收到了 <strong>任何一个 NO</strong> 的信息，或者 <strong>在一定时间内</strong> 并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort），参与者收到中断请求之后会立即中断事务，或者在一定时间内没有收到协调者的请求，它也会中断事务。</li>
<li><strong>DoCommit阶段</strong>：这个阶段其实和 <code>2PC</code> 的第二阶段差不多，如果协调者收到了所有参与者在 <code>PreCommit</code> 阶段的 YES 响应，那么协调者将会给所有参与者发送 <code>DoCommit</code> 请求，<strong>参与者收到 <code>DoCommit</code> 请求后则会进行事务的提交工作</strong>，完成后则会给协调者返回响应，协调者收到所有参与者返回的事务提交成功的响应之后则完成事务。若协调者在 <code>PreCommit</code> 阶段 <strong>收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应</strong> ，那么就会进行中断请求的发送，参与者收到中断请求后则会 <strong>通过上面记录的回滚日志</strong> 来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d0b44361c746593f70a6e42c298b413a.png" alt="3PC流程"></p>
<blockquote>
<p>这里是 <code>3PC</code> 在成功的环境下的流程图，你可以看到 <code>3PC</code> 在很多地方进行了超时中断的处理，比如协调者在指定时间内为收到全部的确认消息则进行事务中断的处理，这样能 <strong>减少同步阻塞的时间</strong> 。还有需要注意的是，**<code>3PC</code> 在 <code>DoCommit</code> 阶段参与者如未收到协调者发送的提交事务的请求，它会在一定时间内进行事务的提交<strong>。为什么这么做呢？是因为这个时候我们肯定</strong>保证了在第一阶段所有的协调者全部返回了可以执行事务的响应<strong>，这个时候我们有理由</strong>相信其他系统都能进行事务的执行和提交<strong>，所以</strong>不管**协调者有没有发消息给参与者，进入第三阶段参与者都会进行事务的提交操作。</p>
</blockquote>
<p>总之，<code>3PC</code> 通过一系列的超时机制很好的缓解了阻塞问题，但是最重要的一致性并没有得到根本的解决，比如在 <code>PreCommit</code> 阶段，当一个参与者收到了请求之后其他参与者和协调者挂了或者出现了网络分区，这个时候收到消息的参与者都会进行事务提交，这就会出现数据不一致性问题。</p>
<p>所以，要解决一致性问题还需要靠 <code>Paxos</code> 算法⭐️ ⭐️ ⭐️ 。</p>
<h3 id="4-3-Paxos-算法"><a href="#4-3-Paxos-算法" class="headerlink" title="4.3. Paxos 算法"></a>4.3. <code>Paxos</code> 算法</h3><p><code>Paxos</code> 算法是基于<strong>消息传递且具有高度容错特性的一致性算法</strong>，是目前公认的解决分布式一致性问题最有效的算法之一，<strong>其解决的问题就是在分布式系统中如何就某个值（决议）达成一致</strong> 。</p>
<p>在 <code>Paxos</code> 中主要有三个角色，分别为 <code>Proposer提案者</code>、<code>Acceptor表决者</code>、<code>Learner学习者</code>。<code>Paxos</code> 算法和 <code>2PC</code> 一样，也有两个阶段，分别为 <code>Prepare</code> 和 <code>accept</code> 阶段。</p>
<h4 id="4-3-1-prepare-阶段"><a href="#4-3-1-prepare-阶段" class="headerlink" title="4.3.1. prepare 阶段"></a>4.3.1. prepare 阶段</h4><ul>
<li><code>Proposer提案者</code>：负责提出 <code>proposal</code>，每个提案者在提出提案时都会首先获取到一个 <strong>具有全局唯一性的、递增的提案编号N</strong>，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案，在<strong>第一阶段是只将提案编号发送给所有的表决者</strong>。</li>
<li><code>Acceptor表决者</code>：每个表决者在 <code>accept</code> 某提案后，会将该提案编号N记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个<strong>编号最大的提案</strong>，其编号假设为 <code>maxN</code>。每个表决者仅会 <code>accept</code> 编号大于自己本地 <code>maxN</code> 的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给 <code>Proposer</code> 。</li>
</ul>
<blockquote>
<p>下面是 <code>prepare</code> 阶段的流程图，你可以对照着参考一下。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/22e8d512d954676bdf0cc92d200af8ef.png" alt="paxos第一阶段"></p>
<h4 id="4-3-2-accept-阶段"><a href="#4-3-2-accept-阶段" class="headerlink" title="4.3.2. accept 阶段"></a>4.3.2. accept 阶段</h4><p>当一个提案被 <code>Proposer</code> 提出后，如果 <code>Proposer</code> 收到了超过半数的 <code>Acceptor</code> 的批准（<code>Proposer</code> 本身同意），那么此时 <code>Proposer</code> 会给所有的 <code>Acceptor</code> 发送真正的提案（你可以理解为第一阶段为试探），这个时候 <code>Proposer</code> 就会发送提案的内容和提案编号。</p>
<p>表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号 <strong>大于等于</strong> 已经批准过的最大提案编号，那么就 <code>accept</code> 该提案（此时执行提案内容但不提交），随后将情况返回给 <code>Proposer</code> 。如果不满足则不回应或者返回 NO 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b82536f956f70a584c6a20c10113f225.png" alt="paxos第二阶段1"></p>
<p>当 <code>Proposer</code> 收到超过半数的 <code>accept</code> ，那么它这个时候会向所有的 <code>acceptor</code> 发送提案的提交请求。需要注意的是，因为上述仅仅是超过半数的 <code>acceptor</code> 批准执行了该提案内容，其他没有批准的并没有执行该提案内容，所以这个时候需要<strong>向未批准的 <code>acceptor</code> 发送提案内容和提案编号并让它无条件执行和提交</strong>，而对于前面已经批准过该提案的 <code>acceptor</code> 来说 <strong>仅仅需要发送该提案的编号</strong> ，让 <code>acceptor</code> 执行提交就行了。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/743889b97485fdfe2094e5ef0af6b141.png" alt="paxos第二阶段2"></p>
<p>而如果 <code>Proposer</code> 如果没有收到超过半数的 <code>accept</code>  那么它将会将 <strong>递增</strong> 该 <code>Proposal</code> 的编号，然后 <strong>重新进入 <code>Prepare</code> 阶段</strong> 。</p>
<blockquote>
<p>对于 <code>Learner</code> 来说如何去学习 <code>Acceptor</code> 批准的提案内容，这有很多方式，读者可以自己去了解一下，这里不做过多解释。</p>
</blockquote>
<h4 id="4-3-3-paxos-算法的死循环问题"><a href="#4-3-3-paxos-算法的死循环问题" class="headerlink" title="4.3.3. paxos 算法的死循环问题"></a>4.3.3. <code>paxos</code> 算法的死循环问题</h4><p>其实就有点类似于两个人吵架，小明说我是对的，小红说我才是对的，两个人据理力争的谁也不让谁🤬🤬。</p>
<p>比如说，此时提案者 P1 提出一个方案 M1，完成了 <code>Prepare</code> 阶段的工作，这个时候 <code>acceptor</code> 则批准了 M1，但是此时提案者 P2 同时也提出了一个方案 M2，它也完成了 <code>Prepare</code> 阶段的工作。然后 P1 的方案已经不能在第二阶段被批准了（因为 <code>acceptor</code> 已经批准了比 M1 更大的 M2），所以 P1 自增方案变为 M3 重新进入 <code>Prepare</code> 阶段，然后 <code>acceptor</code> ，又批准了新的 M3 方案，它又不能批准 M2 了，这个时候 M2 又自增进入 <code>Prepare</code> 阶段。。。</p>
<p>就这样无休无止的永远提案下去，这就是 <code>paxos</code> 算法的死循环问题。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/72ccf65cdc107346ff2a1a881d296a2b.png"></p>
<p>那么如何解决呢？很简单，人多了容易吵架，我现在 <strong>就允许一个能提案</strong> 就行了。</p>
<h2 id="5-引出-ZAB"><a href="#5-引出-ZAB" class="headerlink" title="5. 引出 ZAB"></a>5. 引出 <code>ZAB</code></h2><h3 id="5-1-Zookeeper-架构"><a href="#5-1-Zookeeper-架构" class="headerlink" title="5.1. Zookeeper 架构"></a>5.1. <code>Zookeeper</code> 架构</h3><p>作为一个优秀高效且可靠的分布式协调框架，<code>ZooKeeper</code> 在解决分布式数据一致性问题时并没有直接使用 <code>Paxos</code> ，而是专门定制了一致性协议叫做 <code>ZAB(ZooKeeper Automic Broadcast)</code> 原子广播协议，该协议能够很好地支持 <strong>崩溃恢复</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0c38d08ea026e25bf3849cc7654a4e79.png" alt="Zookeeper架构"></p>
<h3 id="5-2-ZAB-中的三个角色"><a href="#5-2-ZAB-中的三个角色" class="headerlink" title="5.2. ZAB 中的三个角色"></a>5.2. <code>ZAB</code> 中的三个角色</h3><p>和介绍 <code>Paxos</code> 一样，在介绍 <code>ZAB</code> 协议之前，我们首先来了解一下在 <code>ZAB</code> 中三个主要的角色，<code>Leader 领导者</code>、<code>Follower跟随者</code>、<code>Observer观察者</code> 。</p>
<ul>
<li><code>Leader</code> ：集群中 <strong>唯一的写请求处理者</strong> ，能够发起投票（投票也是为了进行写请求）。</li>
<li><code>Follower</code>：能够接收客户端的请求，如果是读请求则可以自己处理，<strong>如果是写请求则要转发给 <code>Leader</code></strong> 。在选举过程中会参与投票，<strong>有选举权和被选举权</strong> 。</li>
<li><code>Observer</code> ：就是没有选举权和被选举权的 <code>Follower</code> 。</li>
</ul>
<p>在 <code>ZAB</code> 协议中对 <code>zkServer</code>(即上面我们说的三个角色的总称) 还有两种模式的定义，分别是 <strong>消息广播</strong> 和 <strong>崩溃恢复</strong> 。</p>
<h3 id="5-3-消息广播模式"><a href="#5-3-消息广播模式" class="headerlink" title="5.3. 消息广播模式"></a>5.3. 消息广播模式</h3><p>说白了就是 <code>ZAB</code> 协议是如何处理写请求的，上面我们不是说只有 <code>Leader</code> 能处理写请求嘛？那么我们的 <code>Follower</code> 和 <code>Observer</code> 是不是也需要 <strong>同步更新数据</strong> 呢？总不能数据只在 <code>Leader</code> 中更新了，其他角色都没有得到更新吧？</p>
<p>不就是 <strong>在整个集群中保持数据的一致性</strong> 嘛？如果是你，你会怎么做呢？</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e6064aea729dcc2d927d5d81c4797e74.png"></p>
<p>废话，第一步肯定需要 <code>Leader</code> 将写请求 <strong>广播</strong> 出去呀，让 <code>Leader</code> 问问 <code>Followers</code> 是否同意更新，如果超过半数以上的同意那么就进行 <code>Follower</code> 和 <code>Observer</code> 的更新（和 <code>Paxos</code> 一样）。当然这么说有点虚，画张图理解一下。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/08ccce48190fe4edcbcbb223d6231876.png" alt="消息广播"></p>
<p>嗯。。。看起来很简单，貌似懂了🤥🤥🤥。这两个 <code>Queue</code> 哪冒出来的？答案是 <strong><code>ZAB</code> 需要让 <code>Follower</code> 和 <code>Observer</code> 保证顺序性</strong> 。何为顺序性，比如我现在有一个写请求A，此时 <code>Leader</code> 将请求A广播出去，因为只需要半数同意就行，所以可能这个时候有一个 <code>Follower</code> F1因为网络原因没有收到，而 <code>Leader</code> 又广播了一个请求B，因为网络原因，F1竟然先收到了请求B然后才收到了请求A，这个时候请求处理的顺序不同就会导致数据的不同，从而 <strong>产生数据不一致问题</strong> 。</p>
<p>所以在 <code>Leader</code> 这端，它为每个其他的 <code>zkServer</code> 准备了一个 <strong>队列</strong> ，采用先进先出的方式发送消息。由于协议是 **通过 <code>TCP</code> **来进行网络通信的，保证了消息的发送顺序性，接受顺序性也得到了保证。</p>
<p>除此之外，在 <code>ZAB</code> 中还定义了一个 <strong>全局单调递增的事务ID <code>ZXID</code></strong> ，它是一个64位long型，其中高32位表示 <code>epoch</code> 年代，低32位表示事务id。<code>epoch</code> 是会根据 <code>Leader</code> 的变化而变化的，当一个 <code>Leader</code> 挂了，新的 <code>Leader</code> 上位的时候，年代（<code>epoch</code>）就变了。而低32位可以简单理解为递增的事务id。</p>
<p>定义这个的原因也是为了顺序性，每个 <code>proposal</code> 在 <code>Leader</code> 中生成后需要 <strong>通过其 <code>ZXID</code> 来进行排序</strong> ，才能得到处理。</p>
<h3 id="5-4-崩溃恢复模式"><a href="#5-4-崩溃恢复模式" class="headerlink" title="5.4. 崩溃恢复模式"></a>5.4. 崩溃恢复模式</h3><p>说到崩溃恢复我们首先要提到 <code>ZAB</code> 中的 <code>Leader</code> 选举算法，当系统出现崩溃影响最大应该是 <code>Leader</code> 的崩溃，因为我们只有一个 <code>Leader</code> ，所以当 <code>Leader</code> 出现问题的时候我们势必需要重新选举 <code>Leader</code> 。</p>
<p><code>Leader</code> 选举可以分为两个不同的阶段，第一个是我们提到的 <code>Leader</code> 宕机需要重新选举，第二则是当 <code>Zookeeper</code> 启动时需要进行系统的 <code>Leader</code> 初始化选举。下面我先来介绍一下 <code>ZAB</code> 是如何进行初始化选举的。</p>
<p>假设我们集群中有3台机器，那也就意味着我们需要两台以上同意（超过半数）。比如这个时候我们启动了 <code>server1</code> ，它会首先 <strong>投票给自己</strong> ，投票内容为服务器的 <code>myid</code> 和 <code>ZXID</code> ，因为初始化所以 <code>ZXID</code> 都为0，此时 <code>server1</code> 发出的投票为 (1,0)。但此时 <code>server1</code> 的投票仅为1，所以不能作为 <code>Leader</code> ，此时还在选举阶段所以整个集群处于 <strong><code>Looking</code> 状态</strong>。</p>
<p>接着 <code>server2</code> 启动了，它首先也会将投票选给自己(2,0)，并将投票信息广播出去（<code>server1</code>也会，只是它那时没有其他的服务器了），<code>server1</code> 在收到 <code>server2</code> 的投票信息后会将投票信息与自己的作比较。**首先它会比较 <code>ZXID</code> ，<code>ZXID</code> 大的优先为 <code>Leader</code>，如果相同则比较 <code>myid</code>，<code>myid</code> 大的优先作为 <code>Leader</code>**。所以此时<code>server1</code> 发现 <code>server2</code> 更适合做 <code>Leader</code>，它就会将自己的投票信息更改为(2,0)然后再广播出去，之后<code>server2</code>  收到之后发现和自己的一样无需做更改，并且自己的 <strong>投票已经超过半数</strong> ，则 **确定 <code>server2</code> 为 <code>Leader</code>**，<code>server1</code> 也会将自己服务器设置为 <code>Following</code> 变为 <code>Follower</code>。整个服务器就从 <code>Looking</code> 变为了正常状态。</p>
<p>当 <code>server3</code> 启动发现集群没有处于 <code>Looking</code> 状态时，它会直接以 <code>Follower</code> 的身份加入集群。</p>
<p>还是前面三个 <code>server</code> 的例子，如果在整个集群运行的过程中 <code>server2</code> 挂了，那么整个集群会如何重新选举 <code>Leader</code> 呢？其实和初始化选举差不多。</p>
<p>首先毫无疑问的是剩下的两个 <code>Follower</code> 会将自己的状态 <strong>从 <code>Following</code> 变为 <code>Looking</code> 状态</strong> ，然后每个 <code>server</code> 会向初始化投票一样首先给自己投票（这不过这里的 <code>zxid</code> 可能不是0了，这里为了方便随便取个数字）。</p>
<p>假设 <code>server1</code> 给自己投票为(1,99)，然后广播给其他 <code>server</code>，<code>server3</code> 首先也会给自己投票(3,95)，然后也广播给其他 <code>server</code>。<code>server1</code> 和 <code>server3</code> 此时会收到彼此的投票信息，和一开始选举一样，他们也会比较自己的投票和收到的投票（<code>zxid</code> 大的优先，如果相同那么就 <code>myid</code> 大的优先）。这个时候 <code>server1</code> 收到了 <code>server3</code> 的投票发现没自己的合适故不变，<code>server3</code> 收到 <code>server1</code> 的投票结果后发现比自己的合适于是更改投票为(1,99)然后广播出去，最后 <code>server1</code> 收到了发现自己的投票已经超过半数就把自己设为 <code>Leader</code>，<code>server3</code> 也随之变为 <code>Follower</code>。</p>
<blockquote>
<p>请注意 <code>ZooKeeper</code> 为什么要设置奇数个结点？比如这里我们是三个，挂了一个我们还能正常工作，挂了两个我们就不能正常工作了（已经没有超过半数的节点数了，所以无法进行投票等操作了）。而假设我们现在有四个，挂了一个也能工作，<strong>但是挂了两个也不能正常工作了</strong>，这是和三个一样的，而三个比四个还少一个，带来的效益是一样的，所以 <code>Zookeeper</code> 推荐奇数个 <code>server</code> 。</p>
</blockquote>
<p>那么说完了 <code>ZAB</code> 中的 <code>Leader</code> 选举方式之后我们再来了解一下 <strong>崩溃恢复</strong> 是什么玩意？</p>
<p>其实主要就是 <strong>当集群中有机器挂了，我们整个集群如何保证数据一致性？</strong></p>
<p>如果只是 <code>Follower</code> 挂了，而且挂的没超过半数的时候，因为我们一开始讲了在 <code>Leader</code> 中会维护队列，所以不用担心后面的数据没接收到导致数据不一致性。</p>
<p>如果 <code>Leader</code> 挂了那就麻烦了，我们肯定需要先暂停服务变为 <code>Looking</code> 状态然后进行 <code>Leader</code> 的重新选举（上面我讲过了），但这个就要分为两种情况了，分别是 <strong>确保已经被Leader提交的提案最终能够被所有的Follower提交</strong> 和 <strong>跳过那些已经被丢弃的提案</strong> 。</p>
<p>确保已经被Leader提交的提案最终能够被所有的Follower提交是什么意思呢？</p>
<p>假设 <code>Leader (server2)</code> 发送 <code>commit</code> 请求（忘了请看上面的消息广播模式），他发送给了 <code>server3</code>，然后要发给 <code>server1</code> 的时候突然挂了。这个时候重新选举的时候我们如果把 <code>server1</code> 作为 <code>Leader</code> 的话，那么肯定会产生数据不一致性，因为 <code>server3</code> 肯定会提交刚刚 <code>server2</code> 发送的 <code>commit</code> 请求的提案，而 <code>server1</code> 根本没收到所以会丢弃。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ffcb12c6fb2bad76ac7105696655e85c.png" alt="崩溃恢复"></p>
<p>那怎么解决呢？</p>
<p>聪明的同学肯定会质疑，<strong>这个时候 <code>server1</code> 已经不可能成为 <code>Leader</code> 了，因为 <code>server1</code> 和 <code>server3</code> 进行投票选举的时候会比较 <code>ZXID</code> ，而此时 <code>server3</code> 的 <code>ZXID</code> 肯定比 <code>server1</code> 的大了</strong>。(不理解可以看前面的选举算法)</p>
<p>那么跳过那些已经被丢弃的提案又是什么意思呢？</p>
<p>假设 <code>Leader (server2)</code> 此时同意了提案N1，自身提交了这个事务并且要发送给所有 <code>Follower</code> 要 <code>commit</code> 的请求，却在这个时候挂了，此时肯定要重新进行 <code>Leader</code> 的选举，比如说此时选 <code>server1</code> 为 <code>Leader</code> （这无所谓）。但是过了一会，这个 <strong>挂掉的 <code>Leader</code> 又重新恢复了</strong> ，此时它肯定会作为 <code>Follower</code> 的身份进入集群中，需要注意的是刚刚 <code>server2</code> 已经同意提交了提案N1，但其他 <code>server</code> 并没有收到它的 <code>commit</code> 信息，所以其他 <code>server</code> 不可能再提交这个提案N1了，这样就会出现数据不一致性问题了，所以 <strong>该提案N1最终需要被抛弃掉</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/abb6efc7d4df9c82b162cbecb129a6e3.png" alt="崩溃恢复"></p>
<h2 id="6-Zookeeper的几个理论知识"><a href="#6-Zookeeper的几个理论知识" class="headerlink" title="6. Zookeeper的几个理论知识"></a>6. Zookeeper的几个理论知识</h2><p>了解了 <code>ZAB</code> 协议还不够，它仅仅是 <code>Zookeeper</code> 内部实现的一种方式，而我们如何通过 <code>Zookeeper</code> 去做一些典型的应用场景呢？比如说集群管理，分布式锁，<code>Master</code> 选举等等。</p>
<p>这就涉及到如何使用 <code>Zookeeper</code> 了，但在使用之前我们还需要掌握几个概念。比如 <code>Zookeeper</code> 的 <strong>数据模型</strong> 、<strong>会话机制</strong>、<strong>ACL</strong>、<strong>Watcher机制</strong> 等等。</p>
<h3 id="6-1-数据模型"><a href="#6-1-数据模型" class="headerlink" title="6.1. 数据模型"></a>6.1. 数据模型</h3><p><code>zookeeper</code> 数据存储结构与标准的 <code>Unix</code> 文件系统非常相似，都是在根节点下挂很多子节点(树型)。但是 <code>zookeeper</code> 中没有文件系统中目录与文件的概念，而是 <strong>使用了 <code>znode</code> 作为数据节点</strong> 。<code>znode</code> 是 <code>zookeeper</code> 中的最小数据单元，每个 <code>znode</code> 上都可以保存数据，同时还可以挂载子节点，形成一个树形化命名空间。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8f35dba8c44c4a10d81e3395df971ce7.png" alt="zk数据模型"></p>
<p>每个 <code>znode</code> 都有自己所属的 <strong>节点类型</strong> 和 <strong>节点状态</strong>。</p>
<p>其中节点类型可以分为 <strong>持久节点</strong>、<strong>持久顺序节点</strong>、<strong>临时节点</strong> 和 <strong>临时顺序节点</strong>。</p>
<ul>
<li>持久节点：一旦创建就一直存在，直到将其删除。</li>
<li>持久顺序节点：一个父节点可以为其子节点 <strong>维护一个创建的先后顺序</strong> ，这个顺序体现在 <strong>节点名称</strong> 上，是节点名称后自动添加一个由 10 位数字组成的数字串，从 0 开始计数。</li>
<li>临时节点：临时节点的生命周期是与 <strong>客户端会话</strong> 绑定的，<strong>会话消失则节点消失</strong> 。临时节点 <strong>只能做叶子节点</strong> ，不能创建子节点。</li>
<li>临时顺序节点：父节点可以创建一个维持了顺序的临时节点(和前面的持久顺序性节点一样)。</li>
</ul>
<p>节点状态中包含了很多节点的属性比如 <code>czxid</code> 、<code>mzxid</code> 等等，在 <code>zookeeper</code> 中是使用 <code>Stat</code> 这个类来维护的。下面我列举一些属性解释。</p>
<ul>
<li><code>czxid</code>：<code>Created ZXID</code>，该数据节点被 <strong>创建</strong> 时的事务ID。</li>
<li><code>mzxid</code>：<code>Modified ZXID</code>，节点 <strong>最后一次被更新时</strong> 的事务ID。</li>
<li><code>ctime</code>：<code>Created Time</code>，该节点被创建的时间。</li>
<li><code>mtime</code>： <code>Modified Time</code>，该节点最后一次被修改的时间。</li>
<li><code>version</code>：节点的版本号。</li>
<li><code>cversion</code>：<strong>子节点</strong> 的版本号。</li>
<li><code>aversion</code>：节点的 <code>ACL</code> 版本号。</li>
<li><code>ephemeralOwner</code>：创建该节点的会话的 <code>sessionID</code> ，如果该节点为持久节点，该值为0。</li>
<li><code>dataLength</code>：节点数据内容的长度。</li>
<li><code>numChildre</code>：该节点的子节点个数，如果为临时节点为0。</li>
<li><code>pzxid</code>：该节点子节点列表最后一次被修改时的事务ID，注意是子节点的 <strong>列表</strong> ，不是内容。</li>
</ul>
<h3 id="6-2-会话"><a href="#6-2-会话" class="headerlink" title="6.2. 会话"></a>6.2. 会话</h3><p>我想这个对于后端开发的朋友肯定不陌生，不就是 <code>session</code> 吗？只不过 <code>zk</code> 客户端和服务端是通过 <strong><code>TCP</code> 长连接</strong> 维持的会话机制，其实对于会话来说你可以理解为 <strong>保持连接状态</strong> 。</p>
<p>在 <code>zookeeper</code> 中，会话还有对应的事件，比如 <code>CONNECTION_LOSS 连接丢失事件</code> 、<code>SESSION_MOVED 会话转移事件</code> 、<code>SESSION_EXPIRED 会话超时失效事件</code> 。</p>
<h3 id="6-3-ACL"><a href="#6-3-ACL" class="headerlink" title="6.3. ACL"></a>6.3. ACL</h3><p><code>ACL</code> 为 <code>Access Control Lists</code> ，它是一种权限控制。在 <code>zookeeper</code> 中定义了5种权限，它们分别为：</p>
<ul>
<li><code>CREATE</code> ：创建子节点的权限。</li>
<li><code>READ</code>：获取节点数据和子节点列表的权限。</li>
<li><code>WRITE</code>：更新节点数据的权限。</li>
<li><code>DELETE</code>：删除子节点的权限。</li>
<li><code>ADMIN</code>：设置节点 ACL 的权限。</li>
</ul>
<h3 id="6-4-Watcher机制"><a href="#6-4-Watcher机制" class="headerlink" title="6.4. Watcher机制"></a>6.4. Watcher机制</h3><p><code>Watcher</code> 为事件监听器，是 <code>zk</code> 非常重要的一个特性，很多功能都依赖于它，它有点类似于订阅的方式，即客户端向服务端 <strong>注册</strong> 指定的 <code>watcher</code> ，当服务端符合了 <code>watcher</code> 的某些事件或要求则会 <strong>向客户端发送事件通知</strong> ，客户端收到通知后找到自己定义的 <code>Watcher</code> 然后 <strong>执行相应的回调方法</strong> 。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/241ab8cc37571034fa984322b753c7ba.png" alt="watcher机制"></p>
<h2 id="7-Zookeeper的几个典型应用场景"><a href="#7-Zookeeper的几个典型应用场景" class="headerlink" title="7. Zookeeper的几个典型应用场景"></a>7. Zookeeper的几个典型应用场景</h2><p>前面说了这么多的理论知识，你可能听得一头雾水，这些玩意有啥用？能干啥事？别急，听我慢慢道来。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9c9bd2a892e23e0b7582370c50117d8c.png"></p>
<h3 id="7-1-选主"><a href="#7-1-选主" class="headerlink" title="7.1. 选主"></a>7.1. 选主</h3><p>还记得上面我们的所说的临时节点吗？因为 <code>Zookeeper</code> 的强一致性，能够很好地在保证 <strong>在高并发的情况下保证节点创建的全局唯一性</strong> (即无法重复创建同样的节点)。</p>
<p>利用这个特性，我们可以 <strong>让多个客户端创建一个指定的节点</strong> ，创建成功的就是 <code>master</code>。</p>
<p>但是，如果这个 <code>master</code> 挂了怎么办？？？</p>
<p>你想想为什么我们要创建临时节点？还记得临时节点的生命周期吗？<code>master</code> 挂了是不是代表会话断了？会话断了是不是意味着这个节点没了？还记得 <code>watcher</code> 吗？我们是不是可以 <strong>让其他不是 <code>master</code> 的节点监听节点的状态</strong> ，比如说我们监听这个临时节点的父节点，如果子节点个数变了就代表 <code>master</code> 挂了，这个时候我们 <strong>触发回调函数进行重新选举</strong> ，或者我们直接监听节点的状态，我们可以通过节点是否已经失去连接来判断 <code>master</code> 是否挂了等等。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a94707028c5581c815f72fba0f50f43a.png" alt="选主"></p>
<p>总的来说，我们可以完全 <strong>利用 临时节点、节点状态 和 <code>watcher</code> 来实现选主的功能</strong>，临时节点主要用来选举，节点状态和<code>watcher</code> 可以用来判断 <code>master</code> 的活性和进行重新选举。</p>
<h3 id="7-2-分布式锁"><a href="#7-2-分布式锁" class="headerlink" title="7.2. 分布式锁"></a>7.2. 分布式锁</h3><p>分布式锁的实现方式有很多种，比如 <code>Redis</code> 、数据库 、<code>zookeeper</code> 等。个人认为 <code>zookeeper</code> 在实现分布式锁这方面是非常非常简单的。</p>
<p>上面我们已经提到过了 <strong>zk在高并发的情况下保证节点创建的全局唯一性</strong>，这玩意一看就知道能干啥了。实现互斥锁呗，又因为能在分布式的情况下，所以能实现分布式锁呗。</p>
<p>如何实现呢？这玩意其实跟选主基本一样，我们也可以利用临时节点的创建来实现。</p>
<p>首先肯定是如何获取锁，因为创建节点的唯一性，我们可以让多个客户端同时创建一个临时节点，<strong>创建成功的就说明获取到了锁</strong> 。然后没有获取到锁的客户端也像上面选主的非主节点创建一个 <code>watcher</code> 进行节点状态的监听，如果这个互斥锁被释放了（可能获取锁的客户端宕机了，或者那个客户端主动释放了锁）可以调用回调函数重新获得锁。</p>
<blockquote>
<p><code>zk</code> 中不需要向 <code>redis</code> 那样考虑锁得不到释放的问题了，因为当客户端挂了，节点也挂了，锁也释放了。是不是很简答？                                               </p>
</blockquote>
<p>那能不能使用 <code>zookeeper</code> 同时实现 <strong>共享锁和独占锁</strong> 呢？答案是可以的，不过稍微有点复杂而已。</p>
<p>还记得 <strong>有序的节点</strong> 吗？</p>
<p>这个时候我规定所有创建节点必须有序，当你是读请求（要获取共享锁）的话，如果 <strong>没有比自己更小的节点，或比自己小的节点都是读请求</strong> ，则可以获取到读锁，然后就可以开始读了。<strong>若比自己小的节点中有写请求</strong> ，则当前客户端无法获取到读锁，只能等待前面的写请求完成。</p>
<p>如果你是写请求（获取独占锁），若 <strong>没有比自己更小的节点</strong> ，则表示当前客户端可以直接获取到写锁，对数据进行修改。若发现 <strong>有比自己更小的节点，无论是读操作还是写操作，当前客户端都无法获取到写锁</strong> ，等待所有前面的操作完成。</p>
<p>这就很好地同时实现了共享锁和独占锁，当然还有优化的地方，比如当一个锁得到释放它会通知所有等待的客户端从而造成 <strong>羊群效应</strong> 。此时你可以通过让等待的节点只监听他们前面的节点。</p>
<p>具体怎么做呢？其实也很简单，你可以让 <strong>读请求监听比自己小的最后一个写请求节点，写请求只监听比自己小的最后一个节点</strong> ，感兴趣的小伙伴可以自己去研究一下。                                                                                                                                                                                                                                                                                       </p>
<h3 id="7-3-命名服务"><a href="#7-3-命名服务" class="headerlink" title="7.3. 命名服务"></a>7.3. 命名服务</h3><p>如何给一个对象设置ID，大家可能都会想到 <code>UUID</code>，但是 <code>UUID</code> 最大的问题就在于它太长了。。。(太长不一定是好事，嘿嘿嘿)。那么在条件允许的情况下，我们能不能使用 <code>zookeeper</code> 来实现呢？</p>
<p>我们之前提到过 <code>zookeeper</code> 是通过 <strong>树形结构</strong> 来存储数据节点的，那也就是说，对于每个节点的 <strong>全路径</strong>，它必定是唯一的，我们可以使用节点的全路径作为命名方式了。而且更重要的是，路径是我们可以自己定义的，这对于我们对有些有语意的对象的ID设置可以更加便于理解。</p>
<h3 id="7-4-集群管理和注册中心"><a href="#7-4-集群管理和注册中心" class="headerlink" title="7.4. 集群管理和注册中心"></a>7.4. 集群管理和注册中心</h3><p>看到这里是不是觉得 <code>zookeeper</code> 实在是太强大了，它怎么能这么能干！</p>
<p>别急，它能干的事情还很多呢。可能我们会有这样的需求，我们需要了解整个集群中有多少机器在工作，我们想对集群中的每台机器的运行时状态进行数据采集，对集群中机器进行上下线操作等等。</p>
<p>而 <code>zookeeper</code> 天然支持的 <code>watcher</code> 和 临时节点能很好的实现这些需求。我们可以为每条机器创建临时节点，并监控其父节点，如果子节点列表有变动（我们可能创建删除了临时节点），那么我们可以使用在其父节点绑定的 <code>watcher</code> 进行状态监控和回调。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6115820219c35c68bcb2c9a855ebace3.png" alt="集群管理"></p>
<p>至于注册中心也很简单，我们同样也是让 <strong>服务提供者</strong> 在 <code>zookeeper</code> 中创建一个临时节点并且将自己的 <code>ip、port、调用方式</code> 写入节点，当 <strong>服务消费者</strong> 需要进行调用的时候会 <strong>通过注册中心找到相应的服务的地址列表(IP端口什么的)</strong> ，并缓存到本地(方便以后调用)，当消费者调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从地址列表中取一个服务提供者的服务器调用服务。</p>
<p>当服务提供者的某台服务器宕机或下线时，相应的地址会从服务提供者地址列表中移除。同时，注册中心会将新的服务地址列表发送给服务消费者的机器并缓存在消费者本机（当然你可以让消费者进行节点监听，我记得 <code>Eureka</code> 会先试错，然后再更新）。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0b5b3911a7c2dae23391d17c91416b29.png" alt="注册中心"></p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>看到这里的同学实在是太有耐心了👍👍👍，如果觉得我写得不错的话点个赞哈。</p>
<p>不知道大家是否还记得我讲了什么😒。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b0bde9f3979b8f19187e6c374ad98993.png"></p>
<p>这篇文章中我带大家入门了 <code>zookeeper</code> 这个强大的分布式协调框架。现在我们来简单梳理一下整篇文章的内容。</p>
<ul>
<li><p>分布式与集群的区别</p>
</li>
<li><p><code>2PC</code> 、<code>3PC</code> 以及 <code>paxos</code> 算法这些一致性框架的原理和实现。</p>
</li>
<li><p><code>zookeeper</code> 专门的一致性算法 <code>ZAB</code> 原子广播协议的内容（<code>Leader</code> 选举、崩溃恢复、消息广播）。</p>
</li>
<li><p><code>zookeeper</code> 中的一些基本概念，比如 <code>ACL</code>，数据节点，会话，<code>watcher</code>机制等等。</p>
</li>
<li><p><code>zookeeper</code> 的典型应用场景，比如选主，注册中心等等。</p>
<p>如果忘了可以回去看看再次理解一下，如果有疑问和建议欢迎提出🤝🤝🤝。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/distributed-system/zookeeper/zookeeper-plus/" data-id="cks75dy6g000u7kve2yh0fl1d" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/distributed-system/zookeeper/zookeeper-intro" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/distributed-system/zookeeper/zookeeper-intro/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.009Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

<ul>
<li><a href="#1-%E5%89%8D%E8%A8%80">1. 前言</a></li>
<li><a href="#2-zookeeper-%E4%BB%8B%E7%BB%8D">2. ZooKeeper 介绍</a><ul>
<li><a href="#21-zookeeper-%E7%94%B1%E6%9D%A5">2.1. ZooKeeper 由来</a></li>
<li><a href="#22-zookeeper-%E6%A6%82%E8%A7%88">2.2. ZooKeeper 概览</a></li>
<li><a href="#23-zookeeper-%E7%89%B9%E7%82%B9">2.3. ZooKeeper 特点</a></li>
<li><a href="#24-zookeeper-%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">2.4. ZooKeeper 典型应用场景</a></li>
<li><a href="#25-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%91%97%E5%90%8D%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%94%A8%E5%88%B0%E4%BA%86-zookeeper">2.5. 有哪些著名的开源项目用到了 ZooKeeper?</a></li>
</ul>
</li>
<li><a href="#3-zookeeper-%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E8%A7%A3%E8%AF%BB">3. ZooKeeper 重要概念解读</a><ul>
<li><a href="#31-data-model%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B">3.1. Data model（数据模型）</a></li>
<li><a href="#32-znode%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9">3.2. znode（数据节点）</a><ul>
<li><a href="#321-znode-4%E7%A7%8D%E7%B1%BB%E5%9E%8B">3.2.1. znode 4种类型</a></li>
<li><a href="#322-znode-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">3.2.2. znode 数据结构</a></li>
</ul>
</li>
<li><a href="#33-%E7%89%88%E6%9C%ACversion">3.3. 版本（version）</a></li>
<li><a href="#34-acl%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6">3.4. ACL（权限控制）</a></li>
<li><a href="#35-watcher%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8">3.5. Watcher（事件监听器）</a></li>
<li><a href="#36-%E4%BC%9A%E8%AF%9Dsession">3.6. 会话（Session）</a></li>
</ul>
</li>
<li><a href="#4-zookeeper-%E9%9B%86%E7%BE%A4">4. ZooKeeper 集群</a><ul>
<li><a href="#41-zookeeper-%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2">4.1. ZooKeeper 集群角色</a></li>
<li><a href="#42-zookeeper-%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81">4.2. ZooKeeper 集群中的服务器状态</a></li>
<li><a href="#43-zookeeper-%E9%9B%86%E7%BE%A4%E4%B8%BA%E5%95%A5%E6%9C%80%E5%A5%BD%E5%A5%87%E6%95%B0%E5%8F%B0">4.3. ZooKeeper 集群为啥最好奇数台？</a></li>
</ul>
</li>
<li><a href="#5-zab-%E5%8D%8F%E8%AE%AE%E5%92%8Cpaxos-%E7%AE%97%E6%B3%95">5. ZAB 协议和Paxos 算法</a><ul>
<li><a href="#51-zab-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D">5.1. ZAB 协议介绍</a></li>
<li><a href="#52-zab-%E5%8D%8F%E8%AE%AE%E4%B8%A4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E5%92%8C%E6%B6%88%E6%81%AF%E5%B9%BF%E6%92%AD">5.2. ZAB 协议两种基本的模式：崩溃恢复和消息广播</a></li>
</ul>
</li>
<li><a href="#6-%E6%80%BB%E7%BB%93">6. 总结</a></li>
<li><a href="#7-%E5%8F%82%E8%80%83">7. 参考</a></li>
</ul>
<!-- /code_chunk_output -->


<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>相信大家对 ZooKeeper 应该不算陌生。但是你真的了解 ZooKeeper 到底有啥用不？如果别人/面试官让你给他讲讲对于 ZooKeeper 的认识，你能回答到什么地步呢？</p>
<p>拿我自己来说吧！我本人曾经使用 Dubbo 来做分布式项目的时候，使用了 ZooKeeper 作为注册中心。为了保证分布式系统能够同步访问某个资源，我还使用 ZooKeeper 做过分布式锁。另外，我在学习 Kafka 的时候，知道 Kafka 很多功能的实现依赖了 ZooKeeper。</p>
<p>前几天，总结项目经验的时候，我突然问自己 ZooKeeper 到底是个什么东西？想了半天，脑海中只是简单的能浮现出几句话：</p>
<ol>
<li>ZooKeeper 可以被用作注册中心、分布式锁；</li>
<li>ZooKeeper 是 Hadoop 生态系统的一员；</li>
<li>构建 ZooKeeper 集群的时候，使用的服务器最好是奇数台。</li>
</ol>
<p>由此可见，我对于 ZooKeeper 的理解仅仅是停留在了表面。</p>
<p>所以，通过本文，希望带大家稍微详细的了解一下 ZooKeeper 。如果没有学过 ZooKeeper ，那么本文将会是你进入 ZooKeeper 大门的垫脚砖。如果你已经接触过 ZooKeeper ，那么本文将带你回顾一下 ZooKeeper 的一些基础概念。</p>
<p>另外，本文不光会涉及到 ZooKeeper 的一些概念，后面的文章会介绍到 ZooKeeper 常见命令的使用以及使用 Apache Curator 作为 ZooKeeper 的客户端。</p>
<p><em>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！</em></p>
<h2 id="2-ZooKeeper-介绍"><a href="#2-ZooKeeper-介绍" class="headerlink" title="2. ZooKeeper 介绍"></a>2. ZooKeeper 介绍</h2><h3 id="2-1-ZooKeeper-由来"><a href="#2-1-ZooKeeper-由来" class="headerlink" title="2.1. ZooKeeper 由来"></a>2.1. ZooKeeper 由来</h3><p>正式介绍 ZooKeeper 之前，我们先来看看 ZooKeeper 的由来，还挺有意思的。</p>
<p>下面这段内容摘自《从 Paxos 到 ZooKeeper 》第四章第一节，推荐大家阅读一下：</p>
<blockquote>
<p>ZooKeeper 最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。</p>
<p>关于“ZooKeeper”这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的 Pig 项目),雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 RaghuRamakrishnan 开玩笑地说：“在这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧一一一因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了，而 ZooKeeper 正好要用来进行分布式环境的协调一一于是，ZooKeeper 的名字也就由此诞生了。</p>
</blockquote>
<h3 id="2-2-ZooKeeper-概览"><a href="#2-2-ZooKeeper-概览" class="headerlink" title="2.2. ZooKeeper 概览"></a>2.2. ZooKeeper 概览</h3><p>ZooKeeper 是一个开源的<strong>分布式协调服务</strong>，它的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>
<blockquote>
<p><strong>原语：</strong> 操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程。具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。</p>
</blockquote>
<p><strong>ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</strong></p>
<p>另外，<strong>ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。</strong></p>
<h3 id="2-3-ZooKeeper-特点"><a href="#2-3-ZooKeeper-特点" class="headerlink" title="2.3. ZooKeeper 特点"></a>2.3. ZooKeeper 特点</h3><ul>
<li><strong>顺序一致性：</strong> 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>
<li><strong>原子性：</strong> 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>
<li><strong>单一系统映像 ：</strong> 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>
<li><strong>可靠性：</strong> 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。</li>
</ul>
<h3 id="2-4-ZooKeeper-典型应用场景"><a href="#2-4-ZooKeeper-典型应用场景" class="headerlink" title="2.4. ZooKeeper 典型应用场景"></a>2.4. ZooKeeper 典型应用场景</h3><p>ZooKeeper 概览中，我们介绍到使用其通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>
<p>下面选 3 个典型的应用场景来专门说说：</p>
<ol>
<li><strong>分布式锁</strong> ： 通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。</li>
<li><strong>命名服务</strong> ：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID</li>
<li><strong>数据发布/订阅</strong> ：通过 <strong>Watcher 机制</strong> 可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。</li>
</ol>
<p>实际上，这些功能的实现基本都得益于 ZooKeeper 可以保存数据的功能，但是 ZooKeeper 不适合保存大量数据，这一点需要注意。</p>
<h3 id="2-5-有哪些著名的开源项目用到了-ZooKeeper"><a href="#2-5-有哪些著名的开源项目用到了-ZooKeeper" class="headerlink" title="2.5. 有哪些著名的开源项目用到了 ZooKeeper?"></a>2.5. 有哪些著名的开源项目用到了 ZooKeeper?</h3><ol>
<li><strong>Kafka</strong> : ZooKeeper 主要为 Kafka 提供 Broker 和 Topic 的注册以及多个 Partition 的负载均衡等功能。</li>
<li><strong>Hbase</strong> : ZooKeeper 为 Hbase 提供确保整个集群只有一个 Master 以及保存和提供 regionserver 状态信息（是否在线）等功能。</li>
<li><strong>Hadoop</strong> : ZooKeeper 为 Namenode 提供高可用支持。</li>
</ol>
<h2 id="3-ZooKeeper-重要概念解读"><a href="#3-ZooKeeper-重要概念解读" class="headerlink" title="3. ZooKeeper 重要概念解读"></a>3. ZooKeeper 重要概念解读</h2><p><em>破音：拿出小本本，下面的内容非常重要哦！</em></p>
<h3 id="3-1-Data-model（数据模型）"><a href="#3-1-Data-model（数据模型）" class="headerlink" title="3.1. Data model（数据模型）"></a>3.1. Data model（数据模型）</h3><p>ZooKeeper 数据模型采用层次化的多叉树形结构，每个节点上都可以存储数据，这些数据可以是数字、字符串或者是二级制序列。并且。每个节点还可以拥有 N 个子节点，最上层是根节点以“/”来代表。每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。并且，每个 znode 都一个唯一的路径标识。</p>
<p>强调一句：<strong>ZooKeeper 主要是用来协调服务的，而不是用来存储业务数据的，所以不要放比较大的数据在 znode 上，ZooKeeper 给出的上限是每个结点的数据大小最大是 1M。</strong></p>
<p>从下图可以更直观地看出：ZooKeeper 节点路径标识方式和 Unix 文件系统路径非常相似，都是由一系列使用斜杠”/“进行分割的路径表示，开发人员可以向这个节点中写入数据，也可以在节点下面创建子节点。这些操作我们后面都会介绍到。</p>
<p><img src="images/znode-structure.png" alt="ZooKeeper 数据模型"></p>
<h3 id="3-2-znode（数据节点）"><a href="#3-2-znode（数据节点）" class="headerlink" title="3.2. znode（数据节点）"></a>3.2. znode（数据节点）</h3><p>介绍了 ZooKeeper 树形数据模型之后，我们知道每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。你要存放的数据就放在上面，是你使用 ZooKeeper 过程中经常需要接触到的一个概念。</p>
<h4 id="3-2-1-znode-4种类型"><a href="#3-2-1-znode-4种类型" class="headerlink" title="3.2.1. znode 4种类型"></a>3.2.1. znode 4种类型</h4><p>我们通常是将 znode 分为 4 大类：</p>
<ul>
<li><strong>持久（PERSISTENT）节点</strong> ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li>
<li><strong>临时（EPHEMERAL）节点</strong> ：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，<strong>临时节点只能做叶子节点</strong> ，不能创建子节点。</li>
<li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong> ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code> 、<code>/node1/app0000000002</code> 。</li>
<li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong> ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li>
</ul>
<h4 id="3-2-2-znode-数据结构"><a href="#3-2-2-znode-数据结构" class="headerlink" title="3.2.2. znode 数据结构"></a>3.2.2. znode 数据结构</h4><p>每个 znode 由 2 部分组成:</p>
<ul>
<li><strong>stat</strong> ：状态信息</li>
<li><strong>data</strong> ： 节点存放的数据的具体内容</li>
</ul>
<p>如下所示，我通过 get 命令来获取 根目录下的 dubbo 节点的内容。（get 命令在下面会介绍到）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 6] get /dubbo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 该数据节点关联的数据内容为空</span></span><br><span class="line">null</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下面是该数据节点的一些状态信息，其实就是 Stat 对象的格式化输出</span></span><br><span class="line">cZxid = 0x2</span><br><span class="line">ctime = Tue Nov 27 11:05:34 CST 2018</span><br><span class="line">mZxid = 0x2</span><br><span class="line">mtime = Tue Nov 27 11:05:34 CST 2018</span><br><span class="line">pZxid = 0x3</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 0</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure>

<p>Stat 类中包含了一个数据节点的所有状态信息的字段，包括事务 ID-cZxid、节点创建时间-ctime 和子节点个数-numChildren 等等。</p>
<p>下面我们来看一下每个 znode 状态信息究竟代表的是什么吧！（下面的内容来源于《从 Paxos 到 ZooKeeper 分布式一致性原理与实践》，因为 Guide 确实也不是特别清楚，要学会参考资料的嘛！ ） ：</p>
<table>
<thead>
<tr>
<th>znode 状态信息</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>cZxid</td>
<td>create ZXID，即该数据节点被创建时的事务 id</td>
</tr>
<tr>
<td>ctime</td>
<td>create time，即该节点的创建时间</td>
</tr>
<tr>
<td>mZxid</td>
<td>modified ZXID，即该节点最终一次更新时的事务 id</td>
</tr>
<tr>
<td>mtime</td>
<td>modified time，即该节点最后一次的更新时间</td>
</tr>
<tr>
<td>pZxid</td>
<td>该节点的子节点列表最后一次修改时的事务 id，只有子节点列表变更才会更新 pZxid，子节点内容变更不会更新</td>
</tr>
<tr>
<td>cversion</td>
<td>子节点版本号，当前节点的子节点每次变化时值增加 1</td>
</tr>
<tr>
<td>dataVersion</td>
<td>数据节点内容版本号，节点创建时为 0，每更新一次节点内容(不管内容有无变化)该版本号的值增加 1</td>
</tr>
<tr>
<td>aclVersion</td>
<td>节点的 ACL 版本号，表示该节点 ACL 信息变更次数</td>
</tr>
<tr>
<td>ephemeralOwner</td>
<td>创建该临时节点的会话的 sessionId；如果当前节点为持久节点，则 ephemeralOwner=0</td>
</tr>
<tr>
<td>dataLength</td>
<td>数据节点内容长度</td>
</tr>
<tr>
<td>numChildren</td>
<td>当前节点的子节点个数</td>
</tr>
</tbody></table>
<h3 id="3-3-版本（version）"><a href="#3-3-版本（version）" class="headerlink" title="3.3. 版本（version）"></a>3.3. 版本（version）</h3><p>在前面我们已经提到，对应于每个 znode，ZooKeeper 都会为其维护一个叫作 <strong>Stat</strong> 的数据结构，Stat 中记录了这个 znode 的三个相关的版本：</p>
<ul>
<li><strong>dataVersion</strong> ：当前 znode 节点的版本号</li>
<li><strong>cversion</strong> ： 当前 znode 子节点的版本</li>
<li><strong>aclVersion</strong> ： 当前 znode 的 ACL 的版本。</li>
</ul>
<h3 id="3-4-ACL（权限控制）"><a href="#3-4-ACL（权限控制）" class="headerlink" title="3.4. ACL（权限控制）"></a>3.4. ACL（权限控制）</h3><p>ZooKeeper 采用 ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。</p>
<p>对于 znode 操作的权限，ZooKeeper 提供了以下 5 种：</p>
<ul>
<li><strong>CREATE</strong> : 能创建子节点</li>
<li><strong>READ</strong> ：能获取节点数据和列出其子节点</li>
<li><strong>WRITE</strong> : 能设置/更新节点数据</li>
<li><strong>DELETE</strong> : 能删除子节点</li>
<li><strong>ADMIN</strong> : 能设置节点 ACL 的权限</li>
</ul>
<p>其中尤其需要注意的是，<strong>CREATE</strong> 和 <strong>DELETE</strong> 这两种权限都是针对 <strong>子节点</strong> 的权限控制。</p>
<p>对于身份认证，提供了以下几种方式：</p>
<ul>
<li><strong>world</strong> ： 默认方式，所有用户都可无条件访问。</li>
<li><strong>auth</strong> :不使用任何 id，代表任何已认证的用户。</li>
<li><strong>digest</strong> :用户名:密码认证方式： <em>username:password</em> 。</li>
<li><strong>ip</strong> : 对指定 ip 进行限制。</li>
</ul>
<h3 id="3-5-Watcher（事件监听器）"><a href="#3-5-Watcher（事件监听器）" class="headerlink" title="3.5. Watcher（事件监听器）"></a>3.5. Watcher（事件监听器）</h3><p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p>
<p><img src="images/watche%E6%9C%BA%E5%88%B6.png" alt="watcher机制"></p>
<p><em>破音：非常有用的一个特性，都能出小本本记好了，后面用到 ZooKeeper 基本离不开 Watcher（事件监听器）机制。</em></p>
<h3 id="3-6-会话（Session）"><a href="#3-6-会话（Session）" class="headerlink" title="3.6. 会话（Session）"></a>3.6. 会话（Session）</h3><p>Session 可以看作是 ZooKeeper 服务器与客户端的之间的一个 TCP 长连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watcher 事件通知。</p>
<p>Session 有一个属性叫做：<code>sessionTimeout</code> ，<code>sessionTimeout</code> 代表会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在<code>sessionTimeout</code>规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p>
<p>另外，在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 <code>sessionID</code>。由于 <code>sessionID</code>是 ZooKeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 <code>sessionID</code> 的，因此，无论是哪台服务器为客户端分配的 <code>sessionID</code>，都务必保证全局唯一。</p>
<h2 id="4-ZooKeeper-集群"><a href="#4-ZooKeeper-集群" class="headerlink" title="4. ZooKeeper 集群"></a>4. ZooKeeper 集群</h2><p>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。通常 3 台服务器就可以构成一个 ZooKeeper 集群了。ZooKeeper 官方提供的架构图就是一个 ZooKeeper 集群整体对外提供服务。</p>
<p><img src="images/zookeeper%E9%9B%86%E7%BE%A4.png"></p>
<p>上图中每一个 Server 代表一个安装 ZooKeeper 服务的服务器。组成 ZooKeeper 服务的服务器都会在内存中维护当前的服务器状态，并且每台服务器之间都互相保持着通信。集群间通过 ZAB 协议（ZooKeeper Atomic Broadcast）来保持数据的一致性。</p>
<p><strong>最典型集群模式： Master/Slave 模式（主备模式）</strong>。在这种模式中，通常 Master 服务器作为主服务器提供写服务，其他的 Slave 服务器从服务器通过异步复制的方式获取 Master 服务器最新的数据提供读服务。</p>
<h3 id="4-1-ZooKeeper-集群角色"><a href="#4-1-ZooKeeper-集群角色" class="headerlink" title="4.1. ZooKeeper 集群角色"></a>4.1. ZooKeeper 集群角色</h3><p>但是，在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了 Leader、Follower 和 Observer 三种角色。如下图所示</p>
<p><img src="images/zookeeper%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2.png"></p>
<p>ZooKeeper 集群中的所有机器通过一个 <strong>Leader 选举过程</strong> 来选定一台称为 “<strong>Leader</strong>” 的机器，Leader 既可以为客户端提供写服务又能提供读服务。除了 Leader 外，<strong>Follower</strong> 和 <strong>Observer</strong> 都只能提供读服务。Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能。</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Leader</td>
<td>为客户端提供读和写的服务，负责投票的发起和决议，更新系统状态。</td>
</tr>
<tr>
<td>Follower</td>
<td>为客户端提供读服务，如果是写服务则转发给 Leader。在选举过程中参与投票。</td>
</tr>
<tr>
<td>Observer</td>
<td>为客户端提供读服务器，如果是写服务则转发给 Leader。不参与选举过程中的投票，也不参与“过半写成功”策略。在不影响写性能的情况下提升集群的读性能。此角色于 ZooKeeper3.3 系列新增的角色。</td>
</tr>
</tbody></table>
<p>当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，就会进入 Leader 选举过程，这个过程会选举产生新的 Leader 服务器。</p>
<p>这个过程大致是这样的：</p>
<ol>
<li><strong>Leader election（选举阶段）</strong>：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。</li>
<li><strong>Discovery（发现阶段）</strong> ：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。</li>
<li><strong>Synchronization（同步阶段）</strong> :同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后<br>准 leader 才会成为真正的 leader。</li>
<li><strong>Broadcast（广播阶段）</strong> :到了这个阶段，ZooKeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li>
</ol>
<h3 id="4-2-ZooKeeper-集群中的服务器状态"><a href="#4-2-ZooKeeper-集群中的服务器状态" class="headerlink" title="4.2. ZooKeeper 集群中的服务器状态"></a>4.2. ZooKeeper 集群中的服务器状态</h3><ul>
<li><strong>LOOKING</strong> ：寻找 Leader。</li>
<li><strong>LEADING</strong> ：Leader 状态，对应的节点为 Leader。</li>
<li><strong>FOLLOWING</strong> ：Follower 状态，对应的节点为 Follower。</li>
<li><strong>OBSERVING</strong> ：Observer 状态，对应节点为 Observer，该节点不参与 Leader 选举。</li>
</ul>
<h3 id="4-3-ZooKeeper-集群为啥最好奇数台？"><a href="#4-3-ZooKeeper-集群为啥最好奇数台？" class="headerlink" title="4.3. ZooKeeper 集群为啥最好奇数台？"></a>4.3. ZooKeeper 集群为啥最好奇数台？</h3><p>ZooKeeper 集群在宕掉几个 ZooKeeper 服务器之后，如果剩下的 ZooKeeper 服务器个数大于宕掉的个数的话整个 ZooKeeper 才依然可用。假如我们的集群中有 n 台 ZooKeeper 服务器，那么也就是剩下的服务数必须大于 n/2。先说一下结论，2n 和 2n-1 的容忍度是一样的，都是 n-1，大家可以先自己仔细想一想，这应该是一个很简单的数学问题了。<br>比如假如我们有 3 台，那么最大允许宕掉 1 台 ZooKeeper 服务器，如果我们有 4 台的的时候也同样只允许宕掉 1 台。<br>假如我们有 5 台，那么最大允许宕掉 2 台 ZooKeeper 服务器，如果我们有 6 台的的时候也同样只允许宕掉 2 台。</p>
<p>综上，何必增加那一个不必要的 ZooKeeper 呢？</p>
<h2 id="5-ZAB-协议和Paxos-算法"><a href="#5-ZAB-协议和Paxos-算法" class="headerlink" title="5. ZAB 协议和Paxos 算法"></a>5. ZAB 协议和Paxos 算法</h2><p>Paxos 算法应该可以说是  ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在ZooKeeper的官方文档中也指出，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</p>
<h3 id="5-1-ZAB-协议介绍"><a href="#5-1-ZAB-协议介绍" class="headerlink" title="5.1. ZAB 协议介绍"></a>5.1. ZAB 协议介绍</h3><p>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p>
<h3 id="5-2-ZAB-协议两种基本的模式：崩溃恢复和消息广播"><a href="#5-2-ZAB-协议两种基本的模式：崩溃恢复和消息广播" class="headerlink" title="5.2. ZAB 协议两种基本的模式：崩溃恢复和消息广播"></a>5.2. ZAB 协议两种基本的模式：崩溃恢复和消息广播</h3><p>ZAB 协议包括两种基本的模式，分别是 </p>
<ul>
<li><strong>崩溃恢复</strong>  ：当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的Leader服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，<strong>所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致</strong>。</li>
<li><strong>消息广播</strong> ：<strong>当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进入消息广播模式了。</strong> 当一台同样遵守ZAB协议的服务器启动后加入到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加入的服务器就会自觉地进入数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</li>
</ul>
<p>关于 <strong>ZAB 协议&amp;Paxos算法</strong> 需要讲和理解的东西太多了，具体可以看下面这两篇文章：</p>
<ul>
<li> <a target="_blank" rel="noopener" href="http://codemacro.com/2014/10/15/explain-poxos/">图解 Paxos 一致性协议</a></li>
<li> <a target="_blank" rel="noopener" href="https://dbaplus.cn/news-141-1875-1.html">Zookeeper ZAB 协议分析</a></li>
</ul>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><ol>
<li>ZooKeeper 本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper 就能正常服务）。</li>
<li>为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。</li>
<li>ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持 znode 中存储的数据量较小的进一步原因）。</li>
<li>ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地明显，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）</li>
<li>ZooKeeper 有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个 znode 被创建了，除非主动进行 znode 的移除操作，否则这个 znode 将一直保存在 ZooKeeper 上。</li>
<li>ZooKeeper 底层其实只提供了两个功能：① 管理（存储、读取）用户程序提交的数据；② 为用户程序提供数据节点监听服务。</li>
</ol>
<h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><ol>
<li>《从 Paxos 到 ZooKeeper 分布式一致性原理与实践》</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/distributed-system/zookeeper/zookeeper-intro/" data-id="cks75dy6a000n7kve1z6vb39h" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/distributed-system/zookeeper/zookeeper-in-action" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/distributed-system/zookeeper/zookeeper-in-action/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:47.006Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

<ul>
<li><a href="#1-%E5%89%8D%E8%A8%80">1. 前言</a></li>
<li><a href="#2-zookeeper-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8">2. ZooKeeper 安装和使用</a><ul>
<li><a href="#21-%E4%BD%BF%E7%94%A8docker-%E5%AE%89%E8%A3%85-zookeeper">2.1. 使用Docker 安装 zookeeper</a></li>
<li><a href="#22-%E8%BF%9E%E6%8E%A5-zookeeper-%E6%9C%8D%E5%8A%A1">2.2. 连接 ZooKeeper 服务</a></li>
<li><a href="#23-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%BC%94%E7%A4%BA">2.3. 常用命令演示</a><ul>
<li><a href="#231-%E6%9F%A5%E7%9C%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4help-%E5%91%BD%E4%BB%A4">2.3.1. 查看常用命令(help 命令)</a></li>
<li><a href="#232-%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9create-%E5%91%BD%E4%BB%A4">2.3.2. 创建节点(create 命令)</a></li>
<li><a href="#233-%E6%9B%B4%E6%96%B0%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E5%86%85%E5%AE%B9set-%E5%91%BD%E4%BB%A4">2.3.3. 更新节点数据内容(set 命令)</a></li>
<li><a href="#234-%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AEget-%E5%91%BD%E4%BB%A4">2.3.4. 获取节点的数据(get 命令)</a></li>
<li><a href="#235-%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%AD%90%E8%8A%82%E7%82%B9ls-%E5%91%BD%E4%BB%A4">2.3.5. 查看某个目录下的子节点(ls 命令)</a></li>
<li><a href="#236-%E6%9F%A5%E7%9C%8B%E8%8A%82%E7%82%B9%E7%8A%B6%E6%80%81stat-%E5%91%BD%E4%BB%A4">2.3.6. 查看节点状态(stat 命令)</a></li>
<li><a href="#237-%E6%9F%A5%E7%9C%8B%E8%8A%82%E7%82%B9%E4%BF%A1%E6%81%AF%E5%92%8C%E7%8A%B6%E6%80%81ls2-%E5%91%BD%E4%BB%A4">2.3.7. 查看节点信息和状态(ls2 命令)</a></li>
<li><a href="#238-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9delete-%E5%91%BD%E4%BB%A4">2.3.8. 删除节点(delete 命令)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-zookeeper-java%E5%AE%A2%E6%88%B7%E7%AB%AF-curator%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">3. ZooKeeper Java客户端 Curator简单使用</a><ul>
<li><a href="#31-%E8%BF%9E%E6%8E%A5-zookeeper-%E5%AE%A2%E6%88%B7%E7%AB%AF">3.1. 连接 ZooKeeper 客户端</a></li>
<li><a href="#32-%E6%95%B0%E6%8D%AE%E8%8A%82%E7%82%B9%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5">3.2. 数据节点的增删改查</a><ul>
<li><a href="#321-%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9">3.2.1. 创建节点</a></li>
<li><a href="#322-%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9">3.2.2. 删除节点</a></li>
<li><a href="#323-%E8%8E%B7%E5%8F%96%E6%9B%B4%E6%96%B0%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E5%86%85%E5%AE%B9">3.2.3. 获取/更新节点数据内容</a></li>
<li><a href="#324-%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%90%E8%8A%82%E7%82%B9%E8%B7%AF%E5%BE%84">3.2.4. 获取某个节点的所有子节点路径</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->


<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>这篇文章简单给演示一下 ZooKeeper 常见命令的使用以及 ZooKeeper Java客户端 Curator 的基本使用。介绍到的内容都是最基本的操作，能满足日常工作的基本需要。</p>
<p>如果文章有任何需要改善和完善的地方，欢迎在评论区指出，共同进步！</p>
<h2 id="2-ZooKeeper-安装和使用"><a href="#2-ZooKeeper-安装和使用" class="headerlink" title="2. ZooKeeper 安装和使用"></a>2. ZooKeeper 安装和使用</h2><h3 id="2-1-使用Docker-安装-zookeeper"><a href="#2-1-使用Docker-安装-zookeeper" class="headerlink" title="2.1. 使用Docker 安装 zookeeper"></a>2.1. 使用Docker 安装 zookeeper</h3><p><strong>a.使用 Docker 下载 ZooKeeper</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull zookeeper:3.5.8</span><br></pre></td></tr></table></figure>

<p><strong>b.运行 ZooKeeper</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name zookeeper -p 2181:2181 zookeeper:3.5.8</span><br></pre></td></tr></table></figure>

<h3 id="2-2-连接-ZooKeeper-服务"><a href="#2-2-连接-ZooKeeper-服务" class="headerlink" title="2.2. 连接 ZooKeeper 服务"></a>2.2. 连接 ZooKeeper 服务</h3><p><strong>a.进入ZooKeeper容器中</strong></p>
<p>先使用 <code>docker ps</code> 查看 ZooKeeper 的 ContainerID，然后使用 <code>docker exec -it ContainerID /bin/bash</code> 命令进入容器中。</p>
<p><strong>b.先进入 bin 目录,然后通过  <code>./zkCli.sh -server 127.0.0.1:2181</code>命令连接ZooKeeper 服务</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@eaf70fc620cb:/apache-zookeeper-3.5.8-bin<span class="comment"># cd bin</span></span><br></pre></td></tr></table></figure>

<p>如果你看到控制台成功打印出如下信息的话，说明你已经成功连接 ZooKeeper 服务。</p>
<p><img src="images/%E8%BF%9E%E6%8E%A5ZooKeeper%E6%9C%8D%E5%8A%A1.png"></p>
<h3 id="2-3-常用命令演示"><a href="#2-3-常用命令演示" class="headerlink" title="2.3. 常用命令演示"></a>2.3. 常用命令演示</h3><h4 id="2-3-1-查看常用命令-help-命令"><a href="#2-3-1-查看常用命令-help-命令" class="headerlink" title="2.3.1. 查看常用命令(help 命令)"></a>2.3.1. 查看常用命令(help 命令)</h4><p>通过 <code>help</code> 命令查看 ZooKeeper 常用命令</p>
<h4 id="2-3-2-创建节点-create-命令"><a href="#2-3-2-创建节点-create-命令" class="headerlink" title="2.3.2. 创建节点(create 命令)"></a>2.3.2. 创建节点(create 命令)</h4><p>通过 <code>create</code> 命令在根目录创建了 node1 节点，与它关联的字符串是”node1”</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 34] create /node1 “node1”</span><br></pre></td></tr></table></figure>

<p>通过 <code>create</code> 命令在根目录创建了 node1 节点，与它关联的内容是数字 123</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 1] create /node1/node1.1 123</span><br><span class="line">Created /node1/node1.1</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-更新节点数据内容-set-命令"><a href="#2-3-3-更新节点数据内容-set-命令" class="headerlink" title="2.3.3. 更新节点数据内容(set 命令)"></a>2.3.3. 更新节点数据内容(set 命令)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 11] set /node1 &quot;set node1&quot;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4-获取节点的数据-get-命令"><a href="#2-3-4-获取节点的数据-get-命令" class="headerlink" title="2.3.4. 获取节点的数据(get 命令)"></a>2.3.4. 获取节点的数据(get 命令)</h4><p><code>get</code> 命令可以获取指定节点的数据内容和节点的状态,可以看出我们通过 <code>set</code> 命令已经将节点数据内容改为 “set node1”。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set node1</span><br><span class="line">cZxid = 0x47</span><br><span class="line">ctime = Sun Jan 20 10:22:59 CST 2019</span><br><span class="line">mZxid = 0x4b</span><br><span class="line">mtime = Sun Jan 20 10:41:10 CST 2019</span><br><span class="line">pZxid = 0x4a</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 1</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 9</span><br><span class="line">numChildren = 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-3-5-查看某个目录下的子节点-ls-命令"><a href="#2-3-5-查看某个目录下的子节点-ls-命令" class="headerlink" title="2.3.5. 查看某个目录下的子节点(ls 命令)"></a>2.3.5. 查看某个目录下的子节点(ls 命令)</h4><p>通过 <code>ls</code> 命令查看根目录下的节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 37] ls /</span><br><span class="line">[dubbo, ZooKeeper, node1]</span><br></pre></td></tr></table></figure>

<p>通过 <code>ls</code> 命令查看 node1 目录下的节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 5] ls /node1</span><br><span class="line">[node1.1]</span><br></pre></td></tr></table></figure>

<p>ZooKeeper 中的 ls 命令和 linux 命令中的 ls 类似， 这个命令将列出绝对路径 path 下的所有子节点信息（列出 1 级，并不递归）</p>
<h4 id="2-3-6-查看节点状态-stat-命令"><a href="#2-3-6-查看节点状态-stat-命令" class="headerlink" title="2.3.6. 查看节点状态(stat 命令)"></a>2.3.6. 查看节点状态(stat 命令)</h4><p>通过 <code>stat</code> 命令查看节点状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 10] stat /node1</span><br><span class="line">cZxid = 0x47</span><br><span class="line">ctime = Sun Jan 20 10:22:59 CST 2019</span><br><span class="line">mZxid = 0x47</span><br><span class="line">mtime = Sun Jan 20 10:22:59 CST 2019</span><br><span class="line">pZxid = 0x4a</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 11</span><br><span class="line">numChildren = 1</span><br></pre></td></tr></table></figure>

<p>上面显示的一些信息比如 cversion、aclVersion、numChildren 等等，我在上面 “znode(数据节点)的结构” 这部分已经介绍到。</p>
<h4 id="2-3-7-查看节点信息和状态-ls2-命令"><a href="#2-3-7-查看节点信息和状态-ls2-命令" class="headerlink" title="2.3.7. 查看节点信息和状态(ls2 命令)"></a>2.3.7. 查看节点信息和状态(ls2 命令)</h4><p><code>ls2</code> 命令更像是  <code>ls</code> 命令和 <code>stat</code> 命令的结合。 <code>ls2</code> 命令返回的信息包括 2 部分：</p>
<ol>
<li>子节点列表 </li>
<li>当前节点的 stat 信息。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 7] ls2 /node1</span><br><span class="line">[node1.1]</span><br><span class="line">cZxid = 0x47</span><br><span class="line">ctime = Sun Jan 20 10:22:59 CST 2019</span><br><span class="line">mZxid = 0x47</span><br><span class="line">mtime = Sun Jan 20 10:22:59 CST 2019</span><br><span class="line">pZxid = 0x4a</span><br><span class="line">cversion = 1</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 0</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 11</span><br><span class="line">numChildren = 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-3-8-删除节点-delete-命令"><a href="#2-3-8-删除节点-delete-命令" class="headerlink" title="2.3.8. 删除节点(delete 命令)"></a>2.3.8. 删除节点(delete 命令)</h4><p>这个命令很简单，但是需要注意的一点是如果你要删除某一个节点，那么这个节点必须无子节点才行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[zk: 127.0.0.1:2181(CONNECTED) 3] delete /node1/node1.1</span><br></pre></td></tr></table></figure>

<p>在后面我会介绍到 Java 客户端 API 的使用以及开源 ZooKeeper 客户端 ZkClient 和 Curator 的使用。</p>
<h2 id="3-ZooKeeper-Java客户端-Curator简单使用"><a href="#3-ZooKeeper-Java客户端-Curator简单使用" class="headerlink" title="3. ZooKeeper Java客户端 Curator简单使用"></a>3. ZooKeeper Java客户端 Curator简单使用</h2><p>Curator 是Netflix公司开源的一套 ZooKeeper Java客户端框架，相比于 Zookeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p>
<p><img src="images/curator.png"></p>
<p>下面我们就来简单地演示一下 Curator 的使用吧！</p>
<p>Curator4.0+版本对ZooKeeper 3.5.x支持比较好。开始之前，请先将下面的依赖添加进你的项目。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-连接-ZooKeeper-客户端"><a href="#3-1-连接-ZooKeeper-客户端" class="headerlink" title="3.1. 连接 ZooKeeper 客户端"></a>3.1. 连接 ZooKeeper 客户端</h3><p>通过 <code>CuratorFrameworkFactory</code> 创建 <code>CuratorFramework</code> 对象，然后再调用  <code>CuratorFramework</code> 对象的 <code>start()</code> 方法即可！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE_SLEEP_TIME = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RETRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retry strategy. Retry 3 times, and will increase the sleep time between retries.</span></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(BASE_SLEEP_TIME, MAX_RETRIES);</span><br><span class="line">CuratorFramework zkClient = CuratorFrameworkFactory.builder()</span><br><span class="line">    <span class="comment">// the server to connect to (can be a server list)</span></span><br><span class="line">    .connectString(<span class="string">&quot;127.0.0.1:2181&quot;</span>)</span><br><span class="line">    .retryPolicy(retryPolicy)</span><br><span class="line">    .build();</span><br><span class="line">zkClient.start();</span><br></pre></td></tr></table></figure>

<p>对于一些基本参数的说明：</p>
<ul>
<li><code>baseSleepTimeMs</code>：重试之间等待的初始时间</li>
<li><code>maxRetries</code> ：最大重试次数</li>
<li><code>connectString</code> ：要连接的服务器列表</li>
<li><code>retryPolicy</code> ：重试策略</li>
</ul>
<h3 id="3-2-数据节点的增删改查"><a href="#3-2-数据节点的增删改查" class="headerlink" title="3.2. 数据节点的增删改查"></a>3.2. 数据节点的增删改查</h3><h4 id="3-2-1-创建节点"><a href="#3-2-1-创建节点" class="headerlink" title="3.2.1. 创建节点"></a>3.2.1. 创建节点</h4><p>我们在 <a href="./zookeeper-intro.md">ZooKeeper常见概念解读</a> 中介绍到，我们通常是将 znode 分为 4 大类：</p>
<ul>
<li><strong>持久（PERSISTENT）节点</strong> ：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li>
<li><strong>临时（EPHEMERAL）节点</strong> ：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，临时节点 <strong>只能做叶子节点</strong> ，不能创建子节点。</li>
<li><strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong> ：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code> 、<code>/node1/app0000000002</code> 。</li>
<li><strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong> ：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li>
</ul>
<p>你在使用的ZooKeeper 的时候，会发现  <code>CreateMode</code> 类中实际有 7种 znode 类型 ，但是用的最多的还是上面介绍的 4 种。</p>
<p><strong>a.创建持久化节点</strong></p>
<p>你可以通过下面两种方式创建持久化的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意:下面的代码会报错，下文说了具体原因</span></span><br><span class="line">zkClient.create().forPath(<span class="string">&quot;/node1/00001&quot;</span>);</span><br><span class="line">zkClient.create().withMode(CreateMode.PERSISTENT).forPath(<span class="string">&quot;/node1/00002&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>但是，你运行上面的代码会报错，这是因为的父节点<code>node1</code>还未创建。</p>
<p>你可以先创建父节点 <code>node1</code> ，然后再执行上面的代码就不会报错了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkClient.create().forPath(<span class="string">&quot;/node1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>更推荐的方式是通过下面这行代码， <strong><code>creatingParentsIfNeeded()</code> 可以保证父节点不存在的时候自动创建父节点，这是非常有用的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="string">&quot;/node1/00001&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>b.创建临时节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">&quot;/node1/00001&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>c.创建节点并指定数据内容</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">&quot;/node1/00001&quot;</span>,<span class="string">&quot;java&quot;</span>.getBytes());</span><br><span class="line">zkClient.getData().forPath(<span class="string">&quot;/node1/00001&quot;</span>);<span class="comment">//获取节点的数据内容，获取到的是 byte数组</span></span><br></pre></td></tr></table></figure>

<p><strong>d.检测节点是否创建成功</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkClient.checkExists().forPath(<span class="string">&quot;/node1/00001&quot;</span>);<span class="comment">//不为null的话，说明节点创建成功</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-删除节点"><a href="#3-2-2-删除节点" class="headerlink" title="3.2.2. 删除节点"></a>3.2.2. 删除节点</h4><p><strong>a.删除一个子节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkClient.delete().forPath(<span class="string">&quot;/node1/00001&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>b.删除一个节点以及其下的所有子节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkClient.delete().deletingChildrenIfNeeded().forPath(<span class="string">&quot;/node1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-获取-更新节点数据内容"><a href="#3-2-3-获取-更新节点数据内容" class="headerlink" title="3.2.3. 获取/更新节点数据内容"></a>3.2.3. 获取/更新节点数据内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">&quot;/node1/00001&quot;</span>,<span class="string">&quot;java&quot;</span>.getBytes());</span><br><span class="line">zkClient.getData().forPath(<span class="string">&quot;/node1/00001&quot;</span>);<span class="comment">//获取节点的数据内容</span></span><br><span class="line">zkClient.setData().forPath(<span class="string">&quot;/node1/00001&quot;</span>,<span class="string">&quot;c++&quot;</span>.getBytes());<span class="comment">//更新节点数据内容</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-获取某个节点的所有子节点路径"><a href="#3-2-4-获取某个节点的所有子节点路径" class="headerlink" title="3.2.4. 获取某个节点的所有子节点路径"></a>3.2.4. 获取某个节点的所有子节点路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; childrenPaths = zkClient.getChildren().forPath(<span class="string">&quot;/node1&quot;</span>);</span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/distributed-system/zookeeper/zookeeper-in-action/" data-id="cks75dy63000g7kveds432sc2" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/distributed-system/rpc/服务之间的调用为啥不直接用HTTP而用RPC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/distributed-system/rpc/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8HTTP%E8%80%8C%E7%94%A8RPC/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:46.999Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="什么是-RPC-RPC原理是什么"><a href="#什么是-RPC-RPC原理是什么" class="headerlink" title="什么是 RPC?RPC原理是什么?"></a>什么是 RPC?RPC原理是什么?</h2><h3 id="什么是-RPC？"><a href="#什么是-RPC？" class="headerlink" title="什么是 RPC？"></a><strong>什么是 RPC？</strong></h3><p>RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。</p>
<h3 id="RPC原理是什么？"><a href="#RPC原理是什么？" class="headerlink" title="RPC原理是什么？"></a><strong>RPC原理是什么？</strong></h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg" alt="RPC原理图"></p>
<ol>
<li>服务消费端（client）以本地调用的方式调用远程服务；</li>
<li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li>
<li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li>
<li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: <code>RpcRequest</code>；</li>
<li>服务端 Stub（桩）根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li>
<li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li>
<li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:<code>RpcResponse</code> ，这样也就得到了最终结果。</li>
</ol>
<p>下面再贴一个网上的时序图，辅助理解：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/32527396.jpg" alt="RPC原理时序图"></p>
<h3 id="RPC-解决了什么问题？"><a href="#RPC-解决了什么问题？" class="headerlink" title="RPC 解决了什么问题？"></a>RPC 解决了什么问题？</h3><p>从上面对 RPC 介绍的内容中，概括来讲RPC 主要解决了：<strong>让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。</strong></p>
<h3 id="常见的-RPC-框架总结"><a href="#常见的-RPC-框架总结" class="headerlink" title="常见的 RPC 框架总结?"></a>常见的 RPC 框架总结?</h3><ul>
<li><strong>RMI（JDK自带）：</strong> JDK自带的RPC，有很多局限性，不推荐使用。</li>
<li><strong>Dubbo:</strong> Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。</li>
<li><strong>gRPC</strong> ：gRPC是可以在任何环境中运行的现代开源高性能RPC框架。它可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。</li>
<li><strong>Hessian：</strong> Hessian是一个轻量级的remotingonhttp工具，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。</li>
<li><strong>Thrift：</strong>  Apache Thrift是Facebook开源的跨语言的RPC通信框架，目前已经捐献给Apache基金会管理，由于其跨语言特性和出色的性能，在很多互联网公司得到应用，有能力的公司甚至会基于thrift研发一套分布式服务框架，增加诸如服务注册、服务发现等功能。</li>
</ul>
<h3 id="RPC学习材料"><a href="#RPC学习材料" class="headerlink" title="RPC学习材料"></a>RPC学习材料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Snailclimb/guide-rpc-framework">跟着 Guide 哥造轮子</a></li>
</ul>
<h2 id="既有-HTTP-为啥用-RPC-进行服务调用"><a href="#既有-HTTP-为啥用-RPC-进行服务调用" class="headerlink" title="既有 HTTP ,为啥用 RPC 进行服务调用?"></a>既有 HTTP ,为啥用 RPC 进行服务调用?</h2><h3 id="RPC-只是一种设计而已"><a href="#RPC-只是一种设计而已" class="headerlink" title="RPC 只是一种设计而已"></a>RPC 只是一种设计而已</h3><p>RPC 只是一种概念、一种设计，就是为了解决 <strong>不同服务之间的调用问题</strong>, 它一般会包含有 <strong>传输协议</strong> 和 <strong>序列化协议</strong> 这两个。</p>
<p>但是，HTTP  是一种协议，RPC框架可以使用 HTTP协议作为传输协议或者直接使用TCP作为传输协议，使用不同的协议一般也是为了适应不同的场景。</p>
<h3 id="HTTP-和-TCP"><a href="#HTTP-和-TCP" class="headerlink" title="HTTP 和 TCP"></a>HTTP 和 TCP</h3><p><strong>可能现在很多对计算机网络不太熟悉的朋友已经被搞蒙了，要想真正搞懂，还需要来简单复习一下计算机网络基础知识：</strong></p>
<blockquote>
<p>我们通常谈计算机网络的五层协议的体系结构是指：应用层、传输层、网络层、数据链路层、物理层。</p>
<p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong>HTTP 属于应用层协议，它会基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过 URL 向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。HTTP协议建立在 TCP 协议之上。</p>
<p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。TCP是传输层协议，主要解决数据如何在网络中传输。相比于UDP,<strong>TCP</strong> 提供的是<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</p>
</blockquote>
<h3 id="RPC框架功能更齐全"><a href="#RPC框架功能更齐全" class="headerlink" title="RPC框架功能更齐全"></a>RPC框架功能更齐全</h3><p>成熟的 RPC框架还提供好了“服务自动注册与发现”、”智能负载均衡”、“可视化的服务治理和运维”、“运行期流量调度”等等功能，这些也算是选择<br>RPC 进行服务注册和发现的一方面原因吧！</p>
<p><strong>相关阅读：</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/08/http.html">http://www.ruanyifeng.com/blog/2016/08/http.html</a> （HTTP 协议入门- 阮一峰）</li>
</ul>
<h3 id="一个常见的错误观点"><a href="#一个常见的错误观点" class="headerlink" title="一个常见的错误观点"></a>一个常见的错误观点</h3><p>很多文章中还会提到说 HTTP 协议相较于自定义 TCP 报文协议，增加的开销在于连接的建立与断开，但是这个观点已经被否认，下面截取自知乎中一个回答，原回答地址：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/41609070/answer/191965937%E3%80%82">https://www.zhihu.com/question/41609070/answer/191965937。</a></p>
<blockquote>
<p>首先要否认一点 HTTP 协议相较于自定义 TCP 报文协议，增加的开销在于连接的建立与断开。HTTP 协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。二一要说的是 HTTP 也可以使用 Protobuf 这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/distributed-system/rpc/%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E4%B8%BA%E5%95%A5%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8HTTP%E8%80%8C%E7%94%A8RPC/" data-id="cks75dy64000h7kvecr7j8f3c" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/distributed-system/rpc/Dubbo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/distributed-system/rpc/Dubbo/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:46.995Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这篇文章是我根据官方文档以及自己平时的使用情况，对 Dubbo 所做的一个总结。欢迎补充！</p>
<h2 id="RPC基础"><a href="#RPC基础" class="headerlink" title="RPC基础"></a>RPC基础</h2><h3 id="何为-RPC"><a href="#何为-RPC" class="headerlink" title="何为 RPC?"></a>何为 RPC?</h3><p><strong>RPC（Remote Procedure Call）</strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p>
<p><strong>为什么要 RPC  ？</strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP还是UDP）、序列化方式等等方面。</p>
<p>**RPC 能帮助我们做什么呢？ ** 简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。</p>
<p>举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。</p>
<p>一言蔽之：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</strong></p>
<h3 id="RPC-的原理是什么"><a href="#RPC-的原理是什么" class="headerlink" title="RPC 的原理是什么?"></a>RPC 的原理是什么?</h3><p>为了能够帮助小伙伴们理解 RPC 原理，我们可以将整个 RPC的 核心功能看作是下面👇 6 个部分实现的：</p>
<ol>
<li><strong>客户端（服务消费端）</strong> ：调用远程方法的一端。</li>
<li><strong>客户端 Stub（桩）</strong> ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li>
<li><strong>网络传输</strong> ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最近基本的 Socket或者性能以及封装更加优秀的 Netty（推荐）。</li>
<li><strong>服务端 Stub（桩）</strong> ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</li>
<li><strong>服务端（服务提供端）</strong> ：提供远程方法的一端。</li>
</ol>
<p>具体原理图如下，后面我会串起来将整个RPC的过程给大家说一下。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg" alt="RPC原理图"></p>
<ol>
<li>服务消费端（client）以本地调用的方式调用远程服务；</li>
<li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li>
<li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li>
<li>服务端 Stub（桩）收到消息将消息反序列化为Java对象: <code>RpcRequest</code>；</li>
<li>服务端 Stub（桩）根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li>
<li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li>
<li>客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:<code>RpcResponse</code> ，这样也就得到了最终结果。over!</li>
</ol>
<p>相信小伙伴们看完上面的讲解之后，已经了解了 RPC 的原理。</p>
<p>虽然篇幅不多，但是基本把 RPC 框架的核心原理讲清楚了！另外，对于上面的技术细节，我会在后面的章节介绍到。</p>
<p><strong>最后，对于 RPC 的原理，希望小伙伴不单单要理解，还要能够自己画出来并且能够给别人讲出来。因为，在面试中这个问题在面试官问到 RPC 相关内容的时候基本都会碰到。</strong></p>
<h2 id="Dubbo基础"><a href="#Dubbo基础" class="headerlink" title="Dubbo基础"></a>Dubbo基础</h2><h3 id="什么是-Dubbo"><a href="#什么是-Dubbo" class="headerlink" title="什么是 Dubbo?"></a>什么是 Dubbo?</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/427f2168-1930-4c14-8760-415fac8db1d0-20200802184737978.png"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/apache/incubator-dubbo">Apache Dubbo</a> (incubating) |ˈdʌbəʊ|  是一款高性能、轻量级的开源 Java RPC 框架。</p>
<p>根据 <a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/">Dubbo 官方文档</a>的介绍，Dubbo 提供了六大核心能力</p>
<ol>
<li>面向接口代理的高性能RPC调用。</li>
<li>智能容错和负载均衡。</li>
<li>服务自动注册和发现。</li>
<li>高度可扩展能力。</li>
<li>运行期流量调度。</li>
<li>可视化的服务治理与运维。</li>
</ol>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/%E6%BA%90%E7%A0%81/dubbo/dubbo%E6%8F%90%E4%BE%9B%E7%9A%84%E5%85%AD%E5%A4%A7%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B.png" alt="Dubbo提供的六大核心能力"></p>
<p>简单来说就是： <strong>Dubbo 不光可以帮助我们调用远程服务，还提供了一些其他开箱即用的功能比如智能负载均衡。</strong></p>
<p>Dubbo 目前已经有接近 34.4 k 的 Star  。 </p>
<p>在 <strong>2020 年度 OSC 中国开源项目</strong> 评选活动中，Dubbo 位列开发框架和基础组件类项目的第7名。想比几年前来说，热度和排名有所下降。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/%E6%BA%90%E7%A0%81/dubbo/image-20210107153159545.png"></p>
<p>Dubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。</p>
<h3 id="为什么要用-Dubbo"><a href="#为什么要用-Dubbo" class="headerlink" title="为什么要用 Dubbo?"></a>为什么要用 Dubbo?</h3><p>随着互联网的发展，网站的规模越来越大，用户数量越来越多。单一应用架构 、垂直应用架构无法满足我们的需求，这个时候分布式服务架构就诞生了。</p>
<p>分布式服务架构下，系统被拆分成不同的服务比如短信服务、安全服务，每个服务独立提供系统的某个核心服务。</p>
<p>我们可以使用 Java RMI（Java Remote Method Invocation）、Hessian这种支持远程调用的框架来简单地暴露和引用远程服务。但是！当服务越来越多之后，服务调用关系越来越复杂。当应用访问压力越来越大后，负载均衡以及服务监控的需求也迫在眉睫。我们可以用 F5 这类硬件来做负载均衡，但这样增加了成本，并且存在单点故障的风险。</p>
<p>不过，Dubbo 的出现让上述问题得到了解决。<strong>Dubbo 帮助我们解决了什么问题呢？</strong></p>
<ol>
<li><strong>负载均衡</strong> ： 同一个服务部署在不同的机器时该调用那一台机器上的服务。</li>
<li><strong>服务调用链路生成</strong>  ： 随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。</li>
<li><strong>服务访问压力以及时长统计、资源调度和治理</strong> ：基于访问压力实时管理集群容量，提高集群利用率。</li>
<li>……</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-26/43050183.jpg"></p>
<p>另外，Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。</p>
<p><strong>我们刚刚提到了分布式这个概念，下面再给大家介绍一下什么是分布式？为什么要分布式？</strong></p>
<h2 id="分布式基础"><a href="#分布式基础" class="headerlink" title="分布式基础"></a>分布式基础</h2><h3 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式?"></a>什么是分布式?</h3><p>分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。比如电商系统可以简单地拆分成订单系统、商品系统、登录系统等等，拆分之后的每个服务可以部署在不同的机器上，如果某一个服务的访问量比较大的话也可以将这个服务同时部署在多台机器上。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="分布式事务示意图"></p>
<h3 id="为什么要分布式"><a href="#为什么要分布式" class="headerlink" title="为什么要分布式?"></a>为什么要分布式?</h3><p>从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。</p>
<p>另外，我觉得将系统拆分成分布式之后不光便于系统扩展和维护，更能提高整个系统的性能。你想一想嘛？把整个系统拆分成不同的服务/系统，然后每个服务/系统 单独部署在一台服务器上，是不是很大程度上提高了系统性能呢？</p>
<h2 id="Dubbo-架构"><a href="#Dubbo-架构" class="headerlink" title="Dubbo 架构"></a>Dubbo 架构</h2><h3 id="Dubbo-架构中的核心角色有哪些？"><a href="#Dubbo-架构中的核心角色有哪些？" class="headerlink" title="Dubbo 架构中的核心角色有哪些？"></a>Dubbo 架构中的核心角色有哪些？</h3><p><a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/dev/design/">官方文档中的框架设计章节</a> 已经介绍的非常详细了，我这里把一些比较重要的点再提一下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/%E6%BA%90%E7%A0%81/dubbo/dubbo-relation.jpg" alt="dubbo-relation"></p>
<p>上述节点简单介绍以及他们之间的关系：</p>
<ul>
<li><strong>Container：</strong> 服务运行容器，负责加载、运行服务提供者。必须。</li>
<li><strong>Provider：</strong> 暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。</li>
<li><strong>Consumer：</strong> 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。</li>
<li><strong>Registry：</strong> 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。</li>
<li><strong>Monitor：</strong> 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须。</li>
</ul>
<h3 id="Dubbo-中的-Invoker-概念了解么？"><a href="#Dubbo-中的-Invoker-概念了解么？" class="headerlink" title="Dubbo 中的 Invoker 概念了解么？"></a>Dubbo 中的 Invoker 概念了解么？</h3><p><code>Invoker</code> 是 Dubbo 领域模型中非常重要的一个概念，你如果阅读过 Dubbo 源码的话，你会无数次看到这玩意。就比如下面我要说的负载均衡这块的源码中就有大量 <code>Invoker</code> 的身影。</p>
<p>简单来说，<code>Invoker</code> 就是 Dubbo 对远程调用的抽象。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/dubbo_rpc_invoke.jpg" alt="dubbo_rpc_invoke.jpg"></p>
<p>按照 Dubbo 官方的话来说，<code>Invoker</code>  分为</p>
<ul>
<li>服务提供 <code>Invoker</code> </li>
<li>服务消费 <code>Invoker</code></li>
</ul>
<p>假如我们需要调用一个远程方法，我们需要动态代理来屏蔽远程调用的细节吧！我们屏蔽掉的这些细节就依赖对应的 <code>Invoker</code>  实现， <code>Invoker</code> 实现了真正的远程服务调用。</p>
<h3 id="Dubbo-的工作原理了解么？"><a href="#Dubbo-的工作原理了解么？" class="headerlink" title="Dubbo 的工作原理了解么？"></a>Dubbo 的工作原理了解么？</h3><p>下图是 Dubbo 的整体设计，从下至上分为十层，各层均为单向依赖。</p>
<blockquote>
<p>左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。</p>
</blockquote>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/source-code/dubbo/dubbo-framework.jpg" alt="dubbo-framework"></p>
<ul>
<li><strong>config 配置层</strong>：Dubbo相关的配置。支持代码配置，同时也支持基于 Spring  来做配置，以 <code>ServiceConfig</code>, <code>ReferenceConfig</code> 为中心</li>
<li><strong>proxy 服务代理层</strong>：调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以 <code>ServiceProxy</code> 为中心。</li>
<li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现。</li>
<li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code> 为中心。</li>
<li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 <code>Statistics</code> 为中心。</li>
<li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 <code>Invocation</code>, <code>Result</code> 为中心。</li>
<li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 <code>Request</code>, <code>Response</code> 为中心。</li>
<li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 <code>Message</code> 为中心。</li>
<li><strong>serialize 数据序列化层</strong> ：对需要在网络传输的数据进行序列化。</li>
</ul>
<h3 id="Dubbo-的-SPI-机制了解么？-如何扩展-Dubbo-中的默认实现？"><a href="#Dubbo-的-SPI-机制了解么？-如何扩展-Dubbo-中的默认实现？" class="headerlink" title="Dubbo 的 SPI 机制了解么？ 如何扩展 Dubbo 中的默认实现？"></a>Dubbo 的 SPI 机制了解么？ 如何扩展 Dubbo 中的默认实现？</h3><p>SPI（Service Provider Interface） 机制被大量用在开源项目中，它可以帮助我们动态寻找服务/功能（比如负载均衡策略）的实现。</p>
<p>SPI 的具体原理是这样的：我们将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类。和 IoC 的解耦思想是类似的。</p>
<p>Java 本身就提供了 SPI 机制的实现。不过，Dubbo 没有直接用，而是对 Java原生的 SPI机制进行了增强，以便更好满足自己的需求。</p>
<p><strong>那我们如何扩展 Dubbo 中的默认实现呢？</strong></p>
<p>比如说我们想要实现自己的负载均衡策略，我们创建对应的实现类 <code>XxxLoadBalance</code> 实现 <code>LoadBalance</code> 接口或者 <code>AbstractLoadBalance</code> 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxx;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.rpc.cluster.LoadBalance;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.rpc.Invoker;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.rpc.Invocation;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.rpc.RpcException; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxLoadBalance</span> <span class="keyword">implements</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将这个是实现类的路径写入到<code>resources</code> 目录下的 <code>META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance</code>文件中即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line"> |-main</span><br><span class="line">    |-java</span><br><span class="line">        |-com</span><br><span class="line">            |-xxx</span><br><span class="line">                |-XxxLoadBalance.java (实现LoadBalance接口)</span><br><span class="line">    |-resources</span><br><span class="line">        |-META-INF</span><br><span class="line">            |-dubbo</span><br><span class="line">                |-org.apache.dubbo.rpc.cluster.LoadBalance (纯文本文件，内容为：xxx=com.xxx.XxxLoadBalance)</span><br></pre></td></tr></table></figure>

<p><code>org.apache.dubbo.rpc.cluster.LoadBalance</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx=com.xxx.XxxLoadBalance</span><br></pre></td></tr></table></figure>

<p>其他还有很多可供扩展的选择，你可以在<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/dev/impls/">官方文档@SPI扩展实现</a>这里找到。</p>
<p><img src="https://img-blog.csdnimg.cn/20210328091015555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70"></p>
<h3 id="Dubbo-的微内核架构了解吗？"><a href="#Dubbo-的微内核架构了解吗？" class="headerlink" title="Dubbo 的微内核架构了解吗？"></a>Dubbo 的微内核架构了解吗？</h3><p>Dubbo 采用 微内核（Microkernel） + 插件（Plugin） 模式，简单来说就是微内核架构。微内核只负责组装插件。</p>
<p><strong>何为微内核架构呢？</strong> 《软件架构模式》 这本书是这样介绍的：</p>
<blockquote>
<p>微内核架构模式（有时被称为插件架构模式）是实现基于产品应用程序的一种自然模式。基于产品的应用程序是已经打包好并且拥有不同版本，可作为第三方插件下载的。然后，很多公司也在开发、发布自己内部商业应用像有版本号、说明及可加载插件式的应用软件（这也是这种模式的特征）。微内核系统可让用户添加额外的应用如插件，到核心应用，继而提供了可扩展性和功能分离的用法。</p>
</blockquote>
<p>微内核架构包含两类组件：<strong>核心系统（core system）</strong> 和 <strong>插件模块（plug-in modules）</strong>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/source-code/dubbo/%E5%BE%AE%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p>核心系统提供系统所需核心能力，插件模块可以扩展系统的功能。因此， 基于微内核架构的系统，非常易于扩展功能。</p>
<p>我们常见的一些IDE，都可以看作是基于微内核架构设计的。绝大多数 IDE比如IDEA、VSCode都提供了插件来丰富自己的功能。</p>
<p>正是因为Dubbo基于微内核架构，才使得我们可以随心所欲替换Dubbo的功能点。比如你觉得Dubbo 的序列化模块实现的不满足自己要求，没关系啊！你自己实现一个序列化模块就好了啊！</p>
<p>通常情况下，微核心都会采用 Factory、IoC、OSGi 等方式管理插件生命周期。Dubbo 不想依赖 Spring 等 IoC 容器，也不想自已造一个小的 IoC 容器（过度设计），因此采用了一种最简单的 Factory 方式管理插件 ：<strong>JDK 标准的 SPI 扩展机制</strong> （<code>java.util.ServiceLoader</code>）。</p>
<h3 id="关于Dubbo架构的一些自测小问题"><a href="#关于Dubbo架构的一些自测小问题" class="headerlink" title="关于Dubbo架构的一些自测小问题"></a>关于Dubbo架构的一些自测小问题</h3><h4 id="注册中心的作用了解么？"><a href="#注册中心的作用了解么？" class="headerlink" title="注册中心的作用了解么？"></a>注册中心的作用了解么？</h4><p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互。</p>
<h4 id="服务提供者宕机后，注册中心会做什么？"><a href="#服务提供者宕机后，注册中心会做什么？" class="headerlink" title="服务提供者宕机后，注册中心会做什么？"></a>服务提供者宕机后，注册中心会做什么？</h4><p>注册中心会立即推送事件通知消费者。</p>
<h4 id="监控中心的作用呢？"><a href="#监控中心的作用呢？" class="headerlink" title="监控中心的作用呢？"></a>监控中心的作用呢？</h4><p>监控中心负责统计各服务调用次数，调用时间等。</p>
<h4 id="注册中心和监控中心都宕机的话，服务都会挂掉吗？"><a href="#注册中心和监控中心都宕机的话，服务都会挂掉吗？" class="headerlink" title="注册中心和监控中心都宕机的话，服务都会挂掉吗？"></a>注册中心和监控中心都宕机的话，服务都会挂掉吗？</h4><p>不会。两者都宕机也不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。</p>
<h2 id="Dubbo-的负载均衡策略"><a href="#Dubbo-的负载均衡策略" class="headerlink" title="Dubbo 的负载均衡策略"></a>Dubbo 的负载均衡策略</h2><h3 id="什么是负载均衡？"><a href="#什么是负载均衡？" class="headerlink" title="什么是负载均衡？"></a>什么是负载均衡？</h3><p>先来看一下稍微官方点的解释。下面这段话摘自维基百科对负载均衡的定义：</p>
<blockquote>
<p>负载均衡改善了跨多个计算资源（例如计算机，计算机集群，网络链接，中央处理单元或磁盘驱动）的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间，并避免任何单个资源的过载。使用具有负载平衡而不是单个组件的多个组件可以通过冗余提高可靠性和可用性。负载平衡通常涉及专用软件或硬件。</p>
</blockquote>
<p><strong>上面讲的大家可能不太好理解，再用通俗的话给大家说一下。</strong></p>
<p>我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。</p>
<h3 id="Dubbo-提供的负载均衡策略有哪些？"><a href="#Dubbo-提供的负载均衡策略有哪些？" class="headerlink" title="Dubbo 提供的负载均衡策略有哪些？"></a>Dubbo 提供的负载均衡策略有哪些？</h3><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 <code>random</code> 随机调用。我们还可以自行扩展负载均衡策略（参考Dubbo SPI机制）。</p>
<p>在 Dubbo 中，所有负载均衡实现类均继承自 <code>AbstractLoadBalance</code>，该类实现了 <code>LoadBalance</code> 接口，并封装了一些公共的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLoadBalance</span> <span class="keyword">implements</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateWarmupWeight</span><span class="params">(<span class="keyword">int</span> uptime, <span class="keyword">int</span> warmup, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AbstractLoadBalance</code> 的实现类有下面这些：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/image-20210326105257812.png"></p>
<p>官方文档对负载均衡这部分的介绍非常详细，推荐小伙伴们看看，地址：<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#m-zhdocsv27devsourceloadbalance">https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#m-zhdocsv27devsourceloadbalance</a> 。</p>
<h4 id="RandomLoadBalance"><a href="#RandomLoadBalance" class="headerlink" title="RandomLoadBalance"></a>RandomLoadBalance</h4><p>根据权重随机选择（对加权随机算法的实现）。这是Dubbo默认采用的一种负载均衡策略。</p>
<p><code> RandomLoadBalance</code> 具体的实现原理非常简单，假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。</p>
<p>我们把这些权重值分布在坐标区间会得到：S1-&gt;[0, 7) ，S2-&gt;(7, 10]。我们生成[0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/%20RandomLoadBalance.png" alt="RandomLoadBalance"></p>
<p><code>RandomLoadBalance</code> 的源码非常简单，简单花几分钟时间看一下。</p>
<blockquote>
<p>以下源码来自 Dubbo master 分支上的最新的版本 2.7.9。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;random&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length]; </span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 下面这个for循环的主要作用就是计算所有该服务的提供者的权重之和 totalWeight（），</span></span><br><span class="line">        <span class="comment">// 除此之外，还会检测每个服务提供者的权重是否相同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">            totalWeight += weight;</span><br><span class="line">            weights[i] = totalWeight;</span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; totalWeight != weight * (i + <span class="number">1</span>)) &#123;</span><br><span class="line">                sameWeight = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// 随机生成一个 [0, totalWeight) 区间内的数字</span></span><br><span class="line">            <span class="keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// 判断会落在哪个服务提供者的区间</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; weights[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="LeastActiveLoadBalance"><a href="#LeastActiveLoadBalance" class="headerlink" title="LeastActiveLoadBalance"></a>LeastActiveLoadBalance</h4><p><code>LeastActiveLoadBalance</code> 直译过来就是<strong>最小活跃数负载均衡</strong>。</p>
<p>这个名字起得有点不直观，不仔细看官方对活跃数的定义，你压根不知道这玩意是干嘛的。</p>
<p>我这么说吧！初始状态下所有服务提供者的活跃数均为 0（每个服务提供者的中特定方法都对应一个活跃数，我在后面的源码中会提到），每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。</p>
<p>因此，<strong>Dubbo 就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。</strong></p>
<p><strong>如果有多个服务提供者的活跃数相等怎么办？</strong></p>
<p>很简单，那就再走一遍  <code>RandomLoadBalance</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeastActiveLoadBalance</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;leastactive&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = invokers.size();</span><br><span class="line">        <span class="keyword">int</span> leastActive = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leastCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leastIndexes = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> firstWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sameWeight = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 这个 for 循环的主要作用是遍历 invokers 列表，找出活跃数最小的 Invoker</span></span><br><span class="line">        <span class="comment">// 如果有多个 Invoker 具有相同的最小活跃数，还会记录下这些 Invoker 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line">            <span class="comment">// 获取 invoker 对应的活跃(active)数</span></span><br><span class="line">            <span class="keyword">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line">            <span class="keyword">int</span> afterWarmup = getWeight(invoker, invocation);</span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || active &lt; leastActive) &#123;</span><br><span class="line">                leastActive = active;</span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line">                leastIndexes[<span class="number">0</span>] = i;</span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line">                sameWeight = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123;</span><br><span class="line">                leastIndexes[leastCount++] = i;</span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 如果只有一个 Invoker 具有最小的活跃数，此时直接返回该 Invoker 即可</span></span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(leastIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有多个 Invoker 具有相同的最小活跃数，但它们之间的权重不同</span></span><br><span class="line">        <span class="comment">// 这里的处理方式就和  RandomLoadBalance 一致了</span></span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> leastIndex = leastIndexes[i];</span><br><span class="line">                offsetWeight -= weights[leastIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>活跃数是通过 <code>RpcStatus</code> 中的一个 <code>ConcurrentMap</code> 保存的，根据 URL 以及服务提供者被调用的方法的名称，我们便可以获取到对应的活跃数。也就是说服务提供者中的每一个方法的活跃数都是互相独立的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcStatus</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, RpcStatus&gt;&gt; METHOD_STATISTICS =</span><br><span class="line">            <span class="keyword">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, RpcStatus&gt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RpcStatus <span class="title">getStatus</span><span class="params">(URL url, String methodName)</span> </span>&#123;</span><br><span class="line">        String uri = url.toIdentityString();</span><br><span class="line">        ConcurrentMap&lt;String, RpcStatus&gt; map = METHOD_STATISTICS.computeIfAbsent(uri, k -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> map.computeIfAbsent(methodName, k -&gt; <span class="keyword">new</span> RpcStatus());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> active.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ConsistentHashLoadBalance"><a href="#ConsistentHashLoadBalance" class="headerlink" title="ConsistentHashLoadBalance"></a>ConsistentHashLoadBalance</h4><p><code>ConsistentHashLoadBalance</code>  小伙伴们应该也不会陌生，在分库分表、各种集群中就经常使用这个负载均衡策略。</p>
<p><code>ConsistentHashLoadBalance</code> 即<strong>一致性Hash负载均衡策略</strong>。 <code>ConsistentHashLoadBalance</code> 中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/consistent-hash-data-incline.jpg"></p>
<p>另外，Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/consistent-hash-invoker.jpg"></p>
<p>官方有详细的源码分析：<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#23-consistenthashloadbalance">https://dubbo.apache.org/zh/docs/v2.7/dev/source/loadbalance/#23-consistenthashloadbalance</a> 。这里还有一个相关的 <a target="_blank" rel="noopener" href="https://github.com/apache/dubbo/pull/5440">PR#5440</a> 来修复老版本中 ConsistentHashLoadBalance 存在的一些Bug。感兴趣的小伙伴，可以多花点时间研究一下。我这里不多分析了，这个作业留给你们！</p>
<h4 id="RoundRobinLoadBalance"><a href="#RoundRobinLoadBalance" class="headerlink" title="RoundRobinLoadBalance"></a>RoundRobinLoadBalance</h4><p>加权轮询负载均衡。</p>
<p>轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。比如假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。</p>
<p>如果我们有 10 次请求，那么  7 次会被 S1处理，3次被 S2处理。</p>
<p>但是，如果是 <code>RandomLoadBalance</code> 的话，很可能存在10次请求有9次都被 S1 处理的情况（概率性问题）。</p>
<p>Dubbo 中的 <code>RoundRobinLoadBalance</code> 的代码实现被修改重建了好几次，Dubbo-2.6.5 版本的 <code>RoundRobinLoadBalance</code> 为平滑加权轮询算法。</p>
<h2 id="Dubbo序列化协议"><a href="#Dubbo序列化协议" class="headerlink" title="Dubbo序列化协议"></a>Dubbo序列化协议</h2><h3 id="Dubbo-支持哪些序列化方式呢？"><a href="#Dubbo-支持哪些序列化方式呢？" class="headerlink" title="Dubbo 支持哪些序列化方式呢？"></a>Dubbo 支持哪些序列化方式呢？</h3><p><img src="https://img-blog.csdnimg.cn/20210328092219640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70"></p>
<p>Dubbo 支持多种序列化方式：JDK自带的序列化、hessian2、JSON、Kryo、FST、Protostuff，ProtoBuf等等。</p>
<p>Dubbo 默认使用的序列化方式是 hession2。</p>
<h3 id="谈谈你对这些序列化协议了解？"><a href="#谈谈你对这些序列化协议了解？" class="headerlink" title="谈谈你对这些序列化协议了解？"></a>谈谈你对这些序列化协议了解？</h3><p>一般我们不会直接使用 JDK 自带的序列化方式。主要原因有两个：</p>
<ol>
<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
</ol>
<p>JSON 序列化由于性能问题，我们一般也不会考虑使用。</p>
<p>像 Protostuff，ProtoBuf、hessian2这些都是跨语言的序列化方式，如果有跨语言需求的话可以考虑使用。</p>
<p>Kryo和FST这两种序列化方式是 Dubbo 后来才引入的，性能非常好。不过，这两者都是专门针对 Java 语言的。Dubbo 官网的一篇文章中提到说推荐使用 Kryo 作为生产环境的序列化方式。(文章地址：<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/">https://dubbo.apache.org/zh/docs/v2.7/user/references/protocol/rest/</a>)</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/569e541a-22b2-4846-aa07-0ad479f07440.png"></p>
<p>Dubbo 官方文档中还有一个关于这些<a target="_blank" rel="noopener" href="https://dubbo.apache.org/zh/docs/v2.7/user/serialization/#m-zhdocsv27userserialization">序列化协议的性能对比图</a>可供参考。</p>
<p><img src="https://img-blog.csdnimg.cn/20210328093219609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzM3Mjcy,size_16,color_FFFFFF,t_70"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/distributed-system/rpc/Dubbo/" data-id="cks75dy6b000o7kve999jh3f2" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/distributed-system/message-queue/RocketMQ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/distributed-system/message-queue/RocketMQ/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:46.988Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>文章很长，点赞再看，养成好习惯😋😋😋</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485969&idx=1&sn=6bd53abde30d42a778d5a35ec104428c&chksm=cea245daf9d5cccce631f93115f0c2c4a7634e55f5bef9009fd03f5a0ffa55b745b5ef4f0530&token=294077121&lang=zh_CN#rd">本文由 FrancisQ 老哥投稿！</a></p>
</blockquote>
<h2 id="消息队列扫盲"><a href="#消息队列扫盲" class="headerlink" title="消息队列扫盲"></a>消息队列扫盲</h2><p>消息队列顾名思义就是存放消息的队列，队列我就不解释了，别告诉我你连队列都不知道似啥吧？</p>
<p>所以问题并不是消息队列是什么，而是 <strong>消息队列为什么会出现？消息队列能用来干什么？用它来干这些事会带来什么好处？消息队列会带来副作用吗？</strong></p>
<h3 id="消息队列为什么会出现？"><a href="#消息队列为什么会出现？" class="headerlink" title="消息队列为什么会出现？"></a>消息队列为什么会出现？</h3><p>消息队列算是作为后端程序员的一个必备技能吧，因为<strong>分布式应用必定涉及到各个系统之间的通信问题</strong>，这个时候消息队列也应运而生了。可以说分布式的产生是消息队列的基础，而分布式怕是一个很古老的概念了吧，所以消息队列也是一个很古老的中间件了。</p>
<h3 id="消息队列能用来干什么？"><a href="#消息队列能用来干什么？" class="headerlink" title="消息队列能用来干什么？"></a>消息队列能用来干什么？</h3><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>你可能会反驳我，应用之间的通信又不是只能由消息队列解决，好好的通信为什么中间非要插一个消息队列呢？我不能直接进行通信吗？</p>
<p>很好👍，你又提出了一个概念，<strong>同步通信</strong>。就比如现在业界使用比较多的 <code>Dubbo</code> 就是一个适用于各个系统之间同步通信的 <code>RPC</code> 框架。</p>
<p>我来举个🌰吧，比如我们有一个购票系统，需求是用户在购买完之后能接收到购买完成的短信。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef37fee7e09230.jpg"></p>
<p>我们省略中间的网络通信时间消耗，假如购票系统处理需要 150ms ，短信系统处理需要 200ms ，那么整个处理流程的时间消耗就是 150ms + 200ms = 350ms。</p>
<p>当然，乍看没什么问题。可是仔细一想你就感觉有点问题，我用户购票在购票系统的时候其实就已经完成了购买，而我现在通过同步调用非要让整个请求拉长时间，而短息系统这玩意又不是很有必要，它仅仅是一个辅助功能增强用户体验感而已。我现在整个调用流程就有点 <strong>头重脚轻</strong> 的感觉了，购票是一个不太耗时的流程，而我现在因为同步调用，非要等待发送短信这个比较耗时的操作才返回结果。那我如果再加一个发送邮件呢？</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef380429cf373e.jpg"></p>
<p>这样整个系统的调用链又变长了，整个时间就变成了550ms。</p>
<p>当我们在学生时代需要在食堂排队的时候，我们和食堂大妈就是一个同步的模型。</p>
<p>我们需要告诉食堂大妈：“姐姐，给我加个鸡腿，再加个酸辣土豆丝，帮我浇点汁上去，多打点饭哦😋😋😋”  咦~~~ 为了多吃点，真恶心。</p>
<p>然后大妈帮我们打饭配菜，我们看着大妈那颤抖的手和掉落的土豆丝不禁咽了咽口水。</p>
<p>最终我们从大妈手中接过饭菜然后去寻找座位了…</p>
<p>回想一下，我们在给大妈发送需要的信息之后我们是 <strong>同步等待大妈给我配好饭菜</strong> 的，上面我们只是加了鸡腿和土豆丝，万一我再加一个番茄牛腩，韭菜鸡蛋，这样是不是大妈打饭配菜的流程就会变长，我们等待的时间也会相应的变长。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/006APoFYly1fvd9cwjlfrj30as0b03ym.jpg"></p>
<p>那后来，我们工作赚钱了有钱去饭店吃饭了，我们告诉服务员来一碗牛肉面加个荷包蛋 <strong>(传达一个消息)</strong> ，然后我们就可以在饭桌上安心的玩手机了 <strong>(干自己其他事情)</strong> ，等到我们的牛肉面上了我们就可以吃了。这其中我们也就传达了一个消息，然后我们又转过头干其他事情了。这其中虽然做面的时间没有变短，但是我们只需要传达一个消息就可以看其他事情了，这是一个 <strong>异步</strong> 的概念。</p>
<p>所以，为了解决这一个问题，聪明的程序员在中间也加了个类似于服务员的中间件——消息队列。这个时候我们就可以把模型给改造了。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38124f55eaea.jpg"></p>
<p>这样，我们在将消息存入消息队列之后我们就可以直接返回了(我们告诉服务员我们要吃什么然后玩手机)，所以整个耗时只是 150ms + 10ms = 160ms。</p>
<blockquote>
<p>但是你需要注意的是，整个流程的时长是没变的，就像你仅仅告诉服务员要吃什么是不会影响到做面的速度的。</p>
</blockquote>
<h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p>回到最初同步调用的过程，我们写个伪代码简单概括一下。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef381a505d3e1f.jpg"></p>
<p>那么第二步，我们又添加了一个发送邮件，我们就得重新去修改代码，如果我们又加一个需求：用户购买完还需要给他加积分，这个时候我们是不是又得改代码？</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef381c4e1b1ac7.jpg"></p>
<p>如果你觉得还行，那么我这个时候不要发邮件这个服务了呢，我是不是又得改代码，又得重启应用？</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef381f273a66bd.jpg"></p>
<p>这样改来改去是不是很麻烦，那么 <strong>此时我们就用一个消息队列在中间进行解耦</strong> 。你需要注意的是，我们后面的发送短信、发送邮件、添加积分等一些操作都依赖于上面的 <code>result</code> ，这东西抽象出来就是购票的处理结果呀，比如订单号，用户账号等等，也就是说我们后面的一系列服务都是需要同样的消息来进行处理。既然这样，我们是不是可以通过 <strong>“广播消息”</strong> 来实现。</p>
<p>我上面所讲的“广播”并不是真正的广播，而是接下来的系统作为消费者去 <strong>订阅</strong> 特定的主题。比如我们这里的主题就可以叫做 <code>订票</code> ，我们购买系统作为一个生产者去生产这条消息放入消息队列，然后消费者订阅了这个主题，会从消息队列中拉取消息并消费。就比如我们刚刚画的那张图，你会发现，在生产者这边我们只需要关注 <strong>生产消息到指定主题中</strong> ，而 <strong>消费者只需要关注从指定主题中拉取消息</strong> 就行了。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef382674b66892.jpg"></p>
<blockquote>
<p>如果没有消息队列，每当一个新的业务接入，我们都要在主系统调用新接口、或者当我们取消某些业务，我们也得在主系统删除某些接口调用。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，接下来收到消息如何处理，是下游的事情，无疑极大地减少了开发和联调的工作量。</p>
</blockquote>
<h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><p>我们再次回到一开始我们使用同步调用系统的情况，并且思考一下，如果此时有大量用户请求购票整个系统会变成什么样？</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef382a9756bb1c.jpg"></p>
<p>如果，此时有一万的请求进入购票系统，我们知道运行我们主业务的服务器配置一般会比较好，所以这里我们假设购票系统能承受这一万的用户请求，那么也就意味着我们同时也会出现一万调用发短信服务的请求。而对于短信系统来说并不是我们的主要业务，所以我们配备的硬件资源并不会太高，那么你觉得现在这个短信系统能承受这一万的峰值么，且不说能不能承受，系统会不会 <strong>直接崩溃</strong> 了？</p>
<p>短信业务又不是我们的主业务，我们能不能 <strong>折中处理</strong> 呢？如果我们把购买完成的信息发送到消息队列中，而短信系统 <strong>尽自己所能地去消息队列中取消息和消费消息</strong> ，即使处理速度慢一点也无所谓，只要我们的系统没有崩溃就行了。</p>
<p>留得江山在，还怕没柴烧？你敢说每次发送验证码的时候是一发你就收到了的么？</p>
<h4 id="消息队列能带来什么好处？"><a href="#消息队列能带来什么好处？" class="headerlink" title="消息队列能带来什么好处？"></a>消息队列能带来什么好处？</h4><p>其实上面我已经说了。<strong>异步、解耦、削峰。</strong> 哪怕你上面的都没看懂也千万要记住这六个字，因为他不仅是消息队列的精华，更是编程和架构的精华。</p>
<h4 id="消息队列会带来副作用吗？"><a href="#消息队列会带来副作用吗？" class="headerlink" title="消息队列会带来副作用吗？"></a>消息队列会带来副作用吗？</h4><p>没有哪一门技术是“银弹”，消息队列也有它的副作用。</p>
<p>比如，本来好好的两个系统之间的调用，我中间加了个消息队列，如果消息队列挂了怎么办呢？是不是 <strong>降低了系统的可用性</strong> ？</p>
<p>那这样是不是要保证HA(高可用)？是不是要搞集群？那么我 <strong>整个系统的复杂度是不是上升了</strong> ？</p>
<p>抛开上面的问题不讲，万一我发送方发送失败了，然后执行重试，这样就可能产生重复的消息。</p>
<p>或者我消费端处理失败了，请求重发，这样也会产生重复的消息。</p>
<p>对于一些微服务来说，消费重复消息会带来更大的麻烦，比如增加积分，这个时候我加了多次是不是对其他用户不公平？</p>
<p>那么，又 <strong>如何解决重复消费消息的问题</strong> 呢？</p>
<p>如果我们此时的消息需要保证严格的顺序性怎么办呢？比如生产者生产了一系列的有序消息(对一个id为1的记录进行删除增加修改)，但是我们知道在发布订阅模型中，对于主题是无顺序的，那么这个时候就会导致对于消费者消费消息的时候没有按照生产者的发送顺序消费，比如这个时候我们消费的顺序为修改删除增加，如果该记录涉及到金额的话是不是会出大事情？</p>
<p>那么，又 <strong>如何解决消息的顺序消费问题</strong> 呢？</p>
<p>就拿我们上面所讲的分布式系统来说，用户购票完成之后是不是需要增加账户积分？在同一个系统中我们一般会使用事务来进行解决，如果用 <code>Spring</code> 的话我们在上面伪代码中加入 <code>@Transactional</code> 注解就好了。但是在不同系统中如何保证事务呢？总不能这个系统我扣钱成功了你那积分系统积分没加吧？或者说我这扣钱明明失败了，你那积分系统给我加了积分。</p>
<p>那么，又如何 <strong>解决分布式事务问题</strong> 呢？</p>
<p>我们刚刚说了，消息队列可以进行削峰操作，那如果我的消费者如果消费很慢或者生产者生产消息很快，这样是不是会将消息堆积在消息队列中？</p>
<p>那么，又如何 <strong>解决消息堆积的问题</strong> 呢？</p>
<p>可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题，这消息队列还怎么用啊😵？</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef382d709abc9d.png"></p>
<p>别急，办法总是有的。</p>
<h2 id="RocketMQ是什么？"><a href="#RocketMQ是什么？" class="headerlink" title="RocketMQ是什么？"></a>RocketMQ是什么？</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef383014430799.jpg"></p>
<p>哇，你个混蛋！上面给我抛出那么多问题，你现在又讲 <code>RocketMQ</code> ，还让不让人活了？！🤬</p>
<p>别急别急，话说你现在清楚 <code>MQ</code> 的构造吗，我还没讲呢，我们先搞明白 <code>MQ</code> 的内部构造，再来看看如何解决上面的一系列问题吧，不过你最好带着问题去阅读和了解喔。</p>
<p><code>RocketMQ</code> 是一个 <strong>队列模型</strong> 的消息中间件，具有<strong>高性能、高可靠、高实时、分布式</strong> 的特点。它是一个采用 <code>Java</code> 语言开发的分布式的消息系统，由阿里巴巴团队开发，在2016年底贡献给 <code>Apache</code>，成为了 <code>Apache</code> 的一个顶级项目。 在阿里内部，<code>RocketMQ</code> 很好地服务了集团大大小小上千个应用，在每年的双十一当天，更有不可思议的万亿级消息通过 <code>RocketMQ</code> 流转。</p>
<p>废话不多说，想要了解 <code>RocketMQ</code> 历史的同学可以自己去搜寻资料。听完上面的介绍，你只要知道 <code>RocketMQ</code> 很快、很牛、而且经历过双十一的实践就行了！</p>
<h2 id="队列模型和主题模型"><a href="#队列模型和主题模型" class="headerlink" title="队列模型和主题模型"></a>队列模型和主题模型</h2><p>在谈 <code>RocketMQ</code> 的技术架构之前，我们先来了解一下两个名词概念——<strong>队列模型</strong> 和 <strong>主题模型</strong> 。</p>
<p>首先我问一个问题，消息队列为什么要叫消息队列？</p>
<p>你可能觉得很弱智，这玩意不就是存放消息的队列嘛？不叫消息队列叫什么？</p>
<p>的确，早期的消息中间件是通过 <strong>队列</strong> 这一模型来实现的，可能是历史原因，我们都习惯把消息中间件成为消息队列。</p>
<p>但是，如今例如 <code>RocketMQ</code> 、<code>Kafka</code> 这些优秀的消息中间件不仅仅是通过一个 <strong>队列</strong> 来实现消息存储的。</p>
<h3 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h3><p>就像我们理解队列一样，消息中间件的队列模型就真的只是一个队列。。。我画一张图给大家理解。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3834ae653469.jpg"></p>
<p>在一开始我跟你提到了一个 <strong>“广播”</strong> 的概念，也就是说如果我们此时我们需要将一个消息发送给多个消费者(比如此时我需要将信息发送给短信系统和邮件系统)，这个时候单个队列即不能满足需求了。</p>
<p>当然你可以让 <code>Producer</code> 生产消息放入多个队列中，然后每个队列去对应每一个消费者。问题是可以解决，创建多个队列并且复制多份消息是会很影响资源和性能的。而且，这样子就会导致生产者需要知道具体消费者个数然后去复制对应数量的消息队列，这就违背我们消息中间件的 <strong>解耦</strong> 这一原则。</p>
<h3 id="主题模型"><a href="#主题模型" class="headerlink" title="主题模型"></a>主题模型</h3><p>那么有没有好的方法去解决这一个问题呢？有，那就是 <strong>主题模型</strong> 或者可以称为 <strong>发布订阅模型</strong> 。</p>
<blockquote>
<p>感兴趣的同学可以去了解一下设计模式里面的观察者模式并且手动实现一下，我相信你会有所收获的。</p>
</blockquote>
<p>在主题模型中，消息的生产者称为 <strong>发布者(Publisher)</strong> ，消息的消费者称为 <strong>订阅者(Subscriber)</strong> ，存放消息的容器称为 <strong>主题(Topic)</strong> 。</p>
<p>其中，发布者将消息发送到指定主题中，订阅者需要 <strong>提前订阅主题</strong> 才能接受特定主题的消息。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3837887d9a54sds.jpg"></p>
<h3 id="RocketMQ中的消息模型"><a href="#RocketMQ中的消息模型" class="headerlink" title="RocketMQ中的消息模型"></a>RocketMQ中的消息模型</h3><p><code>RockerMQ</code> 中的消息模型就是按照 <strong>主题模型</strong> 所实现的。你可能会好奇这个 <strong>主题</strong> 到底是怎么实现的呢？你上面也没有讲到呀！</p>
<p>其实对于主题模型的实现来说每个消息中间件的底层设计都是不一样的，就比如 <code>Kafka</code> 中的 <strong>分区</strong> ，<code>RocketMQ</code> 中的 <strong>队列</strong> ，<code>RabbitMQ</code> 中的 <code>Exchange</code> 。我们可以理解为 <strong>主题模型/发布订阅模型</strong> 就是一个标准，那些中间件只不过照着这个标准去实现而已。</p>
<p>所以，<code>RocketMQ</code> 中的 <strong>主题模型</strong> 到底是如何实现的呢？首先我画一张图，大家尝试着去理解一下。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef383d3e8c9788.jpg"></p>
<p>我们可以看到在整个图中有 <code>Producer Group</code> 、<code>Topic</code> 、<code>Consumer Group</code>  三个角色，我来分别介绍一下他们。</p>
<ul>
<li><code>Producer Group</code> 生产者组： 代表某一类的生产者，比如我们有多个秒杀系统作为生产者，这多个合在一起就是一个 <code>Producer Group</code> 生产者组，它们一般生产相同的消息。</li>
<li><code>Consumer Group</code> 消费者组： 代表某一类的消费者，比如我们有多个短信系统作为消费者，这多个合在一起就是一个 <code>Consumer Group</code> 消费者组，它们一般消费相同的消息。</li>
<li><code>Topic</code> 主题： 代表一类消息，比如订单消息，物流消息等等。</li>
</ul>
<p>你可以看到图中生产者组中的生产者会向主题发送消息，而 <strong>主题中存在多个队列</strong>，生产者每次生产消息之后是指定主题中的某个队列发送消息的。</p>
<p>每个主题中都有多个队列(分布在不同的 <code>Broker</code>中，如果是集群的话，<code>Broker</code>又分布在不同的服务器中)，集群消费模式下，一个消费者集群多台机器共同消费一个 <code>topic</code> 的多个队列，<strong>一个队列只会被一个消费者消费</strong>。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。就像上图中 <code>Consumer1</code> 和 <code>Consumer2</code> 分别对应着两个队列，而 <code>Consuer3</code> 是没有队列对应的，所以一般来讲要控制 <strong>消费者组中的消费者个数和主题中队列个数相同</strong> 。</p>
<p>当然也可以消费者个数小于队列个数，只不过不太建议。如下图。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3850c808d707.jpg"></p>
<p><strong>每个消费组在每个队列上维护一个消费位置</strong> ，为什么呢？</p>
<p>因为我们刚刚画的仅仅是一个消费者组，我们知道在发布订阅模式中一般会涉及到多个消费者组，而每个消费者组在每个队列中的消费位置都是不同的。如果此时有多个消费者组，那么消息被一个消费者组消费完之后是不会删除的(因为其它消费者组也需要呀)，它仅仅是为每个消费者组维护一个 <strong>消费位移(offset)</strong> ，每次消费者组消费完会返回一个成功的响应，然后队列再把维护的消费位移加一，这样就不会出现刚刚消费过的消息再一次被消费了。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3857fefaa079.jpg"></p>
<p>可能你还有一个问题，<strong>为什么一个主题中需要维护多个队列</strong> ？</p>
<p>答案是 <strong>提高并发能力</strong> 。的确，每个主题中只存在一个队列也是可行的。你想一下，如果每个主题中只存在一个队列，这个队列中也维护着每个消费者组的消费位置，这样也可以做到 <strong>发布订阅模式</strong> 。如下图。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38600cdb6d4b.jpg"></p>
<p>但是，这样我生产者是不是只能向一个队列发送消息？又因为需要维护消费位置所以一个队列只能对应一个消费者组中的消费者，这样是不是其他的 <code>Consumer</code> 就没有用武之地了？从这两个角度来讲，并发度一下子就小了很多。</p>
<p>所以总结来说，<code>RocketMQ</code> 通过<strong>使用在一个 <code>Topic</code> 中配置多个队列并且每个队列维护每个消费者组的消费位置</strong> 实现了 <strong>主题模式/发布订阅模式</strong> 。</p>
<h2 id="RocketMQ的架构图"><a href="#RocketMQ的架构图" class="headerlink" title="RocketMQ的架构图"></a>RocketMQ的架构图</h2><p>讲完了消息模型，我们理解起 <code>RocketMQ</code> 的技术架构起来就容易多了。</p>
<p><code>RocketMQ</code> 技术架构中有四大角色 <code>NameServer</code> 、<code>Broker</code> 、<code>Producer</code> 、<code>Consumer</code> 。我来向大家分别解释一下这四个角色是干啥的。</p>
<ul>
<li><p><code>Broker</code>： 主要负责消息的存储、投递和查询以及服务高可用保证。说白了就是消息队列服务器嘛，生产者生产消息到 <code>Broker</code> ，消费者从 <code>Broker</code> 拉取消息并消费。</p>
<p>这里，我还得普及一下关于 <code>Broker</code> 、<code>Topic</code> 和 队列的关系。上面我讲解了 <code>Topic</code> 和队列的关系——一个 <code>Topic</code> 中存在多个队列，那么这个 <code>Topic</code> 和队列存放在哪呢？</p>
<p><strong>一个 <code>Topic</code> 分布在多个 <code>Broker</code>上，一个 <code>Broker</code> 可以配置多个 <code>Topic</code> ，它们是多对多的关系</strong>。 </p>
<p>如果某个 <code>Topic</code> 消息量很大，应该给它多配置几个队列(上文中提到了提高并发能力)，并且 <strong>尽量多分布在不同 <code>Broker</code> 上，以减轻某个 <code>Broker</code> 的压力</strong> 。</p>
<p><code>Topic</code> 消息量都比较均匀的情况下，如果某个 <code>broker</code> 上的队列越多，则该 <code>broker</code> 压力越大。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38687488a5a4.jpg"></p>
<blockquote>
<p>所以说我们需要配置多个Broker。</p>
</blockquote>
</li>
<li><p><code>NameServer</code>： 不知道你们有没有接触过 <code>ZooKeeper</code> 和 <code>Spring Cloud</code> 中的 <code>Eureka</code> ，它其实也是一个 <strong>注册中心</strong> ，主要提供两个功能：<strong>Broker管理</strong> 和 <strong>路由信息管理</strong> 。说白了就是 <code>Broker</code> 会将自己的信息注册到 <code>NameServer</code> 中，此时 <code>NameServer</code> 就存放了很多 <code>Broker</code> 的信息(Broker的路由表)，消费者和生产者就从 <code>NameServer</code> 中获取路由表然后照着路由表的信息和对应的 <code>Broker</code> 进行通信(生产者和消费者定期会向 <code>NameServer</code> 去查询相关的 <code>Broker</code> 的信息)。</p>
</li>
<li><p><code>Producer</code>： 消息发布的角色，支持分布式集群方式部署。说白了就是生产者。</p>
</li>
<li><p><code>Consumer</code>： 消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制。说白了就是消费者。</p>
</li>
</ul>
<p>听完了上面的解释你可能会觉得，这玩意好简单。不就是这样的么？</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef386c6d1e8bdb.jpg"></p>
<p>嗯？你可能会发现一个问题，这老家伙 <code>NameServer</code> 干啥用的，这不多余吗？直接 <code>Producer</code> 、<code>Consumer</code> 和 <code>Broker</code> 直接进行生产消息，消费消息不就好了么？</p>
<p>但是，我们上文提到过 <code>Broker</code> 是需要保证高可用的，如果整个系统仅仅靠着一个 <code>Broker</code> 来维持的话，那么这个 <code>Broker</code> 的压力会不会很大？所以我们需要使用多个 <code>Broker</code> 来保证 <strong>负载均衡</strong> 。</p>
<p>如果说，我们的消费者和生产者直接和多个 <code>Broker</code> 相连，那么当 <code>Broker</code> 修改的时候必定会牵连着每个生产者和消费者，这样就会产生耦合问题，而 <code>NameServer</code> 注册中心就是用来解决这个问题的。</p>
<blockquote>
<p>如果还不是很理解的话，可以去看我介绍 <code>Spring Cloud</code> 的那篇文章，其中介绍了 <code>Eureka</code> 注册中心。</p>
</blockquote>
<p>当然，<code>RocketMQ</code> 中的技术架构肯定不止前面那么简单，因为上面图中的四个角色都是需要做集群的。我给出一张官网的架构图，大家尝试理解一下。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef386fa3be1e53.jpg"></p>
<p>其实和我们最开始画的那张乞丐版的架构图也没什么区别，主要是一些细节上的差别。听我细细道来🤨。</p>
<p>第一、我们的 <code>Broker</code> <strong>做了集群并且还进行了主从部署</strong> ，由于消息分布在各个 <code>Broker</code> 上，一旦某个 <code>Broker</code> 宕机，则该<code>Broker</code> 上的消息读写都会受到影响。所以 <code>Rocketmq</code> 提供了 <code>master/slave</code> 的结构，<code> salve</code> 定时从 <code>master</code> 同步数据(同步刷盘或者异步刷盘)，如果 <code>master</code> 宕机，<strong>则 <code>slave</code> 提供消费服务，但是不能写入消息</strong> (后面我还会提到哦)。</p>
<p>第二、为了保证 <code>HA</code> ，我们的 <code>NameServer</code> 也做了集群部署，但是请注意它是 <strong>去中心化</strong> 的。也就意味着它没有主节点，你可以很明显地看出 <code>NameServer</code> 的所有节点是没有进行 <code>Info Replicate</code> 的，在 <code>RocketMQ</code> 中是通过 <strong>单个Broker和所有NameServer保持长连接</strong> ，并且在每隔30秒 <code>Broker</code> 会向所有 <code>Nameserver</code> 发送心跳，心跳包含了自身的 <code>Topic</code> 配置信息，这个步骤就对应这上面的 <code>Routing Info</code> 。</p>
<p>第三、在生产者需要向 <code>Broker</code> 发送消息的时候，<strong>需要先从 <code>NameServer</code> 获取关于 <code>Broker</code> 的路由信息</strong>，然后通过 <strong>轮询</strong> 的方法去向每个队列中生产数据以达到 <strong>负载均衡</strong> 的效果。</p>
<p>第四、消费者通过 <code>NameServer</code> 获取所有 <code>Broker</code> 的路由信息后，向 <code>Broker</code> 发送 <code>Pull</code> 请求来获取消息数据。<code>Consumer</code> 可以以两种模式启动—— <strong>广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p>
<h2 id="如何解决-顺序消费、重复消费"><a href="#如何解决-顺序消费、重复消费" class="headerlink" title="如何解决 顺序消费、重复消费"></a>如何解决 顺序消费、重复消费</h2><p>其实，这些东西都是我在介绍消息队列带来的一些副作用的时候提到的，也就是说，这些问题不仅仅挂钩于 <code>RocketMQ</code> ，而是应该每个消息中间件都需要去解决的。</p>
<p>在上面我介绍 <code>RocketMQ</code> 的技术架构的时候我已经向你展示了 <strong>它是如何保证高可用的</strong> ，这里不涉及运维方面的搭建，如果你感兴趣可以自己去官网上照着例子搭建属于你自己的 <code>RocketMQ</code> 集群。</p>
<blockquote>
<p>其实 <code>Kafka</code> 的架构基本和 <code>RocketMQ</code> 类似，只是它注册中心使用了 <code>Zookeeper</code> 、它的 <strong>分区</strong> 就相当于 <code>RocketMQ</code> 中的 <strong>队列</strong> 。还有一些小细节不同会在后面提到。</p>
</blockquote>
<h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><p>在上面的技术架构介绍中，我们已经知道了 <strong><code>RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序</strong> 的。</p>
<p>这又扯到两个概念——<strong>普通顺序</strong> 和 <strong>严格顺序</strong> 。</p>
<p>所谓普通顺序是指 消费者通过 <strong>同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code>Broker</code> <strong>重启情况下不会保证消息顺序性</strong> (短暂时间) 。</p>
<p>所谓严格顺序是指  消费者收到的 <strong>所有消息</strong> 均是有顺序的。严格顺序消息 <strong>即使在异常情况下也会保证消息的顺序性</strong> 。</p>
<p>但是，严格顺序看起来虽好，实现它可会付出巨大的代价。如果你使用严格顺序模式，<code>Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。你还用啥？现在主要场景也就在 <code>binlog</code> 同步。</p>
<p>一般而言，我们的 <code>MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p>
<p>那么，我们现在使用了 <strong>普通顺序模式</strong> ，我们从上面学习知道了在 <code>Producer</code> 生产消息的时候会进行轮询(取决你的负载均衡策略)来向同一主题的不同消息队列发送消息。那么如果此时我有几个消息分别是同一个订单的创建、支付、发货，在轮询的策略下这 <strong>三个消息会被发送到不同队列</strong> ，因为在不同的队列此时就无法使用 <code>RocketMQ</code> 带来的队列有序特性来保证消息有序性了。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3874585e096e.jpg"></p>
<p>那么，怎么解决呢？</p>
<p>其实很简单，我们需要处理的仅仅是将同一语义下的消息放入同一个队列(比如这里是同一个订单)，那我们就可以使用 <strong>Hash取模法</strong> 来保证同一个订单在同一个队列中就行了。</p>
<h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p>emmm，就两个字—— <strong>幂等</strong> 。在编程中一个<em>幂等</em> 操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。比如说，这个时候我们有一个订单的处理积分的系统，每当来一个消息的时候它就负责为创建这个订单的用户的积分加上相应的数值。可是有一次，消息队列发送给订单系统 FrancisQ 的订单信息，其要求是给 FrancisQ 的积分加上 500。但是积分系统在收到 FrancisQ 的订单信息处理完成之后返回给消息队列处理成功的信息的时候出现了网络波动(当然还有很多种情况，比如Broker意外重启等等)，这条回应没有发送成功。</p>
<p>那么，消息队列没收到积分系统的回应会不会尝试重发这个消息？问题就来了，我再发这个消息，万一它又给 FrancisQ 的账户加上 500 积分怎么办呢？</p>
<p>所以我们需要给我们的消费者实现 <strong>幂等</strong> ，也就是对同一个消息的处理结果，执行多少次都不变。</p>
<p>那么如何给业务实现幂等呢？这个还是需要结合具体的业务的。你可以使用 <strong>写入 <code>Redis</code></strong> 来保证，因为 <code>Redis</code> 的 <code>key</code> 和 <code>value</code> 就是天然支持幂等的。当然还有使用 <strong>数据库插入法</strong> ，基于数据库的唯一键来保证重复数据不会被插入多条。</p>
<p>不过最主要的还是需要 <strong>根据特定场景使用特定的解决方案</strong> ，你要知道你的消息消费是否是完全不可重复消费还是可以忍受重复消费的，然后再选择强校验和弱校验的方式。毕竟在 CS 领域还是很少有技术银弹的说法。</p>
<p>而在整个互联网领域，幂等不仅仅适用于消息队列的重复消费问题，这些实现幂等的方法，也同样适用于，<strong>在其他场景中来解决重复请求或者重复调用的问题</strong> 。比如将HTTP服务设计成幂等的，<strong>解决前端或者APP重复提交表单数据的问题</strong> ，也可以将一个微服务设计成幂等的，解决 <code>RPC</code> 框架自动重试导致的 <strong>重复调用问题</strong> 。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>如何解释分布式事务呢？事务大家都知道吧？<strong>要么都执行要么都不执行</strong> 。在同一个系统中我们可以轻松地实现事务，但是在分布式架构中，我们有很多服务是部署在不同系统之间的，而不同服务之间又需要进行调用。比如此时我下订单然后增加积分，如果保证不了分布式事务的话，就会出现A系统下了订单，但是B系统增加积分失败或者A系统没有下订单，B系统却增加了积分。前者对用户不友好，后者对运营商不利，这是我们都不愿意见到的。</p>
<p>那么，如何去解决这个问题呢？</p>
<p>如今比较常见的分布式事务实现有 2PC、TCC 和事务消息(half 半消息机制)。每一种实现都有其特定的使用场景，但是也有各自的问题，<strong>都不是完美的解决方案</strong>。</p>
<p>在 <code>RocketMQ</code> 中使用的是 <strong>事务消息加上事务反查机制</strong> 来解决分布式事务问题的。我画了张图，大家可以对照着图进行理解。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38798d7a987f.png"></p>
<p>在第一步发送的 half 消息 ，它的意思是 <strong>在事务提交之前，对于消费者来说，这个消息是不可见的</strong> 。</p>
<blockquote>
<p>那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后 <strong>改变主题</strong> 为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，<strong>然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费</strong>，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>
</blockquote>
<p>你可以试想一下，如果没有从第5步开始的 <strong>事务反查机制</strong> ，如果出现网路波动第4步没有发送成功，这样就会产生 MQ 不知道是不是需要给消费者消费的问题，他就像一个无头苍蝇一样。在 <code>RocketMQ</code> 中就是使用的上述的事务反查来解决的，而在 <code>Kafka</code> 中通常是直接抛出一个异常让用户来自行解决。</p>
<p>你还需要注意的是，在 <code>MQ Server</code> 指向系统B的操作已经和系统A不相关了，也就是说在消息队列中的分布式事务是——<strong>本地事务和存储消息到消息队列才是同一个事务</strong>。这样也就产生了事务的<strong>最终一致性</strong>，因为整个过程是异步的，<strong>每个系统只要保证它自己那一部分的事务就行了</strong>。</p>
<h2 id="消息堆积问题"><a href="#消息堆积问题" class="headerlink" title="消息堆积问题"></a>消息堆积问题</h2><p>在上面我们提到了消息队列一个很重要的功能——<strong>削峰</strong> 。那么如果这个峰值太大了导致消息堆积在队列中怎么办呢？</p>
<p>其实这个问题可以将它广义化，因为产生消息堆积的根源其实就只有两个——生产者生产太快或者消费者消费太慢。</p>
<p>我们可以从多个角度去思考解决这个问题，当流量到峰值的时候是因为生产者生产太快，我们可以使用一些 <strong>限流降级</strong> 的方法，当然你也可以增加多个消费者实例去水平扩展增加消费能力来匹配生产的激增。如果消费者消费过慢的话，我们可以先检查 <strong>是否是消费者出现了大量的消费错误</strong> ，或者打印一下日志查看是否是哪一个线程卡死，出现了锁资源不释放等等的问题。</p>
<blockquote>
<p>当然，最快速解决消息堆积问题的方法还是增加消费者实例，不过 <strong>同时你还需要增加每个主题的队列数量</strong> 。</p>
<p>别忘了在 <code>RocketMQ</code> 中，<strong>一个队列只会被一个消费者消费</strong> ，如果你仅仅是增加消费者实例就会出现我一开始给你画架构图的那种情况。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef387d939ab66d.jpg"></p>
<h2 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h2><p>回溯消费是指 <code>Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费，在<code>RocketMQ</code> 中， <code>Broker</code> 在向<code>Consumer</code> 投递成功消息后，<strong>消息仍然需要保留</strong> 。并且重新消费一般是按照时间维度，例如由于 <code>Consumer</code> 系统故障，恢复后需要重新消费1小时前的数据，那么 <code>Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。<code>RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p>
<p>这是官方文档的解释，我直接照搬过来就当科普了😁😁😁。</p>
<h2 id="RocketMQ-的刷盘机制"><a href="#RocketMQ-的刷盘机制" class="headerlink" title="RocketMQ 的刷盘机制"></a>RocketMQ 的刷盘机制</h2><p>上面我讲了那么多的 <code>RocketMQ</code> 的架构和设计原理，你有没有好奇</p>
<p>在 <code>Topic</code> 中的 <strong>队列是以什么样的形式存在的？</strong></p>
<p><strong>队列中的消息又是如何进行存储持久化的呢？</strong></p>
<p>我在上文中提到的 <strong>同步刷盘</strong> 和 <strong>异步刷盘</strong> 又是什么呢？它们会给持久化带来什么样的影响呢？</p>
<p>下面我将给你们一一解释。</p>
<h3 id="同步刷盘和异步刷盘"><a href="#同步刷盘和异步刷盘" class="headerlink" title="同步刷盘和异步刷盘"></a>同步刷盘和异步刷盘</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef387fba311cda.jpg"></p>
<p>如上图所示，在同步刷盘中需要等待一个刷盘成功的 <code>ACK</code> ，同步刷盘对 <code>MQ</code> 消息可靠性来说是一种不错的保障，但是 <strong>性能上会有较大影响</strong> ，一般地适用于金融等特定业务场景。</p>
<p>而异步刷盘往往是开启一个线程去异步地执行刷盘操作。消息刷盘采用后台异步线程提交的方式进行， <strong>降低了读写延迟</strong> ，提高了 <code>MQ</code> 的性能和吞吐量，一般适用于如发验证码等对于消息保证要求不太高的业务场景。</p>
<p>一般地，<strong>异步刷盘只有在 <code>Broker</code> 意外宕机的时候会丢失部分数据</strong>，你可以设置 <code>Broker</code> 的参数 <code>FlushDiskType</code> 来调整你的刷盘策略(ASYNC_FLUSH 或者 SYNC_FLUSH)。</p>
<h3 id="同步复制和异步复制"><a href="#同步复制和异步复制" class="headerlink" title="同步复制和异步复制"></a>同步复制和异步复制</h3><p>上面的同步刷盘和异步刷盘是在单个结点层面的，而同步复制和异步复制主要是指的 <code>Borker</code> 主从模式下，主节点返回消息给客户端的时候是否需要同步从节点。</p>
<ul>
<li>同步复制： 也叫 “同步双写”，也就是说，<strong>只有消息同步双写到主从结点上时才返回写入成功</strong> 。</li>
<li>异步复制： <strong>消息写入主节点之后就直接返回写入成功</strong> 。</li>
</ul>
<p>然而，很多事情是没有完美的方案的，就比如我们进行消息写入的节点越多就更能保证消息的可靠性，但是随之的性能也会下降，所以需要程序员根据特定业务场景去选择适应的主从复制方案。</p>
<p>那么，<strong>异步复制会不会也像异步刷盘那样影响消息的可靠性呢？</strong></p>
<p>答案是不会的，因为两者就是不同的概念，对于消息可靠性是通过不同的刷盘策略保证的，而像异步同步复制策略仅仅是影响到了 <strong>可用性</strong> 。为什么呢？其主要原因<strong>是 <code>RocketMQ</code> 是不支持自动主从切换的，当主节点挂掉之后，生产者就不能再给这个主节点生产消息了</strong>。</p>
<p>比如这个时候采用异步复制的方式，在主节点还未发送完需要同步的消息的时候主节点挂掉了，这个时候从节点就少了一部分消息。但是此时生产者无法再给主节点生产消息了，<strong>消费者可以自动切换到从节点进行消费</strong>(仅仅是消费)，所以在主节点挂掉的时间只会产生主从结点短暂的消息不一致的情况，降低了可用性，而当主节点重启之后，从节点那部分未来得及复制的消息还会继续复制。</p>
<p>在单主从架构中，如果一个主节点挂掉了，那么也就意味着整个系统不能再生产了。那么这个可用性的问题能否解决呢？<strong>一个主从不行那就多个主从的呗</strong>，别忘了在我们最初的架构图中，每个 <code>Topic</code> 是分布在不同 <code>Broker</code> 中的。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef38687488a5a4.jpg"></p>
<p>但是这种复制方式同样也会带来一个问题，那就是无法保证 <strong>严格顺序</strong> 。在上文中我们提到了如何保证的消息顺序性是通过将一个语义的消息发送在同一个队列中，使用 <code>Topic</code> 下的队列来保证顺序性的。如果此时我们主节点A负责的是订单A的一系列语义消息，然后它挂了，这样其他节点是无法代替主节点A的，如果我们任意节点都可以存入任何消息，那就没有顺序性可言了。</p>
<p>而在 <code>RocketMQ</code> 中采用了 <code>Dledger</code> 解决这个问题。他要求在写入消息的时候，要求<strong>至少消息复制到半数以上的节点之后</strong>，才给客⼾端返回写⼊成功，并且它是⽀持通过选举来动态切换主节点的。这里我就不展开说明了，读者可以自己去了解。</p>
<blockquote>
<p>也不是说 <code>Dledger</code> 是个完美的方案，至少在 <code>Dledger</code> 选举过程中是无法提供服务的，而且他必须要使用三个节点或以上，如果多数节点同时挂掉他也是无法保证可用性的，而且要求消息复制板书以上节点的效率和直接异步复制还是有一定的差距的。</p>
</blockquote>
<h3 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h3><p>还记得上面我们一开始的三个问题吗？到这里第三个问题已经解决了。</p>
<p>但是，在 <code>Topic</code> 中的 <strong>队列是以什么样的形式存在的？队列中的消息又是如何进行存储持久化的呢？</strong> 还未解决，其实这里涉及到了 <code>RocketMQ</code> 是如何设计它的存储结构了。我首先想大家介绍 <code>RocketMQ</code> 消息存储架构中的三大角色——<code>CommitLog</code> 、<code>ConsumeQueue</code> 和 <code>IndexFile</code> 。</p>
<ul>
<li><code>CommitLog</code>： <strong>消息主体以及元数据的存储主体</strong>，存储 <code>Producer</code> 端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是<strong>顺序写入日志文件</strong>，当文件满了，写入下一个文件。</li>
<li><code>ConsumeQueue</code>： 消息消费队列，<strong>引入的目的主要是提高消息消费的性能</strong>(我们再前面也讲了)，由于<code>RocketMQ</code> 是基于主题 <code>Topic</code> 的订阅模式，消息消费是针对主题进行的，如果要遍历 <code>commitlog</code> 文件中根据 <code>Topic</code> 检索消息是非常低效的。<code>Consumer</code> 即可根据 <code>ConsumeQueue</code> 来查找待消费的消息。其中，<code>ConsumeQueue</code>（逻辑消费队列）<strong>作为消费消息的索引</strong>，保存了指定 <code>Topic</code> 下的队列消息在 <code>CommitLog</code> 中的<strong>起始物理偏移量 <code>offset</code> <strong>，消息大小 <code>size</code> 和消息 <code>Tag</code> 的 <code>HashCode</code> 值。</strong><code>consumequeue</code> 文件可以看成是基于 <code>topic</code> 的 <code>commitlog</code> 索引文件</strong>，故 <code>consumequeue</code> 文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样 <code>consumequeue</code> 文件采取定长设计，每一个条目共20个字节，分别为8字节的 <code>commitlog</code> 物理偏移量、4字节的消息长度、8字节tag <code>hashcode</code>，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个 <code>ConsumeQueue</code>文件大小约5.72M；</li>
<li><code>IndexFile</code>： <code>IndexFile</code>（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。这里只做科普不做详细介绍。</li>
</ul>
<p>总结来说，整个消息存储的结构，最主要的就是 <code>CommitLoq</code> 和 <code>ConsumeQueue</code> 。而 <code>ConsumeQueue</code> 你可以大概理解为 <code>Topic</code> 中的队列。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef3884c02acc72.png"></p>
<p><code>RocketMQ</code> 采用的是 <strong>混合型的存储结构</strong> ，即为 <code>Broker</code> 单个实例下所有的队列共用一个日志数据文件来存储消息。有意思的是在同样高并发的 <code>Kafka</code> 中会为每个 <code>Topic</code> 分配一个存储文件。这就有点类似于我们有一大堆书需要装上书架，<code>RockeMQ</code> 是不分书的种类直接成批的塞上去的，而 <code>Kafka</code> 是将书本放入指定的分类区域的。</p>
<p>而 <code>RocketMQ</code> 为什么要这么做呢？原因是 <strong>提高数据的写入效率</strong> ，不分 <code>Topic</code> 意味着我们有更大的几率获取 <strong>成批</strong> 的消息进行数据写入，但也会带来一个麻烦就是读取消息的时候需要遍历整个大文件，这是非常耗时的。</p>
<p>所以，在 <code>RocketMQ</code> 中又使用了 <code>ConsumeQueue</code> 作为每个队列的索引文件来 <strong>提升读取消息的效率</strong>。我们可以直接根据队列的消息序号，计算出索引的全局位置（索引序号*索引固定⻓度20），然后直接读取这条索引，再根据索引中记录的消息的全局位置，找到消息。</p>
<p>讲到这里，你可能对 <code>RockeMQ</code> 的存储架构还有些模糊，没事，我们结合着图来理解一下。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/16ef388763c25c62.jpg"></p>
<p>emmm，是不是有一点复杂🤣，看英文图片和英文文档的时候就不要怂，硬着头皮往下看就行。</p>
<blockquote>
<p>如果上面没看懂的读者一定要认真看下面的流程分析！</p>
</blockquote>
<p>首先，在最上面的那一块就是我刚刚讲的你现在可以直接 **把 <code>ConsumerQueue</code> 理解为 <code>Queue</code>**。</p>
<p>在图中最左边说明了 <font color = red>红色方块 </font> 代表被写入的消息，虚线方块代表等待被写入的。左边的生产者发送消息会指定 <code>Topic</code> 、<code>QueueId</code> 和具体消息内容，而在 <code>Broker</code> 中管你是哪门子消息，他直接 **全部顺序存储到了 CommitLog **。而根据生产者指定的 <code>Topic</code> 和 <code>QueueId</code> 将这条消息本身在 <code>CommitLog</code> 的偏移(offset)，消息本身大小，和tag的hash值存入对应的 <code>ConsumeQueue</code> 索引文件中。而在每个队列中都保存了 <code>ConsumeOffset</code> 即每个消费者组的消费位置(我在架构那里提到了，忘了的同学可以回去看一下)，而消费者拉取消息进行消费的时候只需要根据 <code>ConsumeOffset</code> 获取下一个未被消费的消息就行了。</p>
<p>上述就是我对于整个消息存储架构的大概理解(这里不涉及到一些细节讨论，比如稀疏索引等等问题)，希望对你有帮助。</p>
<p>因为有一个知识点因为写嗨了忘讲了，想想在哪里加也不好，所以我留给大家去思考🤔🤔一下吧。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/e314ee45gy1g05zgr67bbj20gp0b3aba.jpg"></p>
<p>为什么 <code>CommitLog</code> 文件要设计成固定大小的长度呢？提醒：<strong>内存映射机制</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总算把这篇博客写完了。我讲的你们还记得吗😅？</p>
<p>这篇文章中我主要想大家介绍了</p>
<ol>
<li>消息队列出现的原因</li>
<li>消息队列的作用(异步，解耦，削峰)</li>
<li>消息队列带来的一系列问题(消息堆积、重复消费、顺序消费、分布式事务等等)</li>
<li>消息队列的两种消息模型——队列和主题模式</li>
<li>分析了 <code>RocketMQ</code> 的技术架构(<code>NameServer</code> 、<code>Broker</code> 、<code>Producer</code> 、<code>Comsumer</code>)</li>
<li>结合 <code>RocketMQ</code> 回答了消息队列副作用的解决方案</li>
<li>介绍了 <code>RocketMQ</code> 的存储机制和刷盘策略。</li>
</ol>
<p>等等。。。</p>
<blockquote>
<p>如果喜欢可以点赞哟👍👍👍。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/distributed-system/message-queue/RocketMQ/" data-id="cks75dy6g000t7kve73w54jic" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/distributed-system/message-queue/RocketMQ-Questions" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/distributed-system/message-queue/RocketMQ-Questions/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:46.985Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文来自读者 <a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/pull/291">PR</a>。</p>
<!-- TOC -->

<ul>
<li><a href="#1-%E5%8D%95%E6%9C%BA%E7%89%88%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83">1 单机版消息中心</a></li>
<li><a href="#2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E4%B8%AD%E5%BF%83">2 分布式消息中心</a><ul>
<li><a href="#21-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3">2.1 问题与解决</a><ul>
<li><a href="#211-%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%97%AE%E9%A2%98">2.1.1 消息丢失的问题</a></li>
<li><a href="#212-%E5%90%8C%E6%AD%A5%E8%90%BD%E7%9B%98%E6%80%8E%E4%B9%88%E6%89%8D%E8%83%BD%E5%BF%AB">2.1.2 同步落盘怎么才能快</a></li>
<li><a href="#213-%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E7%9A%84%E9%97%AE%E9%A2%98">2.1.3 消息堆积的问题</a></li>
<li><a href="#214-%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0">2.1.4 定时消息的实现</a></li>
<li><a href="#215-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0">2.1.5 顺序消息的实现</a></li>
<li><a href="#216-%E5%88%86%E5%B8%83%E5%BC%8F%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9E%E7%8E%B0">2.1.6 分布式消息的实现</a></li>
<li><a href="#217-%E6%B6%88%E6%81%AF%E7%9A%84-push-%E5%AE%9E%E7%8E%B0">2.1.7 消息的 push 实现</a></li>
<li><a href="#218-%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81%E7%9A%84%E9%81%BF%E5%85%8D">2.1.8 消息重复发送的避免</a></li>
<li><a href="#219-%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9%E4%B8%8E%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9">2.1.9 广播消费与集群消费</a></li>
<li><a href="#2110-rocketmq-%E4%B8%8D%E4%BD%BF%E7%94%A8-zookeeper-%E4%BD%9C%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%BB%A5%E5%8F%8A%E8%87%AA%E5%88%B6%E7%9A%84-nameserver-%E4%BC%98%E7%BC%BA%E7%82%B9">2.1.10 RocketMQ 不使用 ZooKeeper 作为注册中心的原因，以及自制的 NameServer 优缺点？</a></li>
<li><a href="#2111-%E5%85%B6%E5%AE%83">2.1.11 其它</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E5%8F%82%E8%80%83">3 参考</a></li>
</ul>
<!-- TOC -->

<h1 id="1-单机版消息中心"><a href="#1-单机版消息中心" class="headerlink" title="1 单机版消息中心"></a>1 单机版消息中心</h1><p>一个消息中心，最基本的需要支持多生产者、多消费者，例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scratch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实际中会有 nameserver 服务来找到 broker 具体位置以及 broker 主从信息</span></span><br><span class="line">        Broker broker = <span class="keyword">new</span> Broker();</span><br><span class="line">        Producer producer1 = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer1.connectBroker(broker);</span><br><span class="line">        Producer producer2 = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer2.connectBroker(broker);</span><br><span class="line"></span><br><span class="line">        Consumer consumer1 = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer1.connectBroker(broker);</span><br><span class="line">        Consumer consumer2 = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer2.connectBroker(broker);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            producer1.asyncSendMsg(<span class="string">&quot;producer1 send msg&quot;</span> + i);</span><br><span class="line">            producer2.asyncSendMsg(<span class="string">&quot;producer2 send msg&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;broker has msg:&quot;</span> + broker.getAllMagByDisk());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;consumer1 consume msg：&quot;</span> + consumer1.syncPullMsg());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;consumer2 consume msg：&quot;</span> + consumer2.syncPullMsg());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Broker broker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectBroker</span><span class="params">(Broker broker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.broker = broker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncSendMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (broker == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;please connect broker first&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            broker.sendMsg(msg);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Broker broker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectBroker</span><span class="params">(Broker broker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.broker = broker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">syncPullMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> broker.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Broker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应 RocketMQ 中 MessageQueue，默认情况下 1 个 Topic 包含 4 个 MessageQueue</span></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;String&gt; messageQueue = <span class="keyword">new</span> LinkedBlockingQueue(Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际发送消息到 broker 服务器使用 Netty 发送</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            messageQueue.put(msg);</span><br><span class="line">            <span class="comment">// 实际会同步或异步落盘，异步落盘使用的定时任务定时扫描落盘</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> messageQueue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAllMagByDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        messageQueue.iterator().forEachRemaining((msg) -&gt; &#123;</span><br><span class="line">            sb.append(msg + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：  </p>
<ol>
<li>没有实现真正执行消息存储落盘</li>
<li>没有实现 NameServer 去作为注册中心，定位服务</li>
<li>使用 LinkedBlockingQueue 作为消息队列，注意，参数是无限大，在真正 RocketMQ 也是如此是无限大，理论上不会出现对进来的数据进行抛弃，但是会有内存泄漏问题（阿里巴巴开发手册也因为这个问题，建议我们使用自制线程池）  </li>
<li>没有使用多个队列（即多个 LinkedBlockingQueue），RocketMQ 的顺序消息是通过生产者和消费者同时使用同一个 MessageQueue 来实现，但是如果我们只有一个 MessageQueue，那我们天然就支持顺序消息</li>
<li>没有使用 MappedByteBuffer 来实现文件映射从而使消息数据落盘非常的快（实际 RocketMQ 使用的是 FileChannel+DirectBuffer）</li>
</ol>
<h1 id="2-分布式消息中心"><a href="#2-分布式消息中心" class="headerlink" title="2 分布式消息中心"></a>2 分布式消息中心</h1><h2 id="2-1-问题与解决"><a href="#2-1-问题与解决" class="headerlink" title="2.1 问题与解决"></a>2.1 问题与解决</h2><h3 id="2-1-1-消息丢失的问题"><a href="#2-1-1-消息丢失的问题" class="headerlink" title="2.1.1 消息丢失的问题"></a>2.1.1 消息丢失的问题</h3><ol>
<li>当你系统需要保证百分百消息不丢失，你可以使用生产者每发送一个消息，Broker 同步返回一个消息发送成功的反馈消息</li>
<li>即每发送一个消息，同步落盘后才返回生产者消息发送成功，这样只要生产者得到了消息发送生成的返回，事后除了硬盘损坏，都可以保证不会消息丢失</li>
<li>但是这同时引入了一个问题，同步落盘怎么才能快？</li>
</ol>
<h3 id="2-1-2-同步落盘怎么才能快"><a href="#2-1-2-同步落盘怎么才能快" class="headerlink" title="2.1.2 同步落盘怎么才能快"></a>2.1.2 同步落盘怎么才能快</h3><ol>
<li>使用 FileChannel + DirectBuffer 池，使用堆外内存，加快内存拷贝  </li>
<li>使用数据和索引分离，当消息需要写入时，使用 commitlog 文件顺序写，当需要定位某个消息时，查询index 文件来定位，从而减少文件IO随机读写的性能损耗</li>
</ol>
<h3 id="2-1-3-消息堆积的问题"><a href="#2-1-3-消息堆积的问题" class="headerlink" title="2.1.3 消息堆积的问题"></a>2.1.3 消息堆积的问题</h3><ol>
<li>后台定时任务每隔72小时，删除旧的没有使用过的消息信息  </li>
<li>根据不同的业务实现不同的丢弃任务，具体参考线程池的 AbortPolicy，例如FIFO/LRU等（RocketMQ没有此策略）  </li>
<li>消息定时转移，或者对某些重要的 TAG 型（支付型）消息真正落库</li>
</ol>
<h3 id="2-1-4-定时消息的实现"><a href="#2-1-4-定时消息的实现" class="headerlink" title="2.1.4 定时消息的实现"></a>2.1.4 定时消息的实现</h3><ol>
<li>实际 RocketMQ 没有实现任意精度的定时消息，它只支持某些特定的时间精度的定时消息</li>
<li>实现定时消息的原理是：创建特定时间精度的 MessageQueue，例如生产者需要定时1s之后被消费者消费，你只需要将此消息发送到特定的 Topic，例如：MessageQueue-1 表示这个 MessageQueue 里面的消息都会延迟一秒被消费，然后 Broker 会在 1s 后发送到消费者消费此消息，使用 newSingleThreadScheduledExecutor 实现</li>
</ol>
<h3 id="2-1-5-顺序消息的实现"><a href="#2-1-5-顺序消息的实现" class="headerlink" title="2.1.5 顺序消息的实现"></a>2.1.5 顺序消息的实现</h3><ol>
<li>与定时消息同原理，生产者生产消息时指定特定的 MessageQueue ，消费者消费消息时，消费特定的 MessageQueue，其实单机版的消息中心在一个 MessageQueue 就天然支持了顺序消息</li>
<li>注意：同一个 MessageQueue 保证里面的消息是顺序消费的前提是：消费者是串行的消费该 MessageQueue，因为就算 MessageQueue 是顺序的，但是当并行消费时，还是会有顺序问题，但是串行消费也同时引入了两个问题：<blockquote>
<ol>
<li>引入锁来实现串行</li>
<li>前一个消费阻塞时后面都会被阻塞</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="2-1-6-分布式消息的实现"><a href="#2-1-6-分布式消息的实现" class="headerlink" title="2.1.6 分布式消息的实现"></a>2.1.6 分布式消息的实现</h3><ol>
<li>需要前置知识：2PC  </li>
<li>RocketMQ4.3 起支持，原理为2PC，即两阶段提交，prepared-&gt;commit/rollback</li>
<li>生产者发送事务消息，假设该事务消息 Topic 为 Topic1-Trans，Broker 得到后首先更改该消息的 Topic 为 Topic1-Prepared，该 Topic1-Prepared 对消费者不可见。然后定时回调生产者的本地事务A执行状态，根据本地事务A执行状态，来是否将该消息修改为 Topic1-Commit 或 Topic1-Rollback，消费者就可以正常找到该事务消息或者不执行等</li>
</ol>
<blockquote>
<p>注意，就算是事务消息最后回滚了也不会物理删除，只会逻辑删除该消息</p>
</blockquote>
<h3 id="2-1-7-消息的-push-实现"><a href="#2-1-7-消息的-push-实现" class="headerlink" title="2.1.7 消息的 push 实现"></a>2.1.7 消息的 push 实现</h3><ol>
<li>注意，RocketMQ 已经说了自己会有低延迟问题，其中就包括这个消息的 push 延迟问题</li>
<li>因为这并不是真正的将消息主动的推送到消费者，而是 Broker 定时任务每5s将消息推送到消费者</li>
<li>pull模式需要我们手动调用consumer拉消息，而push模式则只需要我们提供一个listener即可实现对消息的监听，而实际上，RocketMQ的push模式是基于pull模式实现的，它没有实现真正的push。</li>
<li>push方式里，consumer把轮询过程封装了，并注册MessageListener监听器，取到消息后，唤醒MessageListener的consumeMessage()来消费，对用户而言，感觉消息是被推送过来的。</li>
</ol>
<h3 id="2-1-8-消息重复发送的避免"><a href="#2-1-8-消息重复发送的避免" class="headerlink" title="2.1.8 消息重复发送的避免"></a>2.1.8 消息重复发送的避免</h3><ol>
<li>RocketMQ 会出现消息重复发送的问题，因为在网络延迟的情况下，这种问题不可避免的发生，如果非要实现消息不可重复发送，那基本太难，因为网络环境无法预知，还会使程序复杂度加大，因此默认允许消息重复发送</li>
<li>RocketMQ 让使用者在消费者端去解决该问题，即需要消费者端在消费消息时支持幂等性的去消费消息</li>
<li>最简单的解决方案是每条消费记录有个消费状态字段，根据这个消费状态字段来是否消费或者使用一个集中式的表，来存储所有消息的消费状态，从而避免重复消费</li>
<li>具体实现可以查询关于消息幂等消费的解决方案</li>
</ol>
<h3 id="2-1-9-广播消费与集群消费"><a href="#2-1-9-广播消费与集群消费" class="headerlink" title="2.1.9 广播消费与集群消费"></a>2.1.9 广播消费与集群消费</h3><ol>
<li>消息消费区别：广播消费，订阅该 Topic 的消息者们都会消费<strong>每个</strong>消息。集群消费，订阅该 Topic 的消息者们只会有一个去消费<strong>某个</strong>消息</li>
<li>消息落盘区别：具体表现在消息消费进度的保存上。广播消费，由于每个消费者都独立的去消费每个消息，因此每个消费者各自保存自己的消息消费进度。而集群消费下，订阅了某个 Topic，而旗下又有多个 MessageQueue，每个消费者都可能会去消费不同的 MessageQueue，因此总体的消费进度保存在 Broker 上集中的管理</li>
</ol>
<h3 id="2-1-10-RocketMQ-不使用-ZooKeeper-作为注册中心的原因，以及自制的-NameServer-优缺点？"><a href="#2-1-10-RocketMQ-不使用-ZooKeeper-作为注册中心的原因，以及自制的-NameServer-优缺点？" class="headerlink" title="2.1.10 RocketMQ 不使用 ZooKeeper 作为注册中心的原因，以及自制的 NameServer 优缺点？"></a>2.1.10 RocketMQ 不使用 ZooKeeper 作为注册中心的原因，以及自制的 NameServer 优缺点？</h3><ol>
<li>ZooKeeper 作为支持顺序一致性的中间件，在某些情况下，它为了满足一致性，会丢失一定时间内的可用性，RocketMQ 需要注册中心只是为了发现组件地址，在某些情况下，RocketMQ 的注册中心可以出现数据不一致性，这同时也是 NameServer 的缺点，因为 NameServer 集群间互不通信，它们之间的注册信息可能会不一致</li>
<li>另外，当有新的服务器加入时，NameServer 并不会立马通知到 Produer，而是由 Produer 定时去请求 NameServer 获取最新的 Broker/Consumer 信息（这种情况是通过 Producer 发送消息时，负载均衡解决）</li>
</ol>
<h3 id="2-1-11-其它"><a href="#2-1-11-其它" class="headerlink" title="2.1.11 其它"></a>2.1.11 其它</h3><p><img src="https://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/somephoto/RocketMQ%E6%B5%81%E7%A8%8B.png"></p>
<p>加分项咯 </p>
<ol>
<li>包括组件通信间使用 Netty 的自定义协议</li>
<li>消息重试负载均衡策略（具体参考 Dubbo 负载均衡策略）</li>
<li>消息过滤器（Producer 发送消息到 Broker，Broker 存储消息信息，Consumer 消费时请求 Broker 端从磁盘文件查询消息文件时,在 Broker 端就使用过滤服务器进行过滤）  </li>
<li>Broker 同步双写和异步双写中 Master 和 Slave 的交互</li>
<li>Broker 在 4.5.0 版本更新中引入了基于 Raft 协议的多副本选举，之前这是商业版才有的特性 <a target="_blank" rel="noopener" href="http://rocketmq.apache.org/release_notes/release-notes-4.5.0/">ISSUE-1046</a></li>
</ol>
<h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h1><ol>
<li>《RocketMQ技术内幕》：<a target="_blank" rel="noopener" href="https://blog.csdn.net/prestigeding/article/details/85233529">https://blog.csdn.net/prestigeding/article/details/85233529</a></li>
<li>关于 RocketMQ 对 MappedByteBuffer 的一点优化：<a target="_blank" rel="noopener" href="https://lishoubo.github.io/2017/09/27/MappedByteBuffer%E7%9A%84%E4%B8%80%E7%82%B9%E4%BC%98%E5%8C%96/">https://lishoubo.github.io/2017/09/27/MappedByteBuffer%E7%9A%84%E4%B8%80%E7%82%B9%E4%BC%98%E5%8C%96/</a></li>
<li>阿里中间件团队博客-十分钟入门RocketMQ：<a target="_blank" rel="noopener" href="http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/">http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/</a></li>
<li>分布式事务的种类以及 RocketMQ 支持的分布式消息：<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/2018/08/rocketmq-4.3-release">https://www.infoq.cn/article/2018/08/rocketmq-4.3-release</a></li>
<li>滴滴出行基于RocketMQ构建企业级消息队列服务的实践：<a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/664608">https://yq.aliyun.com/articles/664608</a></li>
<li>基于《RocketMQ技术内幕》源码注释：<a target="_blank" rel="noopener" href="https://github.com/LiWenGu/awesome-rocketmq">https://github.com/LiWenGu/awesome-rocketmq</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/distributed-system/message-queue/RocketMQ-Questions/" data-id="cks75dy61000e7kve0f2w97yf" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-system-design/distributed-system/message-queue/RabbitMQ入门看这一篇就够了" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/system-design/distributed-system/message-queue/RabbitMQ%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T07:03:46.982Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- TOC -->

<ul>
<li><a href="#%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82-rabbitmq-%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85">一文搞懂 RabbitMQ 的重要概念以及安装</a><ul>
<li><a href="#%E4%B8%80-rabbitmq-%E4%BB%8B%E7%BB%8D">一 RabbitMQ 介绍</a><ul>
<li><a href="#11-rabbitmq-%E7%AE%80%E4%BB%8B">1.1 RabbitMQ 简介</a></li>
<li><a href="#12-rabbitmq-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">1.2 RabbitMQ 核心概念</a><ul>
<li><a href="#121-producer%E7%94%9F%E4%BA%A7%E8%80%85-%E5%92%8C-consumer%E6%B6%88%E8%B4%B9%E8%80%85">1.2.1 Producer(生产者) 和 Consumer(消费者)</a></li>
<li><a href="#122-exchange%E4%BA%A4%E6%8D%A2%E5%99%A8">1.2.2 Exchange(交换器)</a></li>
<li><a href="#123-queue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">1.2.3 Queue(消息队列)</a></li>
<li><a href="#124-broker%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9">1.2.4 Broker（消息中间件的服务节点）</a></li>
<li><a href="#125-exchange-types%E4%BA%A4%E6%8D%A2%E5%99%A8%E7%B1%BB%E5%9E%8B">1.2.5 Exchange Types(交换器类型)</a><ul>
<li><a href="#-fanout">① fanout</a></li>
<li><a href="#-direct">② direct</a></li>
<li><a href="#-topic">③ topic</a></li>
<li><a href="#-headers%E4%B8%8D%E6%8E%A8%E8%8D%90">④ headers(不推荐)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C-%E5%AE%89%E8%A3%85-rabbitmq">二 安装 RabbitMq</a><ul>
<li><a href="#21-%E5%AE%89%E8%A3%85-erlang">2.1 安装 erlang</a></li>
<li><a href="#22-%E5%AE%89%E8%A3%85-rabbitmq">2.2 安装 RabbitMQ</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->

<h1 id="一文搞懂-RabbitMQ-的重要概念以及安装"><a href="#一文搞懂-RabbitMQ-的重要概念以及安装" class="headerlink" title="一文搞懂 RabbitMQ 的重要概念以及安装"></a>一文搞懂 RabbitMQ 的重要概念以及安装</h1><h2 id="一-RabbitMQ-介绍"><a href="#一-RabbitMQ-介绍" class="headerlink" title="一 RabbitMQ 介绍"></a>一 RabbitMQ 介绍</h2><p>这部分参考了 《RabbitMQ实战指南》这本书的第 1 章和第 2 章。</p>
<h3 id="1-1-RabbitMQ-简介"><a href="#1-1-RabbitMQ-简介" class="headerlink" title="1.1 RabbitMQ 简介"></a>1.1 RabbitMQ 简介</h3><p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p>
<p>RabbitMQ 发展到今天，被越来越多的人认可，这和它在易用性、扩展性、可靠性和高可用性等方面的卓著表现是分不开的。RabbitMQ 的具体特点可以概括为以下几点：</p>
<ul>
<li><strong>可靠性：</strong> RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li>
<li><strong>灵活的路由：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。这个后面会在我们将 RabbitMQ 核心概念的时候详细介绍到。</li>
<li><strong>扩展性：</strong> 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>
<li><strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li>
<li><strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li>
<li><strong>多语言客户端：</strong> RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript等。</li>
<li><strong>易用的管理界面：</strong> RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li>
<li><strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI机制。</li>
</ul>
<h3 id="1-2-RabbitMQ-核心概念"><a href="#1-2-RabbitMQ-核心概念" class="headerlink" title="1.2 RabbitMQ 核心概念"></a>1.2 RabbitMQ 核心概念</h3><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p>
<p>下面再来看看图1—— RabbitMQ 的整体模型架构。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/96388546.jpg" alt="图1-RabbitMQ 的整体模型架构"></p>
<p>下面我会一一介绍上图中的一些概念。</p>
<h4 id="1-2-1-Producer-生产者-和-Consumer-消费者"><a href="#1-2-1-Producer-生产者-和-Consumer-消费者" class="headerlink" title="1.2.1 Producer(生产者) 和 Consumer(消费者)"></a>1.2.1 Producer(生产者) 和 Consumer(消费者)</h4><ul>
<li><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</li>
<li><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</li>
</ul>
<p>消息一般由 2 部分组成：<strong>消息头</strong>（或者说是标签 Label）和 <strong>消息体</strong>。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</p>
<h4 id="1-2-2-Exchange-交换器"><a href="#1-2-2-Exchange-交换器" class="headerlink" title="1.2.2 Exchange(交换器)"></a>1.2.2 Exchange(交换器)</h4><p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，<strong>Exchange(交换器)</strong> 会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong> 中。</p>
<p><strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。</p>
<p><strong>RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略</strong>：<strong>direct(默认)<strong>，</strong>fanout</strong>, <strong>topic</strong>, 和 <strong>headers</strong>，不同类型的Exchange转发消息的策略有所区别。这个会在介绍 <strong>Exchange Types(交换器类型)</strong> 的时候介绍到。</p>
<p>Exchange(交换器) 示意图如下：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/24007899.jpg" alt="Exchange(交换器) 示意图"></p>
<p>生产者将消息发给交换器的时候，一般会指定一个 **RoutingKey(路由键)**，用来指定这个消息的路由规则，而这个 <strong>RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效</strong>。</p>
<p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</p>
<p>Binding(绑定) 示意图：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/70553134.jpg" alt="Binding(绑定) 示意图"></p>
<p>生产者将消息发送给交换器时，需要一个RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p>
<h4 id="1-2-3-Queue-消息队列"><a href="#1-2-3-Queue-消息队列" class="headerlink" title="1.2.3 Queue(消息队列)"></a>1.2.3 Queue(消息队列)</h4><p><strong>Queue(消息队列)</strong> 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>
<p><strong>RabbitMQ</strong> 中消息只能存储在 <strong>队列</strong> 中，这一点和 <strong>Kafka</strong> 这种消息中间件相反。Kafka 将消息存储在 <strong>topic（主题）</strong> 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。</p>
<p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免的消息被重复消费。</p>
<p><strong>RabbitMQ</strong> 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p>
<h4 id="1-2-4-Broker（消息中间件的服务节点）"><a href="#1-2-4-Broker（消息中间件的服务节点）" class="headerlink" title="1.2.4 Broker（消息中间件的服务节点）"></a>1.2.4 Broker（消息中间件的服务节点）</h4><p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p>
<p>下图展示了生产者将消息存入 RabbitMQ Broker,以及消费者从Broker中消费数据的整个流程。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/67952922.jpg" alt="消息队列的运转过程"></p>
<p>这样图1中的一些关于 RabbitMQ 的基本概念我们就介绍完毕了，下面再来介绍一下 <strong>Exchange Types(交换器类型)</strong> 。</p>
<h4 id="1-2-5-Exchange-Types-交换器类型"><a href="#1-2-5-Exchange-Types-交换器类型" class="headerlink" title="1.2.5 Exchange Types(交换器类型)"></a>1.2.5 Exchange Types(交换器类型)</h4><p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种（AMQP规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。</p>
<h5 id="①-fanout"><a href="#①-fanout" class="headerlink" title="① fanout"></a>① fanout</h5><p>fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</p>
<h5 id="②-direct"><a href="#②-direct" class="headerlink" title="② direct"></a>② direct</h5><p>direct 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。 </p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/37008021.jpg" alt="direct 类型交换器"></p>
<p>以上图为例，如果发送消息的时候设置路由键为“warning”,那么消息会路由到 Queue1 和 Queue2。如果在发送消息的时候设置路由键为”Info”或者”debug”，消息只会路由到Queue2。如果以其他的路由键发送消息，则消息不会路由到这两个队列中。</p>
<p>direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p>
<h5 id="③-topic"><a href="#③-topic" class="headerlink" title="③ topic"></a>③ topic</h5><p>前面讲到direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p>
<ul>
<li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li>
<li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li>
<li>BindingKey 中可以存在两种特殊字符串“*”和“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li>
</ul>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-16/73843.jpg" alt="topic 类型交换器"></p>
<p>以上图为例：</p>
<ul>
<li>路由键为 “com.rabbitmq.client” 的消息会同时路由到 Queuel 和 Queue2;</li>
<li>路由键为 “com.hidden.client” 的消息只会路由到 Queue2 中；</li>
<li>路由键为 “com.hidden.demo” 的消息只会路由到 Queue2 中；</li>
<li>路由键为 “java.rabbitmq.demo” 的消息只会路由到Queuel中；</li>
<li>路由键为 “java.util.concurrent” 的消息将会被丢弃或者返回给生产者（需要设置 mandatory 参数），因为它没有匹配任何路由键。</li>
</ul>
<h5 id="④-headers-不推荐"><a href="#④-headers-不推荐" class="headerlink" title="④ headers(不推荐)"></a>④ headers(不推荐)</h5><p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)’对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p>
<h2 id="二-安装-RabbitMq"><a href="#二-安装-RabbitMq" class="headerlink" title="二 安装 RabbitMq"></a>二 安装 RabbitMq</h2><p>通过 Docker 安装非常方便，只需要几条命令就好了，我这里是只说一下常规安装方法。</p>
<p>前面提到了 RabbitMQ 是由 Erlang语言编写的，也正因如此，在安装RabbitMQ 之前需要安装 Erlang。</p>
<p>注意：在安装 RabbitMQ 的时候需要注意 RabbitMQ 和 Erlang 的版本关系，如果不注意的话会导致出错，两者对应关系如下:</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/RabbitMQ-Erlang.png" alt="RabbitMQ 和 Erlang 的版本关系"></p>
<h3 id="2-1-安装-erlang"><a href="#2-1-安装-erlang" class="headerlink" title="2.1 安装 erlang"></a>2.1 安装 erlang</h3><p><strong>1 下载 erlang 安装包</strong></p>
<p>在官网下载然后上传到 Linux 上或者直接使用下面的命令下载对应的版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]#wget https://erlang.org/download/otp_src_19.3.tar.gz</span><br></pre></td></tr></table></figure>

<p>erlang 官网下载：<a target="_blank" rel="noopener" href="https://www.erlang.org/downloads">https://www.erlang.org/downloads</a>  </p>
<p> <strong>2 解压 erlang 安装包</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]#tar -xvzf otp_src_19.3.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>3 删除 erlang 安装包</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]#rm -rf otp_src_19.3.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>4 安装 erlang 的依赖工具</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]#yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC-devel</span><br></pre></td></tr></table></figure>

<p><strong>5 进入erlang 安装包解压文件对 erlang 进行安装环境的配置</strong></p>
<p>新建一个文件夹</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]# mkdir erlang</span><br></pre></td></tr></table></figure>

<p>对 erlang 进行安装环境的配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb otp_src_19.3]# </span><br><span class="line">./configure --prefix=/usr/local/erlang --without-javac</span><br></pre></td></tr></table></figure>

<p><strong>6 编译安装</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb otp_src_19.3]# </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p><strong>7 验证一下 erlang 是否安装成功了</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb otp_src_19.3]# ./bin/erl</span><br></pre></td></tr></table></figure>
<p>运行下面的语句输出“hello world”</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io:format(<span class="string">&quot;hello world~n&quot;</span>, []).</span><br></pre></td></tr></table></figure>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-12/49570541.jpg" alt="输出“hello world”"></p>
<p>大功告成，我们的 erlang 已经安装完成。</p>
<p><strong>8 配置  erlang 环境变量</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb etc]# vim profile</span><br></pre></td></tr></table></figure>

<p>追加下列环境变量到文件末尾</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">erlang</span></span><br><span class="line">ERL_HOME=/usr/local/erlang</span><br><span class="line">PATH=$ERL_HOME/bin:$PATH</span><br><span class="line">export ERL_HOME PATH</span><br></pre></td></tr></table></figure>

<p>运行下列命令使配置文件<code>profile</code>生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb etc]# source /etc/profile</span><br></pre></td></tr></table></figure>

<p>输入 erl 查看 erlang 环境变量是否配置正确</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb etc]# erl</span><br></pre></td></tr></table></figure>

<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-12/62504246.jpg" alt="输入 erl 查看 erlang 环境变量是否配置正确"></p>
<h3 id="2-2-安装-RabbitMQ"><a href="#2-2-安装-RabbitMQ" class="headerlink" title="2.2 安装 RabbitMQ"></a>2.2 安装 RabbitMQ</h3><p><strong>1. 下载rpm</strong> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.rabbitmq.com/releases/rabbitmq-server/v3.6.8/rabbitmq-server-3.6.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>或者直接在官网下载</p>
<p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/install-rpm.html">https://www.rabbitmq.com/install-rpm.html</a></p>
<p><strong>2. 安装rpm</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc</span><br></pre></td></tr></table></figure>
<p>紧接着执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install rabbitmq-server-3.6.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>中途需要你输入”y”才能继续安装。</p>
<p><strong>3 开启 web 管理插件</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<p><strong>4 设置开机启动</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig rabbitmq-server on</span><br></pre></td></tr></table></figure>

<p><strong>4. 启动服务</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service rabbitmq-server start</span><br></pre></td></tr></table></figure>

<p><strong>5. 查看服务状态</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service rabbitmq-server status</span><br></pre></td></tr></table></figure>

<p><strong>6. 访问 RabbitMQ 控制台</strong></p>
<p>浏览器访问：http://你的ip地址:15672/</p>
<p>默认用户名和密码： guest/guest;但是需要注意的是：guestuest用户只是被容许从localhost访问。官网文档描述如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“guest” user can only connect via localhost</span><br></pre></td></tr></table></figure>

<p><strong>解决远程访问 RabbitMQ 远程访问密码错误</strong></p>
<p>新建用户并授权 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb rabbitmq]# rabbitmqctl add_user root root</span><br><span class="line">Creating user &quot;root&quot; ...</span><br><span class="line">[root@SnailClimb rabbitmq]# rabbitmqctl set_user_tags root administrator</span><br><span class="line"></span><br><span class="line">Setting tags for user &quot;root&quot; to [administrator] ...</span><br><span class="line">[root@SnailClimb rabbitmq]# </span><br><span class="line">[root@SnailClimb rabbitmq]# rabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">Setting permissions for user &quot;root&quot; in vhost &quot;/&quot; ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再次访问:http://你的ip地址:15672/ ,输入用户名和密码：root root</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-12/45835332.jpg" alt="RabbitMQ控制台"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/system-design/distributed-system/message-queue/RabbitMQ%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/" data-id="cks75dy69000m7kve0bey2job" data-title="" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/11/system-design/website-architecture/%E5%85%B3%E4%BA%8E%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%87%82%E7%9A%8410%E4%B8%AA%E9%97%AE%E9%A2%98/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/11/system-design/website-architecture/8%20%E5%BC%A0%E5%9B%BE%E8%AF%BB%E6%87%82%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/11/system-design/micro-service/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E6%80%BB%E7%BB%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/11/system-design/micro-service/spring-cloud/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/11/system-design/high-availability/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%A6%81%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>